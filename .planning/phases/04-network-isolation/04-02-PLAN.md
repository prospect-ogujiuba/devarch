---
phase: 04-network-isolation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - api/internal/api/handlers/instance_effective.go
  - dashboard/src/types/api.ts
  - dashboard/src/features/stacks/queries.ts
  - dashboard/src/routes/stacks/$name.tsx
  - dashboard/src/routes/stacks/index.tsx
  - dashboard/src/components/stacks/stack-grid.tsx
  - dashboard/src/components/stacks/stack-table.tsx
autonomous: true

must_haves:
  truths:
    - "Effective config response includes devarch.* identity labels for the instance"
    - "Stack detail page shows dedicated Network card with status, network name, and connected containers"
    - "Stack list page shows network status indicator per stack"
    - "Network card distinguishes active vs not-created network states with different visual treatment"
  artifacts:
    - path: "api/internal/api/handlers/instance_effective.go"
      provides: "Identity label injection in effective config"
      contains: "devarch.stack_id"
    - path: "dashboard/src/features/stacks/queries.ts"
      provides: "useStackNetwork query hook"
      contains: "useStackNetwork"
    - path: "dashboard/src/types/api.ts"
      provides: "NetworkStatus type definition"
      contains: "NetworkStatus"
    - path: "dashboard/src/routes/stacks/$name.tsx"
      provides: "Enhanced Network card with live status"
      contains: "useStackNetwork"
  key_links:
    - from: "dashboard/src/routes/stacks/$name.tsx"
      to: "dashboard/src/features/stacks/queries.ts"
      via: "useStackNetwork hook consuming GET /stacks/{name}/network"
      pattern: "useStackNetwork"
    - from: "api/internal/api/handlers/instance_effective.go"
      to: "api/internal/container/labels.go"
      via: "BuildLabels call to inject identity labels"
      pattern: "BuildLabels"
---

<objective>
Inject identity labels into effective config and build dashboard network visibility UI (stack detail network card with live status, stack list network badges).

Purpose: NETW-04 requires identity labels on all stack containers — effective config is where labels are assembled before compose generation. Dashboard network UI gives users visibility into network state per the phase context decisions (dedicated Network tab, network status badges, network icon visual language).

Output: Effective config includes devarch.* labels. Dashboard shows network status on stack detail and list pages.
</objective>

<execution_context>
@/home/fhcadmin/.claude/get-shit-done/workflows/execute-plan.md
@/home/fhcadmin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-network-isolation/04-CONTEXT.md
@.planning/phases/04-network-isolation/04-RESEARCH.md
@.planning/phases/04-network-isolation/04-01-SUMMARY.md
@api/internal/api/handlers/instance_effective.go
@api/internal/container/labels.go
@dashboard/src/types/api.ts
@dashboard/src/features/stacks/queries.ts
@dashboard/src/routes/stacks/$name.tsx
@dashboard/src/routes/stacks/index.tsx
@dashboard/src/components/stacks/stack-grid.tsx
@dashboard/src/components/stacks/stack-table.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject identity labels into effective config response</name>
  <files>
    api/internal/api/handlers/instance_effective.go
  </files>
  <action>
  In the `EffectiveConfig` handler, after merging template labels with override labels, inject the devarch identity labels. This ensures that when Phase 5 (compose generation) reads effective config, the labels are already present.

  1. After the label merge section, call `container.BuildLabels(stackName, instanceName, strconv.Itoa(templateServiceID))` to get identity labels.

  2. For each identity label (devarch.stack_id, devarch.instance_id, devarch.template_service_id, devarch.managed_by, devarch.version):
     - Check if user hasn't already overridden it (user overrides win per 03-02 decision).
     - If not overridden, append to the labels slice as `models.ServiceLabel{Key: k, Value: v}`.

  3. This follows the existing pattern in 03-02 where system labels (devarch.*) are validated at API layer and auto-injected in effective config. The override PUT handlers already reject user-set devarch.* labels. So injection here is safe — no user override will conflict.

  4. Import `"strconv"` and `"github.com/priz/devarch-api/internal/container"` if not already imported in this file.
  </action>
  <verify>
  - `cd api && go build ./...` succeeds.
  - `grep "BuildLabels" api/internal/api/handlers/instance_effective.go` shows the injection call.
  - `grep "devarch.stack_id\|LabelStackID" api/internal/api/handlers/instance_effective.go` confirms identity labels referenced.
  </verify>
  <done>
  - Effective config response always includes devarch.stack_id, devarch.instance_id, devarch.template_service_id, devarch.managed_by, devarch.version labels.
  - User label overrides are preserved (identity labels only added if not already present).
  - Code compiles and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dashboard network status types, query hook, and UI components</name>
  <files>
    dashboard/src/types/api.ts
    dashboard/src/features/stacks/queries.ts
    dashboard/src/routes/stacks/$name.tsx
    dashboard/src/routes/stacks/index.tsx
    dashboard/src/components/stacks/stack-grid.tsx
    dashboard/src/components/stacks/stack-table.tsx
  </files>
  <action>
  **types/api.ts:**
  Add `NetworkStatus` interface:
  ```typescript
  export interface NetworkStatus {
    network_name: string
    status: 'active' | 'not_created'
    driver: string
    containers: string[]
    labels: Record<string, string>
  }
  ```

  **features/stacks/queries.ts:**
  Add `useStackNetwork` query hook:
  ```typescript
  export function useStackNetwork(name: string) {
    return useQuery({
      queryKey: ['stacks', name, 'network'],
      queryFn: async () => {
        const response = await api.get<NetworkStatus>(`/stacks/${name}/network`)
        return response.data
      },
      enabled: !!name,
      refetchInterval: 10000, // Less frequent than stack polling — network changes rarely
    })
  }
  ```

  **routes/stacks/$name.tsx — Enhanced Network Card:**
  Replace the existing simple Network card (lines 355-371) with an enhanced version:

  1. Import `useStackNetwork` from queries and `Globe` (or `Network`) icon from lucide-react.

  2. The new Network card should show:
     - Network name as monospace code.
     - Status badge: green "Active" if status === 'active', gray "Not Created" if 'not_created'.
     - Use a globe/network icon (NOT the green/gray dots used for container status — different visual language per context decisions).
     - If active: list connected containers as small monospace items.
     - If active: show driver (e.g., "bridge").
     - DNS discovery hint: "Containers resolve each other by instance name within this network".

  3. Keep the card structure consistent with the existing stat cards above (Card/CardHeader/CardContent).

  **routes/stacks/index.tsx — Stack list network badge:**
  This file contains the StackListPage that renders StackGrid or StackTable. No direct changes needed here since grid/table are separate components.

  **components/stacks/stack-grid.tsx:**
  Add a small network status indicator to each stack card:
  - Import `Globe` from lucide-react.
  - Add a small inline indicator near the instance count or in the card footer.
  - Show network name with a tiny globe icon.
  - Color: use `text-blue-500` for network indicators (distinct from green/gray container status per context decisions).
  - Keep it minimal — just the network name and a globe icon, no full status query per card (would be N+1 API calls). Use the `network_name` field already in the Stack type.

  **components/stacks/stack-table.tsx:**
  Add a "Network" column to the stack table:
  - Show `stack.network_name` value or "—" if null.
  - Small monospace font for the network name.
  - Globe icon prefix.
  </action>
  <verify>
  - `cd dashboard && npm run build:strict` succeeds (TypeScript + Vite build with no errors).
  - `grep "NetworkStatus" dashboard/src/types/api.ts` shows the type.
  - `grep "useStackNetwork" dashboard/src/features/stacks/queries.ts` shows the hook.
  - `grep "useStackNetwork\|Globe\|network" dashboard/src/routes/stacks/\\$name.tsx` confirms network UI integration.
  - `grep "Globe\|network_name" dashboard/src/components/stacks/stack-grid.tsx` shows network indicator.
  - `grep "Globe\|network_name\|Network" dashboard/src/components/stacks/stack-table.tsx` shows network column.
  </verify>
  <done>
  - NetworkStatus type defined in api.ts.
  - useStackNetwork hook fetches from GET /stacks/{name}/network.
  - Stack detail page Network card shows live status (active/not_created), connected containers, network name, driver, DNS hint.
  - Stack grid cards show network name with globe icon.
  - Stack table has Network column.
  - Network indicators use distinct visual language (globe icon, blue coloring) from container status (dots, green/gray).
  - Dashboard builds with strict TypeScript checking.
  </done>
</task>

</tasks>

<verification>
1. `cd api && go build ./...` — compiles
2. `cd dashboard && npm run build:strict` — TypeScript strict build passes
3. Effective config response includes devarch.* identity labels
4. Stack detail page renders enhanced network card
5. Stack list shows network indicators in both grid and table views
</verification>

<success_criteria>
- Identity labels (devarch.stack_id, devarch.instance_id, devarch.template_service_id) injected in effective config
- Dashboard network card shows live status from container runtime
- Stack list views include network name visibility
- Network UI uses distinct visual language from container status indicators
- All code compiles with strict checks
</success_criteria>

<output>
After completion, create `.planning/phases/04-network-isolation/04-02-SUMMARY.md`
</output>
