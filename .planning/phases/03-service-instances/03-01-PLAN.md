---
phase: 03-service-instances
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/migrations/014_instance_overrides.up.sql
  - api/migrations/014_instance_overrides.down.sql
  - api/internal/api/handlers/instance.go
  - api/internal/api/routes.go
autonomous: true

must_haves:
  truths:
    - "Instance override tables exist for ports, volumes, env_vars, labels, domains, healthchecks, config_files"
    - "User can create instance in a stack from a template service"
    - "User can list instances in a stack"
    - "User can get instance detail with all overrides"
    - "User can update instance metadata (name, description, enabled)"
    - "User can delete instance (soft-delete matching stack pattern)"
    - "User can duplicate instance within same stack"
  artifacts:
    - path: "api/migrations/014_instance_overrides.up.sql"
      provides: "Override tables for all resource types"
      contains: "instance_ports"
    - path: "api/internal/api/handlers/instance.go"
      provides: "Instance CRUD handler"
      exports: ["InstanceHandler", "NewInstanceHandler"]
  key_links:
    - from: "api/internal/api/handlers/instance.go"
      to: "api/internal/api/routes.go"
      via: "chi route registration"
      pattern: "instanceHandler"
    - from: "api/migrations/014_instance_overrides.up.sql"
      to: "service_instances table"
      via: "foreign key references"
      pattern: "REFERENCES service_instances"
---

<objective>
Create the instance override database schema and instance CRUD API handler.

Purpose: Foundation for all instance operations — override tables store copy-on-write data, CRUD handler enables instance lifecycle management within stacks.
Output: Migration 014 with 7 override tables, InstanceHandler with create/list/get/update/delete/duplicate endpoints wired into routes.
</objective>

<execution_context>
@/home/priz/.claude/get-shit-done/workflows/execute-plan.md
@/home/priz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-service-instances/03-CONTEXT.md
@.planning/phases/03-service-instances/03-RESEARCH.md

@api/migrations/013_stacks_instances.up.sql
@api/internal/api/handlers/stack.go
@api/internal/api/handlers/service.go
@api/internal/api/routes.go
@dashboard/src/types/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration 014 — instance override tables</name>
  <files>api/migrations/014_instance_overrides.up.sql, api/migrations/014_instance_overrides.down.sql</files>
  <action>
Create migration 014 with these tables, all referencing service_instances(id) with ON DELETE CASCADE:

1. `instance_ports` — columns: id SERIAL PK, instance_id INT NOT NULL FK, host_ip VARCHAR(45) DEFAULT '0.0.0.0', host_port INT NOT NULL, container_port INT NOT NULL, protocol VARCHAR(10) DEFAULT 'tcp'
2. `instance_volumes` — columns: id SERIAL PK, instance_id INT NOT NULL FK, volume_type VARCHAR(20) DEFAULT 'bind', source TEXT NOT NULL, target TEXT NOT NULL, read_only BOOLEAN DEFAULT false, is_external BOOLEAN DEFAULT false
3. `instance_env_vars` — columns: id SERIAL PK, instance_id INT NOT NULL FK, key VARCHAR(255) NOT NULL, value TEXT, is_secret BOOLEAN DEFAULT false. Add UNIQUE(instance_id, key)
4. `instance_labels` — columns: id SERIAL PK, instance_id INT NOT NULL FK, key VARCHAR(255) NOT NULL, value TEXT NOT NULL. Add UNIQUE(instance_id, key)
5. `instance_domains` — columns: id SERIAL PK, instance_id INT NOT NULL FK, domain VARCHAR(255) NOT NULL, proxy_port INT
6. `instance_healthchecks` — columns: id SERIAL PK, instance_id INT NOT NULL FK (UNIQUE — one per instance), test TEXT NOT NULL, interval_seconds INT DEFAULT 30, timeout_seconds INT DEFAULT 10, retries INT DEFAULT 3, start_period_seconds INT DEFAULT 0
7. `instance_config_files` — columns: id SERIAL PK, instance_id INT NOT NULL FK, file_path TEXT NOT NULL, content TEXT NOT NULL, file_mode VARCHAR(10) DEFAULT '0644', is_template BOOLEAN DEFAULT false, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW(). Add UNIQUE(instance_id, file_path)

Also add columns to service_instances table (ALTER TABLE):
- `description TEXT DEFAULT ''`
- `deleted_at TIMESTAMPTZ DEFAULT NULL`

Add partial unique index: `CREATE UNIQUE INDEX uq_instances_stack_instance_active ON service_instances(stack_id, instance_id) WHERE deleted_at IS NULL;`
Drop the existing UNIQUE(stack_id, instance_id) constraint first since we need the partial index instead.

Add indexes on instance_id for all override tables.

Down migration drops all 7 tables, drops the added columns, re-adds the simple unique constraint.

Mirror column types from existing service_* tables (service_ports, service_volumes, etc.) — these override tables are intentional copies.
  </action>
  <verify>Run `cd /home/priz/projects/devarch && docker compose exec api go run ./cmd/migrate -migrations ./migrations` — migration applies without error. Check with psql that all tables exist.</verify>
  <done>7 instance override tables created, service_instances has description + deleted_at + partial unique index</done>
</task>

<task type="auto">
  <name>Task 2: Instance CRUD handler + route wiring</name>
  <files>api/internal/api/handlers/instance.go, api/internal/api/routes.go</files>
  <action>
Create InstanceHandler struct with db *sql.DB field. Follow StackHandler patterns exactly.

Response types:
- `instanceResponse` — id, stack_id, instance_id (name), template_service_id, template_name (joined), container_name, description, enabled, override_count (computed), created_at, updated_at
- `createInstanceRequest` — instance_id (name), template_service_id (required), description (optional)
- `updateInstanceRequest` — description, enabled

Endpoints:

**Create (POST):**
- Validate instance_id with container.ValidateName
- Verify stack exists and is active (deleted_at IS NULL) — 404 if not
- Verify template_service_id exists in services table — 400 if not
- Generate container_name as `devarch-{stack_name}-{instance_id}`
- INSERT with RETURNING, handle unique constraint (23505) with prescriptive error
- Return 201 with instanceResponse

**List (GET):**
- Query instances WHERE stack_id matches AND deleted_at IS NULL
- JOIN services ON template_service_id to get template_name
- Compute override_count as SUM of counts from all 7 override tables (use subquery or lateral join)
- Support ?search, ?enabled query params
- ORDER BY created_at ASC (creation order per CONTEXT.md)
- Return array of instanceResponse

**Get (GET):**
- Lookup by stack name + instance_id from URL
- Load all overrides in separate queries (ports, volumes, env_vars, labels, domains, healthcheck, config_files)
- Return instanceResponse with nested override arrays

**Update (PUT):**
- Update description and/or enabled
- Validate instance exists and is active
- Return updated instanceResponse

**Delete (DELETE):**
- Soft-delete: SET deleted_at = NOW()
- Return 204

**Duplicate (POST /duplicate):**
- Clone instance with new name (auto-generate: `{instance_id}-copy`, let user override via `instance_id` in body)
- Copy all override records from source to new instance
- Use transaction for atomicity
- Return 201 with new instanceResponse

**Rename (PUT /rename):**
- Accept new instance_id in body
- Validate new name, check uniqueness within stack
- Direct UPDATE (no clone+delete — instances are just DB records per CONTEXT.md)
- Update container_name to `devarch-{stack}-{new_instance_id}`
- Return updated instanceResponse

**Delete Preview (GET /delete-preview):**
- Return instance name, template name, override count, container_name

Wire into routes.go under `/stacks/{name}`:
```
r.Route("/instances", func(r chi.Router) {
    r.Get("/", instanceHandler.List)
    r.Post("/", instanceHandler.Create)
    r.Route("/{instance}", func(r chi.Router) {
        r.Get("/", instanceHandler.Get)
        r.Put("/", instanceHandler.Update)
        r.Delete("/", instanceHandler.Delete)
        r.Post("/duplicate", instanceHandler.Duplicate)
        r.Put("/rename", instanceHandler.Rename)
        r.Get("/delete-preview", instanceHandler.DeletePreview)
    })
})
```

Use chi.URLParam(r, "name") for stack, chi.URLParam(r, "instance") for instance_id. Resolve stack_id via query early in each handler (helper function getStackByName).
  </action>
  <verify>
Build: `cd /home/priz/projects/devarch/api && go build ./cmd/server`
Test API manually:
- `curl -H "X-API-Key: test" http://localhost:8550/api/v1/stacks/test-stack/instances` returns 200 (empty array or 404 if stack doesn't exist)
  </verify>
  <done>Instance CRUD endpoints respond correctly, routes registered under /stacks/{name}/instances/{instance}</done>
</task>

</tasks>

<verification>
- Migration 014 applies cleanly (up and down)
- All 7 override tables exist with correct columns and FK constraints
- Instance CRUD endpoints return proper HTTP status codes
- `go build ./cmd/server` succeeds
- Container name follows `devarch-{stack}-{instance}` pattern
</verification>

<success_criteria>
- Instance can be created within a stack from a template
- Instance can be listed, retrieved, updated, soft-deleted, duplicated, renamed
- Override tables ready for data (Plan 02 adds PUT handlers)
- Routes wired under /stacks/{name}/instances/{instance}
</success_criteria>

<output>
After completion, create `.planning/phases/03-service-instances/03-01-SUMMARY.md`
</output>
