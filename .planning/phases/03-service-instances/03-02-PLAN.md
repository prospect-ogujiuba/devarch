---
phase: 03-service-instances
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - api/internal/api/handlers/instance.go
  - api/internal/api/handlers/instance_overrides.go
  - api/internal/api/handlers/instance_effective.go
  - api/internal/api/routes.go
autonomous: true

must_haves:
  truths:
    - "User can override instance ports via API"
    - "User can override instance volumes via API"
    - "User can override instance env vars via API"
    - "User can override instance labels via API"
    - "User can override instance domains via API"
    - "User can override instance healthcheck via API"
    - "User can override instance config files via API"
    - "Effective config returns merged template + overrides (overrides win)"
  artifacts:
    - path: "api/internal/api/handlers/instance_overrides.go"
      provides: "PUT handlers for all 7 override types"
      exports: ["UpdatePorts", "UpdateVolumes", "UpdateEnvVars", "UpdateLabels", "UpdateDomains", "UpdateHealthcheck"]
    - path: "api/internal/api/handlers/instance_effective.go"
      provides: "Effective config merge resolver"
      exports: ["EffectiveConfig"]
  key_links:
    - from: "instance_overrides.go"
      to: "instance_* tables"
      via: "DELETE + INSERT pattern"
      pattern: "DELETE FROM instance_"
    - from: "instance_effective.go"
      to: "service_* tables + instance_* tables"
      via: "template query + override query + merge"
      pattern: "service_ports|instance_ports"
---

<objective>
Add override PUT endpoints for all 7 resource types and the effective config resolver.

Purpose: Enables full copy-on-write override editing via API, plus the merged config view that shows what will actually run.
Output: Override PUT handlers, config file CRUD, effective config GET endpoint — all wired into routes.
</objective>

<execution_context>
@/home/priz/.claude/get-shit-done/workflows/execute-plan.md
@/home/priz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-service-instances/03-CONTEXT.md
@.planning/phases/03-service-instances/03-RESEARCH.md
@.planning/phases/03-service-instances/03-01-SUMMARY.md

@api/internal/api/handlers/service.go
@api/internal/api/handlers/instance.go
@api/internal/api/routes.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Override PUT handlers for all resource types</name>
  <files>api/internal/api/handlers/instance_overrides.go, api/internal/api/routes.go</files>
  <action>
Create instance_overrides.go with methods on *InstanceHandler. Follow the existing ServiceHandler.UpdatePorts/UpdateVolumes/etc. pattern exactly: decode JSON array, DELETE all existing rows for that instance, INSERT new rows in a transaction, return the saved rows.

Each handler: resolve stack by name, resolve instance by instance_id within stack, validate instance is active.

**PUT /ports** — accepts array of {host_ip, host_port, container_port, protocol}. Full replacement.
**PUT /volumes** — accepts array of {volume_type, source, target, read_only, is_external}. Full replacement.
**PUT /env-vars** — accepts array of {key, value, is_secret}. Full replacement (key-based merge happens in effective config, not here — overrides are stored as-is).
**PUT /labels** — accepts array of {key, value}. Full replacement. Reject keys starting with "devarch." — those are system-managed (return 400 with message).
**PUT /domains** — accepts array of {domain, proxy_port}. Full replacement.
**PUT /healthcheck** — accepts single object {test, interval_seconds, timeout_seconds, retries, start_period_seconds}. DELETE existing + INSERT new. One per instance.

Config files need CRUD (not just PUT), add to instance.go or a separate section in overrides:
**GET /files** — list config files for instance
**GET /files/** — get single config file by path
**PUT /files/** — create/update config file (upsert by instance_id + file_path)
**DELETE /files/** — delete single config file

Wire all into routes.go under `/stacks/{name}/instances/{instance}`:
```
r.Put("/ports", instanceHandler.UpdatePorts)
r.Put("/volumes", instanceHandler.UpdateVolumes)
r.Put("/env-vars", instanceHandler.UpdateEnvVars)
r.Put("/labels", instanceHandler.UpdateLabels)
r.Put("/domains", instanceHandler.UpdateDomains)
r.Put("/healthcheck", instanceHandler.UpdateHealthcheck)
r.Get("/files", instanceHandler.ListConfigFiles)
r.Get("/files/*", instanceHandler.GetConfigFile)
r.Put("/files/*", instanceHandler.PutConfigFile)
r.Delete("/files/*", instanceHandler.DeleteConfigFile)
```
  </action>
  <verify>`cd /home/priz/projects/devarch/api && go build ./cmd/server` — compiles. Test: `curl -X PUT -H "X-API-Key: test" -d '[]' http://localhost:8550/api/v1/stacks/{stack}/instances/{inst}/ports` returns 200.</verify>
  <done>All 7 override types have working PUT endpoints, config files have full CRUD</done>
</task>

<task type="auto">
  <name>Task 2: Effective config resolver endpoint</name>
  <files>api/internal/api/handlers/instance_effective.go, api/internal/api/routes.go</files>
  <action>
Create instance_effective.go with EffectiveConfig method on *InstanceHandler.

**GET /effective-config:**

1. Resolve stack + instance (same helpers as CRUD)
2. Load template service by template_service_id — get all service data:
   - service record (image_name, image_tag, restart_policy, command, user_spec)
   - service_ports, service_volumes, service_env_vars, service_dependencies, service_labels, service_domains, service_healthchecks, service_config_files
3. Load all instance overrides (7 tables)
4. Merge with these semantics (from RESEARCH.md):
   - **Ports**: If instance has any port overrides, use ONLY instance ports (full replacement)
   - **Volumes**: If instance has any volume overrides, use ONLY instance volumes (full replacement)
   - **Env vars**: Key-based merge — start with template env vars, override/add from instance env vars (instance wins on key collision)
   - **Labels**: Key-based merge — same as env vars. Prepend devarch.* system labels (stack_id, instance_id, template_service_id) — these are always present and read-only
   - **Domains**: If instance has any domain overrides, use ONLY instance domains (full replacement)
   - **Healthcheck**: If instance has healthcheck override, use it entirely (full replacement). Otherwise template healthcheck.
   - **Dependencies**: Template only — NOT overridable (per CONTEXT.md decision)
   - **Config files**: Path-based merge — start with template files, override from instance files (instance wins on path collision)
5. Return effective config as JSON:
```json
{
  "instance_id": "...",
  "template_name": "...",
  "image_name": "...",
  "image_tag": "...",
  "restart_policy": "...",
  "command": "...",
  "container_name": "devarch-{stack}-{instance}",
  "ports": [...],
  "volumes": [...],
  "env_vars": [...],
  "dependencies": [...],
  "labels": [...],
  "domains": [...],
  "healthcheck": {...} or null,
  "config_files": [...],
  "overrides_applied": {
    "ports": true/false,
    "volumes": true/false,
    "env_vars": ["KEY1", "KEY2"],
    "labels": ["key1"],
    "domains": true/false,
    "healthcheck": true/false,
    "config_files": ["path1"]
  }
}
```

The `overrides_applied` field tells the UI which values came from overrides vs template. For key-based merges (env_vars, labels, config_files), list the specific keys that were overridden. For full-replacement types (ports, volumes, domains, healthcheck), use boolean.

Wire route: `r.Get("/effective-config", instanceHandler.EffectiveConfig)`
  </action>
  <verify>`go build ./cmd/server` compiles. Test with curl: create instance, add port override, GET effective-config shows merged result with template data + override ports.</verify>
  <done>Effective config endpoint returns correctly merged template + overrides with override tracking metadata</done>
</task>

</tasks>

<verification>
- All override PUT endpoints accept and persist data
- Label override rejects devarch.* prefixed keys
- Effective config merges correctly: full-replacement for ports/volumes/domains/healthcheck, key-merge for env_vars/labels/config_files
- Dependencies come from template only in effective config
- overrides_applied metadata accurately tracks which values are overridden
</verification>

<success_criteria>
- Complete override API coverage for all 7 resource types
- Effective config resolver produces correct merged output
- Override tracking metadata enables UI to distinguish overridden vs template values
</success_criteria>

<output>
After completion, create `.planning/phases/03-service-instances/03-02-SUMMARY.md`
</output>
