---
phase: 03-service-instances
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - dashboard/src/types/api.ts
  - dashboard/src/lib/api.ts
  - dashboard/src/lib/instance-queries.ts
  - dashboard/src/components/stacks/add-instance-dialog.tsx
  - dashboard/src/routes/stacks/$name.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard has TypeScript types for instances and all override types"
    - "TanStack Query hooks exist for instance CRUD and overrides"
    - "User can add instance to stack from template catalog via dialog"
    - "Stack detail page shows instance list with rich cards"
    - "Empty stack shows CTA to add first service"
  artifacts:
    - path: "dashboard/src/types/api.ts"
      provides: "Instance and override TypeScript types"
      contains: "InstanceOverrides"
    - path: "dashboard/src/lib/instance-queries.ts"
      provides: "TanStack Query hooks for instances"
      exports: ["useInstances", "useInstance", "useCreateInstance"]
    - path: "dashboard/src/components/stacks/add-instance-dialog.tsx"
      provides: "Template catalog dialog for adding instances"
  key_links:
    - from: "dashboard/src/lib/instance-queries.ts"
      to: "/api/v1/stacks/{name}/instances"
      via: "fetch calls"
      pattern: "stacks.*instances"
    - from: "dashboard/src/routes/stacks/$name.tsx"
      to: "dashboard/src/lib/instance-queries.ts"
      via: "useInstances hook"
      pattern: "useInstances"
---

<objective>
Add dashboard types, query hooks, and instance list UI on the stack detail page.

Purpose: Wire the frontend to instance API endpoints and give users the ability to browse and add instances to stacks.
Output: TypeScript types, TanStack Query hooks, add-instance dialog with template catalog, instance cards on stack detail.
</objective>

<execution_context>
@/home/priz/.claude/get-shit-done/workflows/execute-plan.md
@/home/priz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-service-instances/03-CONTEXT.md
@.planning/phases/03-service-instances/03-RESEARCH.md
@.planning/phases/03-service-instances/03-01-SUMMARY.md

@dashboard/src/types/api.ts
@dashboard/src/lib/api.ts
@dashboard/src/routes/stacks/$name.tsx
@dashboard/src/routes/stacks/index.tsx
@dashboard/src/components/stacks/stack-grid.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: TypeScript types + TanStack Query hooks for instances</name>
  <files>dashboard/src/types/api.ts, dashboard/src/lib/instance-queries.ts</files>
  <action>
Add to api.ts:

```typescript
export interface Instance {
  id: number
  stack_id: number
  instance_id: string
  template_service_id: number | null
  template_name: string
  container_name: string | null
  description: string
  enabled: boolean
  override_count: number
  created_at: string
  updated_at: string
}

export interface InstanceDetail extends Instance {
  ports: InstancePort[]
  volumes: InstanceVolume[]
  env_vars: InstanceEnvVar[]
  labels: InstanceLabel[]
  domains: InstanceDomain[]
  healthcheck: InstanceHealthcheck | null
  config_files: InstanceConfigFile[]
}

export interface InstancePort {
  id: number
  instance_id: number
  host_ip: string
  host_port: number
  container_port: number
  protocol: string
}

export interface InstanceVolume {
  id: number
  instance_id: number
  volume_type: string
  source: string
  target: string
  read_only: boolean
  is_external: boolean
}

export interface InstanceEnvVar {
  id: number
  instance_id: number
  key: string
  value?: string
  is_secret: boolean
}

export interface InstanceLabel {
  id: number
  instance_id: number
  key: string
  value: string
}

export interface InstanceDomain {
  id: number
  instance_id: number
  domain: string
  proxy_port?: number
}

export interface InstanceHealthcheck {
  id: number
  instance_id: number
  test: string
  interval_seconds: number
  timeout_seconds: number
  retries: number
  start_period_seconds: number
}

export interface InstanceConfigFile {
  id: number
  instance_id: number
  file_path: string
  content: string
  file_mode: string
  is_template: boolean
  created_at: string
  updated_at: string
}

export interface EffectiveConfig {
  instance_id: string
  template_name: string
  image_name: string
  image_tag: string
  restart_policy: string
  command?: string
  container_name: string
  ports: ServicePort[]
  volumes: ServiceVolume[]
  env_vars: ServiceEnvVar[]
  dependencies: string[]
  labels: ServiceLabel[]
  domains: ServiceDomain[]
  healthcheck: ServiceHealthcheck | null
  config_files: ServiceConfigFile[]
  overrides_applied: OverridesApplied
}

export interface OverridesApplied {
  ports: boolean
  volumes: boolean
  env_vars: string[]
  labels: string[]
  domains: boolean
  healthcheck: boolean
  config_files: string[]
}

export interface InstanceDeletePreview {
  instance_id: string
  template_name: string
  override_count: number
  container_name: string | null
}
```

Create instance-queries.ts with TanStack Query hooks following the pattern in existing query files:

**Queries:**
- `useInstances(stackName: string)` — GET /stacks/{name}/instances, returns Instance[], queryKey: ['stacks', stackName, 'instances']
- `useInstance(stackName: string, instanceId: string)` — GET /stacks/{name}/instances/{instance}, returns InstanceDetail, queryKey: ['stacks', stackName, 'instances', instanceId]
- `useEffectiveConfig(stackName: string, instanceId: string)` — GET /stacks/{name}/instances/{instance}/effective-config, returns EffectiveConfig
- `useInstanceDeletePreview(stackName: string, instanceId: string)` — GET /stacks/{name}/instances/{instance}/delete-preview

**Mutations (all invalidate ['stacks', stackName, 'instances']):**
- `useCreateInstance(stackName: string)` — POST body: {instance_id, template_service_id, description?}
- `useUpdateInstance(stackName: string, instanceId: string)` — PUT body: {description?, enabled?}
- `useDeleteInstance(stackName: string, instanceId: string)` — DELETE
- `useDuplicateInstance(stackName: string, instanceId: string)` — POST /duplicate
- `useRenameInstance(stackName: string, instanceId: string)` — PUT /rename body: {instance_id}
- `useUpdateInstancePorts(stackName, instanceId)` — PUT /ports
- `useUpdateInstanceVolumes(stackName, instanceId)` — PUT /volumes
- `useUpdateInstanceEnvVars(stackName, instanceId)` — PUT /env-vars
- `useUpdateInstanceLabels(stackName, instanceId)` — PUT /labels
- `useUpdateInstanceDomains(stackName, instanceId)` — PUT /domains
- `useUpdateInstanceHealthcheck(stackName, instanceId)` — PUT /healthcheck

Override mutations should also invalidate the specific instance query key AND the effective config key.

Use the api helper from lib/api.ts for fetch calls. Follow existing patterns exactly.
  </action>
  <verify>`cd /home/priz/projects/devarch/dashboard && npx tsc --noEmit` — no type errors.</verify>
  <done>All instance types defined, all query hooks created with proper cache invalidation</done>
</task>

<task type="auto">
  <name>Task 2: Add-instance dialog + instance list on stack detail</name>
  <files>dashboard/src/components/stacks/add-instance-dialog.tsx, dashboard/src/routes/stacks/$name.tsx</files>
  <action>
**Add-instance dialog (add-instance-dialog.tsx):**

Searchable template catalog dialog. Uses existing services list API (GET /api/v1/services) to show available templates.

- Dialog with title "Add Service Instance"
- Search input at top to filter templates by name
- Grid of template cards showing: service name, image name, category. If stack already has instances of that template, show badge "N instance(s)"
- Clicking a template card reveals creation form at bottom: instance name (auto-filled from template name, editable), optional description, "Add" button
- Instance name auto-generated: use template service name (e.g., "postgres"). If already taken in stack, append "-2", "-3", etc.
- On submit: call useCreateInstance mutation, close dialog on success, show error inline on failure
- Use Radix Dialog matching existing dialog patterns (open/onOpenChange props)

**Stack detail page update ($name.tsx):**

Replace the instances placeholder section with real content:

1. Query instances using useInstances(stackName)
2. "Add Instance" button in section header (opens add-instance dialog)
3. Empty state: centered CTA card with "Add your first service" text + button (per CONTEXT.md)
4. Instance cards in a grid (matching stack grid pattern):
   - Instance name (bold)
   - Template name (muted text)
   - Container name (monospace, small)
   - Status: enabled/disabled indicator (green/gray dot)
   - Key ports: first 2-3 ports shown inline
   - Override count badge (e.g., "3 overrides" in muted pill)
   - Click navigates to instance detail (route: /stacks/{name}/instances/{instance} — just Link for now, page built in Plan 04)
5. Display in creation order (oldest first — API returns this)
6. Instance count in section header: "Instances (N)"
  </action>
  <verify>`npm run build:strict` passes. Visual: stack detail page shows "Add Instance" button, empty state CTA when no instances, and instance cards when instances exist.</verify>
  <done>Users can add instances to stacks from template catalog, instance list shows on stack detail with rich cards</done>
</task>

</tasks>

<verification>
- TypeScript compilation passes with all new types
- Query hooks use correct API paths and cache keys
- Add-instance dialog shows template catalog with search
- Instance cards display name, template, ports, override count
- Empty stack shows CTA-focused empty state
</verification>

<success_criteria>
- INST-01 (create instance from template) achievable via dashboard
- INST-11 (list instances) visible on stack detail
- INST-12 (dashboard UI) started — add and list working
</success_criteria>

<output>
After completion, create `.planning/phases/03-service-instances/03-03-SUMMARY.md`
</output>
