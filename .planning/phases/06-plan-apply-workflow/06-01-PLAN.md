---
phase: 06-plan-apply-workflow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/internal/plan/types.go
  - api/internal/plan/differ.go
  - api/internal/plan/staleness.go
autonomous: true

must_haves:
  truths:
    - "Plan types represent add/modify/remove actions with per-field detail"
    - "Differ compares desired instances (DB) against running containers (runtime) and returns structured changes"
    - "Staleness token is deterministic: same inputs always produce same hash"
    - "Staleness validation rejects when any timestamp has changed"
  artifacts:
    - path: "api/internal/plan/types.go"
      provides: "Plan, Change, FieldChange, Action types"
      exports: ["Plan", "Change", "FieldChange"]
    - path: "api/internal/plan/differ.go"
      provides: "Diff computation between desired and runtime state"
      exports: ["ComputeDiff"]
    - path: "api/internal/plan/staleness.go"
      provides: "Staleness token generation and validation"
      exports: ["GenerateToken", "ValidateToken"]
  key_links:
    - from: "api/internal/plan/differ.go"
      to: "api/internal/plan/types.go"
      via: "imports Plan and Change types"
      pattern: "plan\\.Change"
    - from: "api/internal/plan/staleness.go"
      to: "database/sql"
      via: "queries stacks and service_instances updated_at"
      pattern: "db\\.Query"
---

<objective>
Create the plan domain package with types, diff computation, and staleness detection.

Purpose: Foundation for plan/apply endpoints. Isolated package keeps handlers thin.
Output: `api/internal/plan/` with types, differ, and staleness modules.
</objective>

<execution_context>
@/home/priz/.claude/get-shit-done/workflows/execute-plan.md
@/home/priz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-plan-apply-workflow/06-CONTEXT.md
@.planning/phases/06-plan-apply-workflow/06-RESEARCH.md

@api/internal/compose/stack.go (loadStackInstances, loadInstanceEffectiveConfig patterns)
@api/internal/container/client.go (ListContainersWithLabels)
@api/internal/sync/manager.go (advisory lock pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Plan types and diff computation</name>
  <files>api/internal/plan/types.go, api/internal/plan/differ.go</files>
  <action>
Create `api/internal/plan/` package.

**types.go** - Define types for the plan/apply domain:
- `Action` string type with constants: `ActionAdd = "add"`, `ActionModify = "modify"`, `ActionRemove = "remove"`
- `FieldChange` struct: `Old interface{}`, `New interface{}`, `Source string` (source values: "user", "template" — Phase 8 adds "wire")
- `Change` struct: `Action Action`, `InstanceID string`, `TemplateName string`, `ContainerName string`, `Fields map[string]FieldChange` (nil for add/remove, populated for modify)
- `Plan` struct: `StackName string`, `StackID int`, `Changes []Change`, `Token string`, `GeneratedAt time.Time`, `Warnings []string`
- All fields JSON-tagged with snake_case

**differ.go** - Diff computation:
- `DesiredInstance` struct: `InstanceID string`, `TemplateName string`, `ContainerName string`, `Enabled bool` (input to differ, loaded by caller)
- `func ComputeDiff(desired []DesiredInstance, running []string) []Change`
  - Build `runningSet` map from running container names
  - Build `desiredMap` from desired instances keyed by container_name
  - **Additions:** enabled desired instances whose container_name is NOT in runningSet
  - **Removals:** running containers NOT matching any desired instance's container_name
  - **Modifications (enabled->disabled only):** disabled desired instances whose container_name IS in runningSet (action=modify, field "enabled" with old=true new=false, source="user")
  - **No-op:** enabled desired instances whose container_name IS in runningSet are skipped (no change emitted). Config drift detection is out of scope for Phase 6 — it will be addressed in a future phase if needed.
  - Sort changes: removes first, then modifies, then adds (Terraform convention)
  - Return changes slice

Keep differ stateless (no DB access). Caller passes desired + running.
  </action>
  <verify>
`cd /home/priz/projects/devarch/api && go build ./internal/plan/...` compiles without errors.
  </verify>
  <done>
Plan types exist with JSON tags. ComputeDiff correctly identifies add/modify/remove from desired vs running inputs. Modification detection is scoped to enabled/disabled toggling only (no config drift).
  </done>
</task>

<task type="auto">
  <name>Task 2: Staleness token generation and validation</name>
  <files>api/internal/plan/staleness.go</files>
  <action>
**staleness.go** - Token generation and validation:

- `func GenerateToken(stackUpdatedAt time.Time, instances []InstanceTimestamp) string`
  - `InstanceTimestamp` struct: `InstanceID string`, `UpdatedAt time.Time`
  - Sort instances by InstanceID (deterministic ordering)
  - SHA256 hash: write stack updated_at as RFC3339Nano, then each instance updated_at as RFC3339Nano
  - Return hex-encoded hash string
  - No DB access — caller provides timestamps

- `func ValidateToken(db *sql.DB, stackID int, token string) error`
  - Query stack `updated_at` from stacks table WHERE id = stackID AND deleted_at IS NULL
  - If stack not found, return wrapped error
  - Query all service_instances `instance_id, updated_at` WHERE stack_id = stackID AND deleted_at IS NULL
  - Build InstanceTimestamp slice from results
  - Call GenerateToken with current values
  - If current token != provided token, return `ErrStalePlan` (package-level sentinel error)
  - If match, return nil

- `var ErrStalePlan = fmt.Errorf("plan is stale: stack state has changed since plan was generated")`

Use `crypto/sha256` and `encoding/hex` from stdlib. Sort instances before hashing to ensure determinism regardless of DB row order.
  </action>
  <verify>
`cd /home/priz/projects/devarch/api && go build ./internal/plan/...` compiles. `go vet ./internal/plan/...` passes.
  </verify>
  <done>
GenerateToken produces deterministic SHA256 from timestamps. ValidateToken queries DB and compares. ErrStalePlan sentinel exists for caller error handling.
  </done>
</task>

</tasks>

<verification>
- `cd /home/priz/projects/devarch/api && go build ./internal/plan/...` succeeds
- `go vet ./internal/plan/...` passes
- Package exports: Plan, Change, FieldChange, Action, ComputeDiff, GenerateToken, ValidateToken, ErrStalePlan, DesiredInstance, InstanceTimestamp
</verification>

<success_criteria>
- Plan types have JSON tags and represent the full diff schema (add/modify/remove with per-field detail)
- ComputeDiff is stateless and handles add/modify/remove detection from desired vs running inputs
- Modifications scoped to enabled/disabled toggle only (config drift deferred to future phase)
- GenerateToken is deterministic (sorted inputs, RFC3339Nano formatting)
- ValidateToken queries DB and returns ErrStalePlan on mismatch
- All code compiles with go build
</success_criteria>

<output>
After completion, create `.planning/phases/06-plan-apply-workflow/06-01-SUMMARY.md`
</output>
