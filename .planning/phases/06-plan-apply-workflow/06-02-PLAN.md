---
phase: 06-plan-apply-workflow
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - api/internal/api/handlers/stack_plan.go
  - api/internal/api/handlers/stack_apply.go
  - api/internal/api/routes.go
autonomous: true

must_haves:
  truths:
    - "GET /stacks/{name}/plan returns structured diff with add/modify/remove changes"
    - "POST /stacks/{name}/apply acquires advisory lock, validates staleness, executes flow"
    - "Apply rejects concurrent operations with HTTP 409"
    - "Apply rejects stale plans with HTTP 409"
    - "Apply flow: lock -> ensure network -> materialize configs -> compose up"
    - "Error handling: network fail = unlock+error, config fail = cleanup+unlock+error, compose fail = leave configs+unlock+error"
  artifacts:
    - path: "api/internal/api/handlers/stack_plan.go"
      provides: "Plan endpoint handler"
      exports: ["Plan method on StackHandler"]
    - path: "api/internal/api/handlers/stack_apply.go"
      provides: "Apply endpoint handler with advisory lock"
      exports: ["Apply method on StackHandler"]
    - path: "api/internal/api/routes.go"
      provides: "Route registration for plan and apply"
      contains: "r.Get(\"/plan\""
  key_links:
    - from: "api/internal/api/handlers/stack_plan.go"
      to: "api/internal/plan"
      via: "imports plan package for ComputeDiff and GenerateToken"
      pattern: "plan\\.ComputeDiff"
    - from: "api/internal/api/handlers/stack_apply.go"
      to: "api/internal/plan"
      via: "imports plan package for ValidateToken"
      pattern: "plan\\.ValidateToken"
    - from: "api/internal/api/handlers/stack_apply.go"
      to: "api/internal/compose"
      via: "uses Generator for compose generation and config materialization"
      pattern: "compose\\.NewGenerator"
    - from: "api/internal/api/routes.go"
      to: "api/internal/api/handlers"
      via: "registers plan and apply routes on stack router"
      pattern: "stackHandler\\.Plan"
---

<objective>
Create plan and apply HTTP handlers with route wiring.

Purpose: Core API endpoints for the plan/apply workflow — plan generates diff preview, apply executes with safety.
Output: Two new handler files + route registration.
</objective>

<execution_context>
@/home/priz/.claude/get-shit-done/workflows/execute-plan.md
@/home/priz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-plan-apply-workflow/06-CONTEXT.md
@.planning/phases/06-plan-apply-workflow/06-RESEARCH.md
@.planning/phases/06-plan-apply-workflow/06-01-SUMMARY.md

@api/internal/api/handlers/stack.go (StackHandler struct, NewStackHandler)
@api/internal/api/handlers/stack_compose.go (Compose handler — pattern reference for stack lookup, generator setup)
@api/internal/api/routes.go (existing stack route definitions)
@api/internal/compose/stack.go (GenerateStack, MaterializeStackConfigs)
@api/internal/container/client.go (ListContainersWithLabels, CreateNetwork, execComposeCommand)
@api/internal/sync/manager.go (advisory lock pattern — pg_try_advisory_lock)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Plan endpoint handler</name>
  <files>api/internal/api/handlers/stack_plan.go</files>
  <action>
Create `stack_plan.go` as method on existing `StackHandler`.

**Plan handler** — `func (h *StackHandler) Plan(w http.ResponseWriter, r *http.Request)`:

1. Extract stackName from chi URL param "name"
2. Query stack: `SELECT id, network_name, updated_at FROM stacks WHERE name = $1 AND deleted_at IS NULL`
   - 404 if not found
3. Query instances: `SELECT si.instance_id, s.name as template_name, si.container_name, si.enabled, si.updated_at FROM service_instances si JOIN services s ON s.id = si.template_service_id WHERE si.stack_id = $1 AND si.deleted_at IS NULL ORDER BY si.instance_id` (stackID)
   - Build `[]plan.DesiredInstance` from enabled instances for differ
   - Build `[]plan.InstanceTimestamp` from ALL instances for staleness token
   - For container_name: if null, compute via `container.ContainerName(stackName, instanceID)` (same pattern as compose/stack.go)
4. Query running containers: `h.containerClient.ListContainersWithLabels(map[string]string{"devarch.stack_id": stackName})`
   - If error, log and continue with empty slice (runtime may be down — plan should still work showing all as "add")
5. Call `plan.ComputeDiff(desired, running)` to get changes
6. Call `plan.GenerateToken(stackUpdatedAt, instanceTimestamps)` to get staleness token
7. Build `plan.Plan` struct with StackName, StackID, Changes, Token, GeneratedAt (time.Now()), Warnings (empty for now)
8. JSON encode and return 200

Import `plan` package as `"github.com/priz/devarch-api/internal/plan"` and `container` package for `ContainerName`.
  </action>
  <verify>
`cd /home/priz/projects/devarch/api && go build ./internal/api/handlers/...` compiles.
  </verify>
  <done>
Plan handler queries DB and runtime, computes diff, generates staleness token, returns structured JSON plan.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply endpoint handler + route wiring</name>
  <files>api/internal/api/handlers/stack_apply.go, api/internal/api/routes.go</files>
  <action>
**stack_apply.go** — `func (h *StackHandler) Apply(w http.ResponseWriter, r *http.Request)`:

Define request type in same file:
- `applyRequest` struct: `Token string` json:"token"

Handler flow:
1. Extract stackName from chi URL param "name"
2. Decode JSON body into `applyRequest`. Token is required — return 400 if empty.
3. Query stack: `SELECT id, network_name FROM stacks WHERE name = $1 AND deleted_at IS NULL`
   - 404 if not found
4. **Acquire advisory lock**: `SELECT pg_try_advisory_lock($1)` with stack.ID
   - Use `h.db.QueryRowContext(r.Context(), ...)` — same pattern as sync/manager.go
   - If not acquired or error, return 409 with message "Stack is being applied by another session"
   - Defer unlock: `SELECT pg_advisory_unlock($1)` with stack.ID using background context with 5s timeout
5. **Validate staleness**: call `plan.ValidateToken(h.db, stackID, req.Token)`
   - If `errors.Is(err, plan.ErrStalePlan)`, return 409 with "Plan is stale — stack was modified since plan was generated. Regenerate plan."
   - If other error, return 500
6. **Ensure network**:
   - Resolve network name (same pattern as stack_compose.go: use network_name column, fallback to devarch-{stack}-net)
   - Build labels: `devarch.managed_by=devarch`, `devarch.stack={stackName}`
   - Call `h.containerClient.CreateNetwork(netName, labels)` — already idempotent
   - If error, return 500 (nothing to roll back)
7. **Materialize configs**:
   - Get PROJECT_ROOT from env
   - Create generator: `compose.NewGenerator(h.db, netName)` with SetProjectRoot, SetHostProjectRoot
   - Call `gen.MaterializeStackConfigs(stackName, projectRoot)`
   - If error, clean up: `os.RemoveAll(filepath.Join(projectRoot, "compose", "stacks", stackName))`, return 500
8. **Generate compose + compose up**:
   - Call `gen.GenerateStack(stackName)` for YAML bytes
   - If error, clean up config dir, return 500
   - Write YAML to temp file, defer remove
   - Call `h.containerClient.RunCompose(tmpFile, "--project-name", "devarch-"+stackName, "up", "-d")`
   - If error, leave configs for debugging, return 500 with compose stderr
9. **Success**: return 200 JSON with `{"status": "applied", "output": composeOutput}`

**routes.go** — Add two routes inside the `/{name}` stack route group:
- `r.Get("/plan", stackHandler.Plan)`
- `r.Post("/apply", stackHandler.Apply)`

Place them after the existing `/compose` route for logical grouping.
  </action>
  <verify>
`cd /home/priz/projects/devarch/api && go build ./...` compiles. Routes visible in routes.go.
  </verify>
  <done>
Apply endpoint acquires advisory lock (pg_try_advisory_lock), validates staleness, runs sequential flow (network -> configs -> compose up), handles errors per CONTEXT.md decisions. Routes registered.
  </done>
</task>

</tasks>

<verification>
- `cd /home/priz/projects/devarch/api && go build ./...` succeeds (full project compiles)
- `go vet ./...` passes
- routes.go contains `/plan` and `/apply` routes under `/{name}` stack group
- Plan handler returns JSON with changes array, token, stack_name, generated_at
- Apply handler uses pg_try_advisory_lock, validates staleness, runs 3-step flow
</verification>

<success_criteria>
- GET /stacks/{name}/plan returns structured plan JSON (PLAN-01, PLAN-05)
- POST /stacks/{name}/apply acquires advisory lock per stack (PLAN-02)
- Apply flow is lock -> ensure network -> materialize configs -> compose up (PLAN-03)
- Stale plans rejected with 409 (PLAN-04)
- Concurrent applies rejected with 409 (PLAN-02)
- Error handling matches CONTEXT.md decisions (no rollback, leave configs on compose failure)
</success_criteria>

<output>
After completion, create `.planning/phases/06-plan-apply-workflow/06-02-SUMMARY.md`
</output>
