---
phase: 01-foundation-guardrails
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/internal/container/labels.go
  - api/internal/container/labels_test.go
  - api/internal/container/validation.go
  - api/internal/container/validation_test.go
  - api/internal/container/types.go
  - api/migrations/013_stacks_instances.up.sql
  - api/migrations/013_stacks_instances.down.sql
autonomous: true

must_haves:
  truths:
    - "Identity label constants are defined and accessible from any package"
    - "Name validation rejects invalid stack/instance names with prescriptive errors"
    - "Name validation accepts valid DNS-safe names"
    - "Database schema supports stack and instance entities"
  artifacts:
    - path: "api/internal/container/labels.go"
      provides: "Label constants and helper functions"
      contains: "LabelStackID"
    - path: "api/internal/container/validation.go"
      provides: "Name validation with prescriptive errors"
      contains: "ValidateName"
    - path: "api/internal/container/types.go"
      provides: "Shared types for runtime abstraction"
      contains: "Runtime interface"
    - path: "api/migrations/013_stacks_instances.up.sql"
      provides: "Stack and instance table schema"
      contains: "CREATE TABLE stacks"
  key_links:
    - from: "api/internal/container/validation.go"
      to: "api/internal/container/labels.go"
      via: "reserved names use label prefix"
      pattern: "reservedNames"
---

<objective>
Create identity label constants, name validation helpers, shared runtime types, and DB migration for stacks/instances.

Purpose: Establish the foundational primitives (identity, validation, schema) that Plans 02+ and Phase 2 depend on.
Output: Four new Go files + one SQL migration pair.
</objective>

<execution_context>
@/home/fhcadmin/.claude/get-shit-done/workflows/execute-plan.md
@/home/fhcadmin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-guardrails/01-CONTEXT.md
@.planning/phases/01-foundation-guardrails/01-RESEARCH.md

@api/internal/container/client.go
@api/internal/podman/client.go
@api/internal/podman/types.go
@api/internal/podman/containers.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Identity labels, validation, and shared types</name>
  <files>
    api/internal/container/labels.go
    api/internal/container/labels_test.go
    api/internal/container/validation.go
    api/internal/container/validation_test.go
    api/internal/container/types.go
  </files>
  <action>
Create three new files in `api/internal/container/`:

**labels.go** — Label constants and helpers:
```go
package container

const (
    LabelPrefix            = "devarch."
    LabelStackID           = "devarch.stack_id"
    LabelInstanceID        = "devarch.instance_id"
    LabelTemplateServiceID = "devarch.template_service_id"
    LabelManagedBy         = "devarch.managed_by"
    LabelVersion           = "devarch.version"
    ManagedByValue         = "devarch"
)
```
Add helper functions:
- `BuildLabels(stackID, instanceID, templateServiceID string) map[string]string` — returns full label map including managed_by and version
- `ContainerName(stackID, instanceID string) string` — returns `devarch-{stackID}-{instanceID}`
- `NetworkName(stackID string) string` — returns `devarch-{stackID}-net`
- `IsDevArchManaged(labels map[string]string) bool` — checks if container has devarch.managed_by label

**labels_test.go** — Test BuildLabels returns all expected keys, ContainerName format, NetworkName format, IsDevArchManaged true/false cases.

**validation.go** — Name validation:
- DNS-safe regex: `^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$`
- Reserved names: `default`, `devarch`, `system`, `none`, `all`
- `ValidateName(name string) error` — returns nil if valid, descriptive error if not
- `Slugify(input string) string` — lowercase, replace spaces/underscores with hyphens, strip invalid chars, collapse multiple hyphens
- Error messages must be prescriptive: include what's wrong AND suggest fix using Slugify. Example: `"My App" is not a valid name: must be lowercase alphanumeric with hyphens — try: my-app`
- Single-char names are valid (e.g., "a")
- Empty string is invalid

**validation_test.go** — Table-driven tests covering:
- Valid names: "my-stack", "a", "abc-123", 63-char name
- Invalid: empty, uppercase "MyStack", leading hyphen "-bad", trailing hyphen "bad-", 64+ chars, reserved names, spaces, special chars
- Slugify: "My App" -> "my-app", "foo_bar" -> "foo-bar", "  leading  " -> "leading", "foo--bar" -> "foo-bar"

**types.go** — Shared types for the runtime abstraction (used by Plan 02):
```go
package container

type RuntimeType string

const (
    RuntimePodman RuntimeType = "podman"
    RuntimeDocker RuntimeType = "docker"
)

// Runtime is the unified container runtime interface.
// Phase 1 defines the interface; implementation extends existing Client.
type Runtime interface {
    // Identity
    RuntimeName() RuntimeType

    // Container lifecycle (compose-based)
    StartService(name string, composeYAML []byte) error
    StopService(name string, composeYAML []byte) error
    RestartService(name string, composeYAML []byte) error
    RebuildService(name string, composeYAML []byte, noCache bool) error

    // Container inspection — named GetContainerStatus/GetContainerMetrics
    // to avoid collision with existing Client.GetStatus (*models.ContainerState)
    // and Client.GetMetrics (*models.ContainerMetrics). Both coexist for
    // backward compat; new stack-aware code uses the Runtime interface methods.
    GetContainerStatus(name string) (*ContainerStatus, error)
    GetLogs(name string, tail string) (string, error)
    GetContainerMetrics(name string) (*ContainerMetrics, error)
    ListContainers() ([]string, error)
    ListContainersWithLabels(labels map[string]string) ([]string, error)
    GetRunningCount() (running int, stopped int)

    // Container exec
    Exec(containerName string, command []string) (string, error)

    // Pod operations (stubs in Phase 1, implemented Phase 4)
    CreatePod(name string, labels map[string]string) error
    RemovePod(name string) error
    ListPods() ([]string, error)

    // Network operations (stubs in Phase 1, implemented Phase 4)
    CreateNetwork(name string, labels map[string]string) error
    RemoveNetwork(name string) error
    ListNetworks() ([]string, error)
}

// ContainerStatus holds container state info (replaces models.ContainerState dependency for new code)
type ContainerStatus struct {
    Status       string
    Health       string
    StartedAt    *time.Time
    FinishedAt   *time.Time
    ExitCode     *int
    Error        string
    RestartCount int
}

// ContainerMetrics holds resource usage (mirrors existing models.ContainerMetrics)
type ContainerMetrics struct {
    CPUPercentage    float64
    MemoryUsedMB     float64
    MemoryLimitMB    float64
    MemoryPercentage float64
    NetworkRxBytes   int64
    NetworkTxBytes   int64
    RecordedAt       time.Time
}
```
Note: Keep existing `models.ContainerState` and `models.ContainerMetrics` for backward compat. The types in types.go are for new stack-aware code. Plan 02 will implement `GetContainerStatus` and `GetContainerMetrics` on Client by converting from existing models types internally.
  </action>
  <verify>
    cd api && go build ./internal/container/...
    cd api && go test ./internal/container/... -v
  </verify>
  <done>
    - All label constants defined and exported
    - ValidateName rejects all invalid inputs with prescriptive messages
    - ValidateName accepts all valid DNS-safe names
    - Slugify produces correct suggestions
    - Runtime interface compiles with all method signatures (GetContainerStatus, GetContainerMetrics — not GetStatus/GetMetrics)
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Database migration for stacks and instances</name>
  <files>
    api/migrations/013_stacks_instances.up.sql
    api/migrations/013_stacks_instances.down.sql
  </files>
  <action>
Create migration 013.

Note: CONTEXT.md explicitly locks the decision "DB migration included: stack and instance table schema created in Phase 1." This takes precedence over REQUIREMENTS.md MIGR-01/MIGR-02 numbering which assumed stacks/instances in Phase 3. The MIGR numbering in REQUIREMENTS.md will be reconciled in a later phase.

**013_stacks_instances.up.sql:**
```sql
CREATE TABLE stacks (
    id SERIAL PRIMARY KEY,
    name VARCHAR(63) UNIQUE NOT NULL,
    description TEXT DEFAULT '',
    network_name VARCHAR(63),
    enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE service_instances (
    id SERIAL PRIMARY KEY,
    stack_id INTEGER NOT NULL REFERENCES stacks(id) ON DELETE CASCADE,
    instance_id VARCHAR(63) NOT NULL,
    template_service_id INTEGER REFERENCES services(id),
    container_name VARCHAR(127),
    enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(stack_id, instance_id)
);

CREATE INDEX idx_service_instances_stack_id ON service_instances(stack_id);
CREATE INDEX idx_service_instances_template_service_id ON service_instances(template_service_id);
```

**013_stacks_instances.down.sql:**
```sql
DROP TABLE IF EXISTS service_instances;
DROP TABLE IF EXISTS stacks;
```

Key design notes:
- `stacks.name` is UNIQUE — stack name IS the identity (per CONTEXT decision)
- `service_instances.instance_id` is unique per stack (composite unique constraint)
- `template_service_id` references existing `services` table — nullable for instances not based on a template
- `container_name` stores the deterministic name (`devarch-{stack}-{instance}`) for quick lookup
- `network_name` on stacks stores `devarch-{stack}-net` for Phase 4
- CASCADE delete: removing a stack removes all instances
  </action>
  <verify>
    Verify SQL syntax: check that the migration files parse correctly by reviewing them.
    Ensure services table reference exists by checking existing migrations for CREATE TABLE services.
  </verify>
  <done>
    - Migration 013 up/down files exist
    - Up creates stacks and service_instances tables with correct constraints
    - Down drops both tables in correct order (instances first)
    - Foreign key to services table is correct
  </done>
</task>

</tasks>

<verification>
- `cd api && go build ./internal/container/...` compiles without errors
- `cd api && go test ./internal/container/... -v` all tests pass
- Migration files exist at api/migrations/013_stacks_instances.{up,down}.sql
- `go vet ./internal/container/...` reports no issues
</verification>

<success_criteria>
- Label constants (LabelStackID, LabelInstanceID, LabelTemplateServiceID) defined and exported
- ValidateName validates DNS-safe names with prescriptive errors
- Runtime interface defined with GetContainerStatus/GetContainerMetrics (not GetStatus/GetMetrics) plus container, pod, and network method signatures
- Stack/instance DB schema ready for Phase 2 CRUD
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-guardrails/01-01-SUMMARY.md`
</output>
