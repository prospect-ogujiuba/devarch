---
phase: 01-foundation-guardrails
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - api/internal/container/client.go
  - api/internal/container/client_test.go
  - api/internal/project/controller.go
  - api/internal/api/handlers/nginx.go
  - api/cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "All container operations route through container.Client — no hardcoded exec.Command(podman/docker)"
    - "Runtime auto-detects Podman (preferred) or Docker, overridable via DEVARCH_RUNTIME env var"
    - "Pod and network stub methods exist and return ErrNotImplemented"
    - "Exec method exists for running commands inside containers"
    - "container.Client satisfies the Runtime interface from types.go"
  artifacts:
    - path: "api/internal/container/client.go"
      provides: "Unified runtime client implementing Runtime interface"
      contains: "func (c *Client) Exec"
    - path: "api/internal/project/controller.go"
      provides: "Project controller using container.Client instead of hardcoded podman"
      exports: ["NewController"]
    - path: "api/internal/api/handlers/nginx.go"
      provides: "Nginx handler using container.Client for exec"
  key_links:
    - from: "api/internal/container/client.go"
      to: "api/internal/container/types.go"
      via: "implements Runtime interface"
      pattern: "var _ Runtime = .*Client"
    - from: "api/internal/project/controller.go"
      to: "api/internal/container/client.go"
      via: "uses container.Client instead of exec.Command"
      pattern: "container\\.Client"
    - from: "api/internal/api/handlers/nginx.go"
      to: "api/internal/container/client.go"
      via: "uses Exec method for nginx reload"
      pattern: "\\.Exec\\("
---

<objective>
Refactor container.Client to implement the Runtime interface and eliminate all hardcoded exec.Command("podman") calls.

Purpose: Satisfy BASE-03 (all container operations through container.Client) and establish the unified runtime abstraction.
Output: Extended client.go, refactored controller.go and nginx.go, updated main.go wiring.
</objective>

<execution_context>
@/home/fhcadmin/.claude/get-shit-done/workflows/execute-plan.md
@/home/fhcadmin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-guardrails/01-CONTEXT.md
@.planning/phases/01-foundation-guardrails/01-RESEARCH.md
@.planning/phases/01-foundation-guardrails/01-01-SUMMARY.md

@api/internal/container/client.go
@api/internal/container/types.go
@api/internal/project/controller.go
@api/internal/api/handlers/nginx.go
@api/cmd/server/main.go
@api/internal/api/routes.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend container.Client to implement Runtime interface</name>
  <files>
    api/internal/container/client.go
    api/internal/container/client_test.go
  </files>
  <action>
Refactor `client.go` to implement the `Runtime` interface from `types.go`:

1. **DEVARCH_RUNTIME env var support**: In `NewClient()`, check `DEVARCH_RUNTIME` env var first. If set to "docker" or "podman", use that runtime. If set but the specified runtime isn't found via `exec.LookPath`, return error with prescriptive message: `DEVARCH_RUNTIME=<value> but <runtime> not found — install <runtime> or unset DEVARCH_RUNTIME for auto-detection`. If unset, auto-detect with Podman preferred (existing behavior).

2. **Change RuntimeName() return type** from `string` to `RuntimeType`. Update callers if needed.

3. **Add `Exec` method**:
```go
func (c *Client) Exec(containerName string, command []string) (string, error) {
    args := append([]string{"exec", containerName}, command...)
    return c.execCommand(args...)
}
```

4. **Add `ListContainersWithLabels` method**:
```go
func (c *Client) ListContainersWithLabels(labels map[string]string) ([]string, error) {
    args := []string{"ps", "-a", "--format", "{{.Names}}"}
    for k, v := range labels {
        args = append(args, "--filter", fmt.Sprintf("label=%s=%s", k, v))
    }
    return c.parseNamesList(c.execCommand(args...))
}
```
Extract the name-parsing logic from existing `ListContainers` into a shared `parseNamesList` helper.

5. **Add stub methods** for pod and network operations. Each returns `ErrNotImplemented`:
```go
var ErrNotImplemented = fmt.Errorf("not implemented: will be available in Phase 4")

func (c *Client) CreatePod(name string, labels map[string]string) error { return ErrNotImplemented }
func (c *Client) RemovePod(name string) error { return ErrNotImplemented }
func (c *Client) ListPods() ([]string, error) { return nil, ErrNotImplemented }
func (c *Client) CreateNetwork(name string, labels map[string]string) error { return ErrNotImplemented }
func (c *Client) RemoveNetwork(name string) error { return ErrNotImplemented }
func (c *Client) ListNetworks() ([]string, error) { return nil, ErrNotImplemented }
```

6. **Add compile-time interface check**: `var _ Runtime = (*Client)(nil)`

7. **Implement GetContainerStatus and GetContainerMetrics**: The Runtime interface uses `GetContainerStatus(*ContainerStatus)` and `GetContainerMetrics(*ContainerMetrics)` (renamed from GetStatus/GetMetrics per types.go). Implement these on Client by calling the existing internal inspection logic and converting `models.ContainerState` -> `ContainerStatus` and `models.ContainerMetrics` -> `ContainerMetrics`. Keep existing `GetStatus` and `GetMetrics` methods unchanged for backward compat — they are NOT part of the Runtime interface.

8. **client_test.go**: Test that `NewClient` respects `DEVARCH_RUNTIME` env var (set env, create client, check RuntimeName). Test that setting `DEVARCH_RUNTIME` to an invalid/unavailable runtime returns an error with prescriptive message. Test that stub methods return `ErrNotImplemented`. Test `Exec` constructs correct args (mock not needed — just verify command construction pattern if possible, or test that it doesn't panic with empty args).

Important: Do NOT remove any existing public methods. Only add new ones and modify signatures where the Runtime interface requires it.
  </action>
  <verify>
    cd api && go build ./internal/container/...
    cd api && go vet ./internal/container/...
    cd api && go test ./internal/container/... -v
  </verify>
  <done>
    - container.Client implements Runtime interface (compile-time check passes)
    - DEVARCH_RUNTIME env var override works; invalid value returns prescriptive error
    - Exec, ListContainersWithLabels methods exist
    - GetContainerStatus and GetContainerMetrics implement Runtime interface methods
    - Existing GetStatus/GetMetrics preserved for backward compat
    - Pod/network stubs return ErrNotImplemented
    - All existing methods still work (backward compat)
    - Tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix hardcoded exec.Command calls and update wiring</name>
  <files>
    api/internal/project/controller.go
    api/internal/api/handlers/nginx.go
    api/cmd/server/main.go
  </files>
  <action>
Three hardcoded `exec.Command("podman", ...)` calls must be routed through `container.Client`:

**Verification order: build client.go first, then controller.go, then nginx.go, then main.go. Verify `go build ./...` compiles after each file change to catch issues early.**

**project/controller.go** (2 calls):

1. Line 83: `exec.Command("podman", "inspect", "--format", "{{.State.Status}}", cName)` — Replace with `c.containerClient.GetStatus(cName)` or equivalent. The Controller needs a `*container.Client` field.

2. Line 124: `exec.Command("podman", cmdArgs...)` in `runCompose` — Replace with the container client's compose execution. The existing `container.Client` already has `StartService`, `StopService`, `RestartService` which do compose operations. Refactor `runCompose` to delegate to the container client's compose methods, OR add a general `RunCompose(composePath string, args ...string) (string, error)` method to container.Client.

   Recommended approach: Add `RunCompose(composePath string, args ...string) (string, error)` to container.Client that reads the compose file and calls `execComposeCommand`. Then controller.runCompose delegates to it. This keeps the controller simple.

3. Update `NewController` signature: Change from `func NewController(db *sql.DB, podmanClient *podman.Client)` to accept `*container.Client` instead of (or in addition to) `*podman.Client`. The controller currently uses podmanClient only indirectly through hardcoded exec.Command — so replacing with container.Client is the right move.

**handlers/nginx.go** (1 call):

Line 40: `exec.Command("podman", "exec", "nginx-proxy-manager", "nginx", "-s", "reload")` — Replace with `h.containerClient.Exec("nginx-proxy-manager", []string{"nginx", "-s", "reload"})`. Add `containerClient *container.Client` field to NginxHandler, update constructor.

**cmd/server/main.go**:

Update wiring to pass `containerClient` to:
- `project.NewController(db, containerClient)` instead of `podmanClient`
- `handlers.NewNginxHandler(nginxGenerator, containerClient)` — update constructor call

Check `api/internal/api/routes.go` for how NginxHandler is constructed and update accordingly.

After changes, verify NO `exec.Command` calls with "podman" or "docker" remain anywhere outside `container/client.go`:
```bash
grep -rn 'exec.Command.*"podman"\|exec.Command.*"docker"' api/internal/ --include="*.go" | grep -v container/client.go
```
This must return empty.

Remove `"os/exec"` imports from controller.go and nginx.go since they should no longer need it.
  </action>
  <verify>
    cd api && go build ./...
    cd api && go vet ./...
    grep -rn 'exec.Command.*"podman"\|exec.Command.*"docker"' api/internal/ --include="*.go" | grep -v container/client.go
    # Must return empty — no hardcoded runtime calls outside container/client.go
  </verify>
  <done>
    - project/controller.go uses container.Client for all container operations
    - nginx.go uses container.Client.Exec for nginx reload
    - main.go wires container.Client to both controller and nginx handler
    - Zero exec.Command("podman"|"docker") calls outside container/client.go
    - Full API builds without errors
  </done>
</task>

</tasks>

<verification>
- `cd api && go build ./...` — entire API compiles
- `cd api && go vet ./...` — no vet issues
- `cd api && go test ./internal/container/... -v` — all tests pass
- `grep -rn 'exec.Command.*podman\|exec.Command.*docker' api/internal/ --include="*.go" | grep -v container/client.go` — returns empty
- container.Client satisfies Runtime interface (compile-time check)
</verification>

<success_criteria>
- All container operations route through container.Client (BASE-03 satisfied)
- DEVARCH_RUNTIME env var controls runtime selection; invalid values produce prescriptive errors
- No hardcoded exec.Command("podman"|"docker") outside container/client.go
- Pod/network stubs ready for Phase 4 implementation
- Full API builds and existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-guardrails/01-02-SUMMARY.md`
</output>
