---
phase: 05-compose-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/internal/compose/generator.go
  - api/internal/compose/stack.go
  - api/internal/api/handlers/stack_compose.go
  - api/internal/api/routes.go
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/stacks/{name}/compose returns JSON with yaml and warnings fields"
    - "Generated YAML contains N service entries matching enabled instances in stack"
    - "Each service has container_name devarch-{stack}-{instance} and identity labels"
    - "depends_on uses service_healthy condition when target has healthcheck, simple list otherwise"
    - "Disabled instances excluded from YAML, depends_on references to them stripped with warning"
    - "Config files materialized atomically to compose/stacks/{stack}/{instance}/"
    - "Existing GET /api/v1/services/{name}/compose still works unchanged"
    - "Duplicate host port bindings produce a warning (not a blocking error)"
  artifacts:
    - path: "api/internal/compose/stack.go"
      provides: "GenerateStack method and MaterializeStackConfigs"
    - path: "api/internal/api/handlers/stack_compose.go"
      provides: "StackHandler.Compose handler"
    - path: "api/internal/api/routes.go"
      provides: "GET /stacks/{name}/compose route"
  key_links:
    - from: "api/internal/api/handlers/stack_compose.go"
      to: "api/internal/compose/stack.go"
      via: "generator.GenerateStack()"
      pattern: "GenerateStack"
    - from: "api/internal/api/routes.go"
      to: "api/internal/api/handlers/stack_compose.go"
      via: "stackHandler.Compose"
      pattern: "stackHandler\\.Compose"
    - from: "api/internal/compose/stack.go"
      to: "api/internal/api/handlers/instance_effective.go"
      via: "reuses same effective config merge logic"
      pattern: "mergeEnvVars|mergeLabels|mergeConfigFiles"
---

<objective>
Stack compose generator produces single docker-compose YAML with all instances from effective configs, with config file materialization and warning collection.

Purpose: Core compose generation engine — transforms DB state (template + overrides) into valid docker-compose YAML for an entire stack. This is the data pipeline that Phase 6 (plan/apply) will consume.
Output: New GenerateStack method, MaterializeStackConfigs, compose handler, route wiring.
</objective>

<execution_context>
@/home/priz/.claude/get-shit-done/workflows/execute-plan.md
@/home/priz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@api/internal/compose/generator.go
@api/internal/api/handlers/instance_effective.go
@api/internal/api/handlers/stack.go
@api/internal/api/routes.go
@api/internal/container/labels.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stack compose generator and config materialization</name>
  <files>api/internal/compose/stack.go, api/internal/compose/generator.go</files>
  <action>
Create `api/internal/compose/stack.go` with two methods on the existing `Generator` type:

**GenerateStack(stackName string) ([]byte, []string, error)**
1. Query all instances for the stack with their effective configs. For each instance, load:
   - Instance row (id, instance_id, enabled, container_name, template_service_id) from service_instances JOIN stacks
   - Template service base data (image_name, image_tag, restart_policy, command, user_spec) from services
   - Effective ports: instance_ports if any, else service_ports
   - Effective volumes: instance_volumes if any, else service_volumes
   - Effective env_vars: merge service_env_vars + instance_env_vars (key-based, instance wins) — reuse same merge logic as instance_effective.go
   - Effective labels: merge service_labels + instance_labels (key-based, instance wins) + inject identity labels via container.BuildLabels (only if not already present)
   - Effective healthcheck: instance_healthchecks if exists, else service_healthchecks
   - Effective dependencies: instance_dependencies if any, else service_dependencies (instance deps use depends_on TEXT column; service deps join to services.name)
   - Effective config_files: merge service_config_files + instance_config_files (path-based, instance wins)

2. Build generatedCompose struct:
   - Network: stack's network_name from stacks table (fallback to devarch-{stack}-net), declared as external: true
   - Services map: iterate enabled instances only. For each:
     - Service key = instance_id (e.g., "db-01", "redis-cache")
     - container_name = container_name from DB (already set as devarch-{stack}-{instance} at creation)
     - Build serviceConfig from effective config data (reuse existing struct from generator.go)
     - For ports: format as "{host_ip}:{host_port}:{container_port}" with protocol suffix if not tcp
     - For volumes: format as "{source}:{target}[:ro]" — use resolveRelativePath with compose/stacks/{stack}/{instance} as base for config file volumes
     - For environment: map of key->value
     - For labels: format as "key=value" strings (include identity labels)
     - For healthcheck: build healthcheckConfig pointer (nil if none)

3. depends_on handling — change DependsOn field type:
   - In generator.go, change `serviceConfig.DependsOn` from `[]string` to `interface{}` with yaml tag `yaml:"depends_on,omitempty"`
   - For stack generation: build depends_on per instance. For each dependency target:
     - If target instance_id is disabled: skip it, add warning "Instance {instance_id}: stripped dependency on disabled instance {target}"
     - If target instance_id is not in the stack at all: skip it, add warning "Instance {instance_id}: dependency {target} not found in stack"
     - If target has a healthcheck: use map format `{target: {condition: "service_healthy"}}`
     - If target has no healthcheck: use map format `{target: {condition: "service_started"}}`
   - Use `map[string]dependsOnCondition` where `dependsOnCondition` is a struct with `Condition string yaml:"condition"`
   - For existing single-service Generate(): convert the existing []string to the same format to maintain backward compat (simple list is still valid YAML, but to keep it unchanged, populate DependsOn as []string when called from Generate)

4. Warning collection:
   - Disabled instances: "Skipped disabled instance: {instance_id}"
   - Stripped dependencies on disabled instances (see above)
   - Dependencies not found in stack (see above)
   - Port conflicts: collect all host_port values across all instances. If duplicates found: "Port conflict: host port {port} used by instances {a}, {b}" — warn, do not block

5. Marshal with yaml.Marshal and return (yamlBytes, warnings, nil).

**MaterializeStackConfigs(stackName, baseDir string) error**
1. Query all enabled instances and their effective config_files (merged template + instance, path-based)
2. Create temp directory: filepath.Join(baseDir, "compose", "stacks", ".tmp-"+stackName)
3. For each instance, write config files to: tempDir/{instance_id}/{file_path} with proper file mode (use parseFileMode from generator.go)
4. Atomic swap: os.RemoveAll(finalDir) then os.Rename(tempDir, finalDir) where finalDir = filepath.Join(baseDir, "compose", "stacks", stackName)
5. If no config files exist for any instance, still create the directory (empty is fine, cleanup removes stale)

Important: Do NOT modify the existing Generate() method behavior for single services except changing DependsOn type to interface{} — existing callers assign []string which marshals identically to the current behavior.
  </action>
  <verify>
Run `cd /home/priz/projects/devarch/api && go build ./...` — must compile with no errors. Verify the DependsOn type change doesn't break existing Generate() by checking that the service handler still compiles.
  </verify>
  <done>
GenerateStack method exists, builds multi-service YAML from effective configs with proper depends_on conditions, identity labels, disabled instance filtering, port conflict warnings, and atomic config materialization. Existing Generate() still compiles and works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Stack compose handler and route wiring</name>
  <files>api/internal/api/handlers/stack_compose.go, api/internal/api/routes.go</files>
  <action>
Create `api/internal/api/handlers/stack_compose.go` with:

**StackHandler.Compose(w, r)** — handles GET /api/v1/stacks/{name}/compose
1. Extract stack name from chi URL param
2. Verify stack exists and is not deleted (query stacks WHERE name = $1 AND deleted_at IS NULL)
3. Return 404 if not found
4. Create compose.Generator (need to get generator reference — add generator field to StackHandler, initialized in NewStackHandler; pass db and stack's network_name)
5. Actually: StackHandler needs access to a Generator. Two options — simplest is to construct one on the fly since Generator just needs db and networkName. Query the stack's network_name, create generator with compose.NewGenerator(h.db, networkName), set project roots if available.
6. Call generator.GenerateStack(stackName) to get (yamlBytes, warnings, err)
7. Call generator.MaterializeStackConfigs(stackName, projectRoot) if projectRoot is set — materialize config files atomically (this ensures config files are on disk before YAML is returned, since YAML may reference them via volume mounts)
8. Return JSON response:
   ```json
   {
     "yaml": "<yaml string>",
     "warnings": ["...", "..."],
     "instance_count": N
   }
   ```
   Content-Type: application/json

**Route wiring in routes.go:**
Add inside the existing `r.Route("/{name}", ...)` block under stacks, after the network route:
```go
r.Get("/compose", stackHandler.Compose)
```

**StackHandler modifications:**
- Add a `projectRoot` and `hostProjectRoot` field to StackHandler
- In NewStackHandler, accept projectRoot string parameter — update the constructor call in routes.go
- Alternatively, simpler: read PROJECT_ROOT from env in the handler (matching how ServiceHandler does it — check service.go for pattern). Actually, looking at service.go line 32, the generator gets project root set after construction. Follow same pattern: in NewStackHandler, check if os env PROJECT_ROOT is set, store it.

Note: The compose response is JSON (not raw YAML) per the CONTEXT.md decision — `{ yaml: "...", warnings: [...] }` — so the dashboard can display warnings alongside the YAML.
  </action>
  <verify>
Run `cd /home/priz/projects/devarch/api && go build ./...` — must compile. Check that route is registered by grepping for "compose" in routes.go. Verify handler returns JSON by checking Content-Type header setting.
  </verify>
  <done>
GET /api/v1/stacks/{name}/compose returns JSON with yaml string, warnings array, and instance_count. Config files materialized to disk atomically before response. Route wired in routes.go. Existing service compose endpoint unchanged.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/priz/projects/devarch/api && go build ./...` compiles without errors
2. Existing service compose endpoint unaffected: `GET /api/v1/services/{name}/compose` still returns text/yaml
3. New stack compose endpoint: `GET /api/v1/stacks/{name}/compose` returns application/json with yaml and warnings fields
4. DependsOn type change in serviceConfig doesn't alter existing YAML output format for single-service generation
</verification>

<success_criteria>
- Stack compose generator produces valid multi-service docker-compose YAML from effective configs
- depends_on uses condition-based format (service_healthy when target has healthcheck)
- Disabled instances excluded, references stripped with warnings
- Port conflicts detected and warned
- Config files materialized atomically to compose/stacks/{stack}/{instance}/
- Existing single-service compose generation unchanged (COMP-03)
- API compiles and handler returns structured JSON response
</success_criteria>

<output>
After completion, create `.planning/phases/05-compose-generation/05-01-SUMMARY.md`
</output>
