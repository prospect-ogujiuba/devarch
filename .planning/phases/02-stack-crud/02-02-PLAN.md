---
phase: 02-stack-crud
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - api/internal/api/handlers/stack.go
  - api/internal/api/routes.go
  - api/cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "Enable/disable stack updates enabled flag and stops containers on disable"
    - "Clone copies stack record with new name (instances copy deferred to Phase 3)"
    - "Rename is clone + soft-delete in a transaction"
    - "Trash list shows soft-deleted stacks"
    - "Restore moves stack out of trash (checks name conflict)"
    - "Permanent delete removes row from DB"
    - "Delete preview shows cascade summary (instance count)"
    - "All stack routes registered and accessible"
  artifacts:
    - path: "api/internal/api/handlers/stack.go"
      provides: "Complete stack handler with all operations"
      exports: ["Enable", "Disable", "Clone", "Rename", "ListTrash", "Restore", "PermanentDelete", "DeletePreview"]
    - path: "api/internal/api/routes.go"
      provides: "Stack routes registered under /api/v1/stacks"
      contains: "stackHandler"
  key_links:
    - from: "api/internal/api/routes.go"
      to: "api/internal/api/handlers/stack.go"
      via: "stackHandler method references"
      pattern: "stackHandler\\."
    - from: "api/cmd/server/main.go"
      to: "api/internal/api/routes.go"
      via: "NewRouter parameter"
      pattern: "NewRouter"
---

<objective>
Add advanced stack operations (enable/disable, clone, rename, trash) and wire all routes.

Purpose: Complete the API surface for stack management — all operations accessible via HTTP.
Output: Full StackHandler + registered routes + server wiring.
</objective>

<execution_context>
@/home/fhcadmin/.claude/get-shit-done/workflows/execute-plan.md
@/home/fhcadmin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-stack-crud/02-CONTEXT.md
@.planning/phases/02-stack-crud/02-RESEARCH.md
@.planning/phases/02-stack-crud/02-01-SUMMARY.md
@api/internal/api/routes.go
@api/cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add advanced stack operations to handler</name>
  <files>api/internal/api/handlers/stack.go</files>
  <action>
Add these methods to the existing StackHandler:

1. **Enable** `POST /stacks/{name}/enable` — Set enabled=true, updated_at=NOW(). Return updated stack. Active stacks only.

2. **Disable** `POST /stacks/{name}/disable` — Set enabled=false, updated_at=NOW(). Stop all containers for this stack's instances via containerClient (query service_instances for stack_id, build container names with `container.ContainerName(stackName, instanceID)`, stop each). Return updated stack with list of stopped containers.

3. **Clone** `POST /stacks/{name}/clone` — Accept `{name: "new-name"}`. Validate new name. Begin transaction. Copy stack record with new name (description copied, enabled=true, deleted_at=NULL). Copy all service_instances from source to new stack (preserve instance_id, template_service_id). Commit. Return 201 + new stack. Handle name conflicts (23505 error).

4. **Rename** `POST /stacks/{name}/rename` — Accept `{name: "new-name"}`. Implemented as clone + soft-delete in single transaction. If clone step fails, original untouched (tx rollback). Return 200 + new stack.

5. **DeletePreview** `GET /stacks/{name}/delete-preview` — Return cascade summary: `{stack_name, instance_count, container_names: [...]}`. Shows blast radius. Build container names from instances. No side effects.

6. **ListTrash** `GET /stacks/trash` — Select stacks WHERE deleted_at IS NOT NULL. Return with deleted_at timestamp.

7. **Restore** `POST /stacks/trash/{name}/restore` — Check no active stack has same name (partial unique index will catch this, but give better error). Set deleted_at=NULL, updated_at=NOW(). Return restored stack. If name conflict: return 409 with "Stack name 'X' is already in use. Rename before restoring."

8. **PermanentDelete** `DELETE /stacks/trash/{name}` — Actually DELETE FROM stacks WHERE name=$1 AND deleted_at IS NOT NULL. Cascade deletes service_instances (ON DELETE CASCADE). Return 200.

**Transaction pattern:** Use `tx, err := h.db.BeginTx(ctx, nil); defer tx.Rollback(); ... tx.Commit()` (existing deferred rollback pattern).
  </action>
  <verify>`cd /home/fhcadmin/projects/devarch/api && go build ./...` compiles. `grep -c 'func.*StackHandler' internal/api/handlers/stack.go` shows all methods.</verify>
  <done>All advanced stack operations implemented: Enable, Disable, Clone, Rename, DeletePreview, ListTrash, Restore, PermanentDelete.</done>
</task>

<task type="auto">
  <name>Task 2: Register stack routes and wire in server</name>
  <files>api/internal/api/routes.go, api/cmd/server/main.go</files>
  <action>
**routes.go changes:**

1. Add StackHandler instantiation after existing handlers:
```go
stackHandler := handlers.NewStackHandler(db, containerClient)
```

2. Register stack routes inside the `/api/v1` route group (after existing routes):
```go
r.Route("/stacks", func(r chi.Router) {
    r.Get("/", stackHandler.List)
    r.Post("/", stackHandler.Create)

    r.Get("/trash", stackHandler.ListTrash)
    r.Post("/trash/{name}/restore", stackHandler.Restore)
    r.Delete("/trash/{name}", stackHandler.PermanentDelete)

    r.Route("/{name}", func(r chi.Router) {
        r.Get("/", stackHandler.Get)
        r.Put("/", stackHandler.Update)
        r.Delete("/", stackHandler.Delete)

        r.Post("/enable", stackHandler.Enable)
        r.Post("/disable", stackHandler.Disable)
        r.Post("/clone", stackHandler.Clone)
        r.Post("/rename", stackHandler.Rename)

        r.Get("/delete-preview", stackHandler.DeletePreview)
    })
})
```

IMPORTANT: `/trash` routes must be registered BEFORE `/{name}` routes to avoid chi treating "trash" as a name parameter.

**main.go changes:**

Check if NewRouter signature needs updating. It currently takes many params. If StackHandler only needs db + containerClient (both already passed to NewRouter), no main.go changes needed — just use existing params in routes.go to construct the handler.

Only modify main.go if the NewRouter function signature needs new parameters (unlikely — db and containerClient already available).
  </action>
  <verify>`cd /home/fhcadmin/projects/devarch/api && go build ./...` compiles. `grep 'stackHandler' internal/api/routes.go` shows handler registration. `grep '/stacks' internal/api/routes.go` shows route registration.</verify>
  <done>Stack routes registered at /api/v1/stacks/*. Server compiles and all routes accessible. Trash routes before name routes to avoid chi parameter conflicts.</done>
</task>

</tasks>

<verification>
- `cd /home/fhcadmin/projects/devarch/api && go build ./...` passes
- `grep -c 'stackHandler\.' internal/api/routes.go` shows all route registrations
- `grep 'func.*StackHandler' internal/api/handlers/stack.go | wc -l` >= 14 (constructor + 13 methods)
- Routes are logically ordered: /trash before /{name}
</verification>

<success_criteria>
All stack operations (CRUD + enable/disable + clone + rename + trash) are implemented and routed. Server compiles. Routes correctly ordered to avoid chi parameter conflicts.
</success_criteria>

<output>
After completion, create `.planning/phases/02-stack-crud/02-02-SUMMARY.md`
</output>
