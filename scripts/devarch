#!/bin/zsh
# DevArch Service Manager - Minimal transparent wrapper for podman-compose

set -e  # Exit on error

# =============================================================================
# CONFIGURATION
# =============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
COMPOSE_DIR="$PROJECT_ROOT/compose"
NETWORK="microservices-net"

# Service categories in startup order
CATEGORIES=(
    "database"
    "dbms"
    "proxy"
    "management"
    "backend"
    "project"
    "mail"
    "exporters"
    "analytics"
    "messaging"
    "search"
)

# Service definitions by category
declare -A CATEGORY_SERVICES=(
    ["database"]="mariadb mysql postgres mongodb redis mssql memcached"
    ["dbms"]="adminer phpmyadmin mongo-express metabase nocodb pgadmin redis-commander drawdb cloudbeaver"
    ["proxy"]="nginx-proxy-manager"
    ["management"]="portainer"
    ["backend"]="php node python go dotnet"
    ["project"]="openproject gitea"
    ["mail"]="mailpit"
    ["exporters"]="blackbox-exporter mongodb-exporter mysqld-exporter node-exporter postgres-exporter redis-exporter kafka-exporter memcached-exporter rabbitmq-exporter"
    ["analytics"]="matomo prometheus grafana elasticsearch kibana logstash otel-collector"
    ["messaging"]="kafka rabbitmq"
    ["search"]="meilisearch typesense"
)

# =============================================================================
# RUNTIME DETECTION
# =============================================================================

detect_runtime() {
    if command -v podman >/dev/null 2>&1; then
        RUNTIME="podman"
        COMPOSE_CMD="podman-compose"

        # Check for native podman compose
        if podman compose version >/dev/null 2>&1; then
            COMPOSE_CMD="podman compose"
        fi

        # Check if we need sudo
        if podman network exists "$NETWORK" >/dev/null 2>&1; then
            SUDO_PREFIX=""
        elif sudo -n podman network exists "$NETWORK" >/dev/null 2>&1; then
            SUDO_PREFIX="sudo"
        else
            # Network doesn't exist yet - check user groups
            if groups | grep -q podman 2>/dev/null; then
                SUDO_PREFIX=""
            else
                SUDO_PREFIX="sudo"
            fi
        fi
    elif command -v docker >/dev/null 2>&1; then
        RUNTIME="docker"
        COMPOSE_CMD="docker compose"

        # Check if we need sudo
        if groups | grep -q docker 2>/dev/null; then
            SUDO_PREFIX=""
        else
            SUDO_PREFIX="sudo"
        fi
    else
        echo "‚ùå Error: Neither podman nor docker found"
        exit 1
    fi

    CONTAINER_CMD="$SUDO_PREFIX $RUNTIME"
    COMPOSE_CMD="$SUDO_PREFIX $COMPOSE_CMD"
}

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Find service category and compose file path
find_service() {
    local service_name="$1"

    for category in "${CATEGORIES[@]}"; do
        local services="${CATEGORY_SERVICES[$category]}"
        if [[ " $services " =~ " $service_name " ]]; then
            local compose_file="$COMPOSE_DIR/$category/${service_name}.yml"
            if [[ -f "$compose_file" ]]; then
                echo "$compose_file"
                return 0
            fi
        fi
    done

    return 1
}

# Ensure network exists
ensure_network() {
    if [[ "$RUNTIME" == "podman" ]]; then
        if ! eval "$CONTAINER_CMD network exists $NETWORK" >/dev/null 2>&1; then
            echo "üîÑ Creating network: $NETWORK"
            echo "   ‚Üí $CONTAINER_CMD network create --driver bridge $NETWORK"
            eval "$CONTAINER_CMD network create --driver bridge $NETWORK"
            echo "‚úÖ Network created"
        fi
    else
        if ! eval "$CONTAINER_CMD network ls --format '{{.Name}}' | grep -q '^$NETWORK$'" 2>/dev/null; then
            echo "üîÑ Creating network: $NETWORK"
            echo "   ‚Üí $CONTAINER_CMD network create --driver bridge $NETWORK"
            eval "$CONTAINER_CMD network create --driver bridge $NETWORK"
            echo "‚úÖ Network created"
        fi
    fi
}

# =============================================================================
# COMMANDS
# =============================================================================

cmd_start() {
    local service="$1"

    if [[ -z "$service" ]]; then
        echo "‚ùå Error: Service name required"
        echo "Usage: devarch start <service>"
        exit 1
    fi

    local compose_file
    compose_file=$(find_service "$service")

    if [[ $? -ne 0 ]]; then
        echo "‚ùå Error: Service '$service' not found"
        echo "Run 'devarch list' to see available services"
        exit 1
    fi

    ensure_network

    echo "üîÑ Starting service: $service"
    echo "   ‚Üí $COMPOSE_CMD -f $compose_file up -d"
    eval "$COMPOSE_CMD -f $compose_file up -d"

    if [[ $? -eq 0 ]]; then
        echo "‚úÖ Service started: $service"
    else
        echo "‚ùå Failed to start service: $service"
        exit 1
    fi
}

cmd_stop() {
    local service="$1"

    if [[ -z "$service" ]]; then
        echo "‚ùå Error: Service name required"
        echo "Usage: devarch stop <service>"
        exit 1
    fi

    local compose_file
    compose_file=$(find_service "$service")

    if [[ $? -ne 0 ]]; then
        echo "‚ùå Error: Service '$service' not found"
        exit 1
    fi

    echo "üîÑ Stopping service: $service"
    echo "   ‚Üí $COMPOSE_CMD -f $compose_file down"
    eval "$COMPOSE_CMD -f $compose_file down"

    if [[ $? -eq 0 ]]; then
        echo "‚úÖ Service stopped: $service"
    else
        echo "‚ùå Failed to stop service: $service"
        exit 1
    fi
}

cmd_restart() {
    local service="$1"

    if [[ -z "$service" ]]; then
        echo "‚ùå Error: Service name required"
        echo "Usage: devarch restart <service>"
        exit 1
    fi

    echo "üîÑ Restarting service: $service"
    cmd_stop "$service"
    sleep 1
    cmd_start "$service"
}

cmd_logs() {
    local service="$1"
    local follow="${2:-}"

    if [[ -z "$service" ]]; then
        echo "‚ùå Error: Service name required"
        echo "Usage: devarch logs <service> [--follow]"
        exit 1
    fi

    local compose_file
    compose_file=$(find_service "$service")

    if [[ $? -ne 0 ]]; then
        echo "‚ùå Error: Service '$service' not found"
        exit 1
    fi

    local log_args="--tail 100"
    if [[ "$follow" == "--follow" || "$follow" == "-f" ]]; then
        log_args="$log_args -f"
    fi

    echo "üìã Logs for: $service"
    echo "   ‚Üí $COMPOSE_CMD -f $compose_file logs $log_args"
    eval "$COMPOSE_CMD -f $compose_file logs $log_args"
}

cmd_ps() {
    echo "üì¶ Running DevArch Services:"
    echo ""
    echo "   ‚Üí $CONTAINER_CMD ps --filter network=$NETWORK"
    eval "$CONTAINER_CMD ps --filter network=$NETWORK"
}

cmd_exec() {
    local service="$1"
    shift
    local command="$@"

    if [[ -z "$service" || -z "$command" ]]; then
        echo "‚ùå Error: Service and command required"
        echo "Usage: devarch exec <service> <command>"
        exit 1
    fi

    echo "üîß Executing in $service: $command"
    echo "   ‚Üí $CONTAINER_CMD exec -it $service $command"
    eval "$CONTAINER_CMD exec -it $service $command"
}

cmd_start_db() {
    echo "üîÑ Starting database services..."
    echo ""

    ensure_network

    for service in mariadb mysql postgres mongodb redis mssql memcached; do
        local compose_file
        compose_file=$(find_service "$service")

        if [[ $? -eq 0 ]]; then
            echo "üîÑ Starting: $service"
            echo "   ‚Üí $COMPOSE_CMD -f $compose_file up -d"
            eval "$COMPOSE_CMD -f $compose_file up -d"
            sleep 1
        fi
    done

    echo ""
    echo "‚úÖ Database services started"
}

cmd_start_backend() {
    echo "üîÑ Starting backend services..."
    echo ""

    ensure_network

    for service in php node python go dotnet; do
        local compose_file
        compose_file=$(find_service "$service")

        if [[ $? -eq 0 ]]; then
            echo "üîÑ Starting: $service"
            echo "   ‚Üí $COMPOSE_CMD -f $compose_file up -d"
            eval "$COMPOSE_CMD -f $compose_file up -d"
            sleep 1
        fi
    done

    echo ""
    echo "‚úÖ Backend services started"
}

cmd_start_all() {
    echo "üîÑ Starting all DevArch services in dependency order..."
    echo ""

    ensure_network

    for category in "${CATEGORIES[@]}"; do
        echo "üìÇ Starting category: $category"

        local services="${CATEGORY_SERVICES[$category]}"
        for service in $services; do
            local compose_file
            compose_file=$(find_service "$service")

            if [[ $? -eq 0 ]]; then
                echo "  üîÑ Starting: $service"
                echo "     ‚Üí $COMPOSE_CMD -f $compose_file up -d"
                eval "$COMPOSE_CMD -f $compose_file up -d" 2>/dev/null
                sleep 0.5
            fi
        done

        echo ""
        sleep 2  # Wait between categories
    done

    echo "‚úÖ All services started"
}

cmd_stop_all() {
    echo "üîÑ Stopping all DevArch services..."
    echo ""

    # Reverse category order for shutdown
    local reverse_categories=()
    for ((i=${#CATEGORIES[@]}-1; i>=0; i--)); do
        reverse_categories+=("${CATEGORIES[$i]}")
    done

    for category in "${reverse_categories[@]}"; do
        echo "üìÇ Stopping category: $category"

        local services="${CATEGORY_SERVICES[$category]}"
        for service in $services; do
            local compose_file
            compose_file=$(find_service "$service")

            if [[ $? -eq 0 ]]; then
                echo "  üîÑ Stopping: $service"
                echo "     ‚Üí $COMPOSE_CMD -f $compose_file down"
                eval "$COMPOSE_CMD -f $compose_file down" 2>/dev/null
            fi
        done

        echo ""
    done

    echo "‚úÖ All services stopped"
}

cmd_status() {
    echo "üìä DevArch Service Status:"
    echo ""

    for category in "${CATEGORIES[@]}"; do
        echo "üìÇ $category:"

        local services="${CATEGORY_SERVICES[$category]}"
        for service in $services; do
            local status
            status=$(eval "$CONTAINER_CMD inspect --format='{{.State.Status}}' $service 2>/dev/null" || echo "stopped")

            case "$status" in
                "running")
                    echo "  ‚úÖ $service"
                    ;;
                "stopped"|"")
                    echo "  ‚ùå $service"
                    ;;
                *)
                    echo "  ‚ö†Ô∏è  $service ($status)"
                    ;;
            esac
        done
        echo ""
    done
}

cmd_network() {
    echo "üåê Network status for: $NETWORK"
    echo ""

    if [[ "$RUNTIME" == "podman" ]]; then
        if eval "$CONTAINER_CMD network exists $NETWORK" >/dev/null 2>&1; then
            echo "‚úÖ Network exists"
            echo ""
            echo "   ‚Üí $CONTAINER_CMD network inspect $NETWORK"
            eval "$CONTAINER_CMD network inspect $NETWORK"
        else
            echo "‚ùå Network does not exist"
            echo ""
            echo "Run 'devarch start <service>' to create it automatically"
        fi
    else
        if eval "$CONTAINER_CMD network ls --format '{{.Name}}' | grep -q '^$NETWORK$'" 2>/dev/null; then
            echo "‚úÖ Network exists"
            echo ""
            echo "   ‚Üí $CONTAINER_CMD network inspect $NETWORK"
            eval "$CONTAINER_CMD network inspect $NETWORK"
        else
            echo "‚ùå Network does not exist"
            echo ""
            echo "Run 'devarch start <service>' to create it automatically"
        fi
    fi
}

cmd_list() {
    echo "üìã Available DevArch Services:"
    echo ""

    for category in "${CATEGORIES[@]}"; do
        echo "üìÇ $category:"

        local services="${CATEGORY_SERVICES[$category]}"
        for service in $services; do
            local compose_file="$COMPOSE_DIR/$category/${service}.yml"
            if [[ -f "$compose_file" ]]; then
                echo "  ‚Ä¢ $service"
            else
                echo "  ‚Ä¢ $service (compose file missing)"
            fi
        done
        echo ""
    done
}

cmd_help() {
    cat << 'EOF'
DevArch - Minimal transparent service manager

USAGE:
    devarch <command> [arguments]

CORE COMMANDS:
    start <service>         Start a service
    stop <service>          Stop a service
    restart <service>       Restart a service
    logs <service> [-f]     Show service logs (use -f to follow)
    exec <service> <cmd>    Execute command in service container

CONVENIENCE COMMANDS:
    start-db                Start all database services
    start-backend           Start all backend runtimes
    start-all               Start all services in dependency order
    stop-all                Stop all services

UTILITY COMMANDS:
    ps                      Show running DevArch containers
    status                  Show status of all services
    network                 Show/inspect network
    list                    List all available services
    help                    Show this help

EXAMPLES:
    devarch start postgres              # Start PostgreSQL
    devarch logs nginx-proxy-manager -f # Follow nginx logs
    devarch exec php bash               # Open bash in PHP container
    devarch start-db                    # Start all databases
    devarch start-all                   # Start everything

STARTUP ORDER (for start-all):
    1. database    - Core data stores
    2. dbms        - Database management tools
    3. proxy       - Nginx Proxy Manager
    4. management  - Portainer, etc.
    5. backend     - PHP, Node, Python, Go, .NET
    6. project     - OpenProject, Gitea
    7. mail        - Mailpit
    8. exporters   - Prometheus exporters
    9. analytics   - Prometheus, Grafana, ELK
    10. messaging  - Kafka, RabbitMQ
    11. search     - Meilisearch, Typesense

NOTES:
    - All commands show the exact podman/docker command being executed
    - Network (microservices-net) is created automatically if missing
    - Services must be started in order for dependencies to work
    - Use 'devarch list' to see all available services

DIRECT EQUIVALENTS:
    devarch start postgres  ‚Üí podman-compose -f compose/database/postgres.yml up -d
    devarch stop postgres   ‚Üí podman-compose -f compose/database/postgres.yml down
    devarch logs postgres   ‚Üí podman-compose -f compose/database/postgres.yml logs --tail 100
    devarch exec php bash   ‚Üí podman exec -it php bash
    devarch ps              ‚Üí podman ps --filter network=microservices-net

EOF
}

# =============================================================================
# MAIN DISPATCH
# =============================================================================

# Detect runtime first
detect_runtime

# Dispatch command
case "${1:-}" in
    start)
        cmd_start "$2"
        ;;
    stop)
        cmd_stop "$2"
        ;;
    restart)
        cmd_restart "$2"
        ;;
    logs)
        cmd_logs "$2" "$3"
        ;;
    ps)
        cmd_ps
        ;;
    exec)
        shift
        cmd_exec "$@"
        ;;
    start-db)
        cmd_start_db
        ;;
    start-backend)
        cmd_start_backend
        ;;
    start-all)
        cmd_start_all
        ;;
    stop-all)
        cmd_stop_all
        ;;
    status)
        cmd_status
        ;;
    network)
        cmd_network
        ;;
    list)
        cmd_list
        ;;
    help|--help|-h|"")
        cmd_help
        ;;
    *)
        echo "‚ùå Unknown command: $1"
        echo ""
        cmd_help
        exit 1
        ;;
esac
