# devarch - scripts
Generated: Wed Jun 18 13:42:23 EDT 2025
Folder: scripts

## Folder Structure
scripts/config.sh
scripts/extract-certificates.sh
scripts/generate-context.sh
scripts/install.sh
scripts/laravel/setup-laravel.sh
scripts/runtime-switcher.sh
scripts/setup-databases.sh
scripts/setup-podman-socket.sh
scripts/setup-ssl.sh
scripts/show-services.sh
scripts/socket-manager.sh
scripts/start-services.sh
scripts/stop-services.sh
scripts/trust-host.sh
scripts/wordpress/install-starred-repos.sh
scripts/wordpress/install-wp-bare.sh
scripts/wordpress/install-wp-clean.sh
scripts/wordpress/install-wp-custom.sh
scripts/wordpress/install-wp-loaded.sh

## Files

### scripts/config.sh
```
#!/bin/zsh

# =============================================================================
# MICROSERVICES CONFIGURATION MANAGEMENT - ENHANCED
# =============================================================================
# Smart configuration with automatic path resolution and flexible overrides

# =============================================================================
# SCRIPT METADATA & PATHS
# =============================================================================

# Get script location using zsh-specific method
SCRIPT_SOURCE="${(%):-%x}"

# Establish project structure
export PROJECT_ROOT=$(cd "$(dirname "$SCRIPT_SOURCE")/../" && pwd)
export SCRIPT_DIR="${PROJECT_ROOT}/scripts"
export COMPOSE_DIR="${PROJECT_ROOT}/compose"
export CONFIG_DIR="${PROJECT_ROOT}/config"
export APPS_DIR="${PROJECT_ROOT}/apps"
export LOGS_DIR="${PROJECT_ROOT}/logs"

# =============================================================================
# NETWORK & CONTAINER CONFIGURATION
# =============================================================================

export NETWORK_NAME="microservices-net"
export CONTAINER_RUNTIME="podman"  # Change to "docker" if using Docker instead

# =============================================================================
# SERVICE CATEGORIES & COMPOSE FILES - SMART CONFIGURATION
# =============================================================================

# Smart service definitions - automatically resolves paths based on category
typeset -A SERVICE_CATEGORIES
SERVICE_CATEGORIES=(
    [proxy]="traefik.yml nginx-proxy-manager.yml"
    [database]="mariadb.yml mysql.yml postgres.yml mongodb.yml redis.yml"
    [exporters]="blackbox-exporter.yml mongodb-exporter.yml mysqld-exporter.yml node-exporter.yml postgres-exporter.yml redis-exporter.yml"
    [dbms]="adminer.yml phpmyadmin.yml mongo-express.yml metabase.yml nocodb.yml pgadmin.yml redis-commander.yml"
    [backend]="php.yml node.yml python.yml go.yml dotnet.yml"
    [analytics]="elasticsearch.yml kibana.yml logstash.yml grafana.yml prometheus.yml matomo.yml cadvisor.yml otel-collector.yml"
    [ai-services]="langflow.yml n8n.yml"
    [mail]="mailpit.yml"
    [project]="gitea.yml"
    [management]="portainer.yml"  # Add Portainer to management category
)

# Optional: Override category paths if you need different directory structure
typeset -A CATEGORY_PATH_OVERRIDES
CATEGORY_PATH_OVERRIDES=(
    # [category]="custom/path"
    # Example: [backend]="apps/backend"
    # Example: [legacy]="old-services"
    # Example: [management]="infrastructure/management"
)

# Optional: Full path overrides for specific services (for maximum flexibility)
typeset -A SERVICE_PATH_OVERRIDES
SERVICE_PATH_OVERRIDES=(
    # [service.yml]="full/custom/path/service.yml"
    # Example: [special-service.yml]="legacy/docker-compose.yml"
    # Example: [nginx.yml]="infrastructure/nginx/docker-compose.yml"
    # Example: [portainer.yml]="infrastructure/portainer/docker-compose.yml"
)

# Service startup order (critical for dependencies) - zsh array
SERVICE_STARTUP_ORDER=(
    "management"   # Add management first - Portainer should start early for container oversight
    "proxy"
    "database"
    "exporters"
    "dbms" 
    "backend"
    "analytics"
    "ai-services"
    "mail"
    "project"
)

# =============================================================================
# SMART PATH RESOLUTION FUNCTIONS
# =============================================================================

# Function to resolve the full path for a service file
resolve_service_path() {
    local service_file="$1"
    local category="$2"
    local resolved_path=""
    
    # Check for specific service override first
    if [[ -n "${SERVICE_PATH_OVERRIDES[$service_file]}" ]]; then
        resolved_path="$COMPOSE_DIR/${SERVICE_PATH_OVERRIDES[$service_file]}"
        echo "$resolved_path"
        return 0
    fi
    
    # Check for category path override
    local category_path="$category"
    if [[ -n "${CATEGORY_PATH_OVERRIDES[$category]}" ]]; then
        category_path="${CATEGORY_PATH_OVERRIDES[$category]}"
    fi
    
    # Construct the standard path
    local full_path="$COMPOSE_DIR/$category_path/$service_file"
    
    # Verify the file exists, if not try fallback locations
    if [[ -f "$full_path" ]]; then
        resolved_path="$full_path"
        echo "$resolved_path"
        return 0
    fi
    
    # Fallback 1: Try without category subdirectory (flat structure)
    local flat_path="$COMPOSE_DIR/$service_file"
    if [[ -f "$flat_path" ]]; then
        resolved_path="$flat_path"
        echo "$resolved_path"
        return 0
    fi
    
    # Fallback 2: Search in all subdirectories
    local found_path
    found_path=$(find "$COMPOSE_DIR" -name "$service_file" -type f 2>/dev/null | head -1)
    if [[ -n "$found_path" ]]; then
        resolved_path="$found_path"
        echo "$resolved_path"
        return 0
    fi
    
    # Return the expected path even if it doesn't exist (for error reporting)
    resolved_path="$full_path"
    echo "$resolved_path"
    return 1
}

# Enhanced function to get service files for a category with full paths
get_service_files() {
    local category="$1"
    local return_paths="${2:-false}"  # if true, return full paths instead of just filenames
    
    if [[ -z "${SERVICE_CATEGORIES[$category]}" ]]; then
        print_status "error" "Unknown service category: $category"
        return 1
    fi
    
    local service_files="${SERVICE_CATEGORIES[$category]}"
    
    if [[ "$return_paths" == "true" ]]; then
        # Return full resolved paths
        local -a files paths
        files=(${=service_files})
        
        for service_file in "${files[@]}"; do
            local resolved_path
            resolved_path=$(resolve_service_path "$service_file" "$category")
            paths+=("$resolved_path")
        done
        
        echo "${paths[@]}"
    else
        # Return just the filenames (original behavior)
        echo "$service_files"
    fi
}

# Function to validate all service files exist
validate_service_files() {
    local category="$1"
    local -a missing_files valid_files
    
    if [[ -z "${SERVICE_CATEGORIES[$category]}" ]]; then
        print_status "error" "Unknown service category: $category"
        return 1
    fi
    
    local service_files="${SERVICE_CATEGORIES[$category]}"
    local -a files
    files=(${=service_files})
    
    print_status "step" "Validating $category service files..."
    
    for service_file in "${files[@]}"; do
        local resolved_path
        resolved_path=$(resolve_service_path "$service_file" "$category")
        
        if [[ -f "$resolved_path" ]]; then
            valid_files+=("$service_file")
            if [[ "$VERBOSE_VALIDATION" == "true" ]]; then
                print_status "info" "‚úì Found: $service_file -> $resolved_path"
            fi
        else
            missing_files+=("$service_file")
            print_status "warning" "‚ùå Missing: $service_file (expected at $resolved_path)"
        fi
    done
    
    if [[ ${#missing_files[@]} -gt 0 ]]; then
        print_status "warning" "Category '$category' has ${#missing_files[@]} missing file(s): ${missing_files[*]}"
        print_status "info" "Available files: ${valid_files[*]}"
        return 1
    else
        print_status "success" "All $category service files found (${#valid_files[@]} files)"
        return 0
    fi
}

# Function to list all available service files with their resolved paths
list_all_services() {
    echo "=== SERVICE FILE MAPPING ==="
    echo ""
    
    for category in "${SERVICE_STARTUP_ORDER[@]}"; do
        echo "Category: $category"
        echo "----------------------------------------"
        
        if [[ -n "${SERVICE_CATEGORIES[$category]}" ]]; then
            local service_files="${SERVICE_CATEGORIES[$category]}"
            local -a files
            files=(${=service_files})
            
            for service_file in "${files[@]}"; do
                # Use a simple approach without persistent variables
                local file_path="$(resolve_service_path "$service_file" "$category" 2>/dev/null)"
                local status_icon="‚ùå MISSING"
                
                [[ -f "$file_path" ]] && status_icon="‚úÖ EXISTS"
                
                printf "  %-25s -> %s [%s]\n" "$service_file" "$file_path" "$status_icon"
            done
        else
            echo "  No services defined"
        fi
        echo ""
    done
}

# Enhanced start function with smart path resolution
start_service_category() {
    local category="$1"
    local service_files
    service_files=$(get_service_files "$category")
    
    if [[ -z "$service_files" ]]; then
        return 1
    fi
    
    print_status "step" "Starting $category services..."
    
    # Split service_files into array using zsh word splitting
    local -a files
    files=(${=service_files})
    
    local started=0 failed=0
    
    for service_file in "${files[@]}"; do
        local full_path
        full_path=$(resolve_service_path "$service_file" "$category")
        
        if [[ -f "$full_path" ]]; then
            print_status "info" "Starting services from $service_file..."
            if eval "$COMPOSE_CMD -f \"$full_path\" up -d $ERROR_REDIRECT"; then
                ((started++))
            else
                print_status "error" "Failed to start services from $service_file"
                ((failed++))
            fi
        else
            print_status "warning" "Service file not found: $full_path"
            ((failed++))
        fi
    done
    
    if [[ $failed -eq 0 ]]; then
        print_status "success" "$category services started successfully ($started/$((started + failed)))"
    else
        print_status "warning" "$category services partially started ($started/$((started + failed))) - $failed failed"
    fi
    
    return $failed
}

# Enhanced stop function with smart path resolution
stop_service_category() {
    local category="$1"
    local service_files
    service_files=$(get_service_files "$category")
    
    if [[ -z "$service_files" ]]; then
        return 1
    fi
    
    print_status "step" "Stopping $category services..."
    
    # Split service_files into array using zsh word splitting
    local -a files
    files=(${=service_files})
    
    for service_file in "${files[@]}"; do
        local full_path
        full_path=$(resolve_service_path "$service_file" "$category")
        
        if [[ -f "$full_path" ]]; then
            print_status "info" "Stopping services from $service_file..."
            eval "$COMPOSE_CMD -f \"$full_path\" down $ERROR_REDIRECT" || true
        else
            print_status "warning" "Service file not found: $full_path (skipping)"
        fi
    done
    
    print_status "success" "$category services stopped"
}

# =============================================================================
# CONFIGURATION UTILITIES
# =============================================================================

# Function to add a service override
add_service_override() {
    local service_file="$1"
    local custom_path="$2"
    
    SERVICE_PATH_OVERRIDES[$service_file]="$custom_path"
    print_status "success" "Added service override: $service_file -> $custom_path"
}

# Function to add a category override
add_category_override() {
    local category="$1"
    local custom_path="$2"
    
    CATEGORY_PATH_OVERRIDES[$category]="$custom_path"
    print_status "success" "Added category override: $category -> $custom_path"
}

# Function to show current configuration
show_configuration() {
    echo "=== SMART CONFIGURATION STATUS ==="
    echo ""
    echo "Project Root: $PROJECT_ROOT"
    echo "Compose Dir:  $COMPOSE_DIR"
    echo "Container Runtime: $CONTAINER_RUNTIME"
    echo ""
    
    echo "Service Categories:"
    for category in "${SERVICE_STARTUP_ORDER[@]}"; do
        local count
        count=$(echo "${SERVICE_CATEGORIES[$category]}" | wc -w)
        printf "  %-15s: %d services\n" "$category" "$count"
    done
    echo ""
    
    if [[ ${#CATEGORY_PATH_OVERRIDES[@]} -gt 0 ]]; then
        echo "Category Path Overrides:"
        for category in "${(@k)CATEGORY_PATH_OVERRIDES}"; do
            printf "  %-15s -> %s\n" "$category" "${CATEGORY_PATH_OVERRIDES[$category]}"
        done
        echo ""
    fi
    
    if [[ ${#SERVICE_PATH_OVERRIDES[@]} -gt 0 ]]; then
        echo "Service Path Overrides:"
        for service in "${(@k)SERVICE_PATH_OVERRIDES}"; do
            printf "  %-25s -> %s\n" "$service" "${SERVICE_PATH_OVERRIDES[$service]}"
        done
        echo ""
    fi
}

# =============================================================================
# DATABASE CREDENTIALS (unchanged)
# =============================================================================

export MARIADB_ROOT_PASSWORD="123456"
export MYSQL_ROOT_PASSWORD="123456"
export POSTGRES_PASSWORD="123456"
export MONGO_ROOT_PASSWORD="123456"
export ADMIN_PASSWORD="123456"

# =============================================================================
# SSL CONFIGURATION (unchanged)
# =============================================================================

export SSL_DOMAIN="*.test"
export SSL_CERT_DIR="/etc/letsencrypt/live/wildcard.test"
export SSL_DAYS_VALID="3650"  # 10 years for development

# =============================================================================
# RUNTIME DETECTION & COMMAND SETUP (unchanged)
# =============================================================================

# Detect if we should use sudo (for Docker on Linux)
detect_sudo_requirement() {
    if command -v podman >/dev/null 2>&1; then
        export USE_PODMAN=true
        export DEFAULT_SUDO=true
    elif command -v docker >/dev/null 2>&1; then
        export USE_PODMAN=true
        # Check if user is in docker group
        if groups | grep -q docker 2>/dev/null; then
            export DEFAULT_SUDO=false
        else
            export DEFAULT_SUDO=true
        fi
    else
        echo "Error: Neither podman nor docker found!"
        exit 1
    fi
}

# Set up command execution context
setup_command_context() {
    local use_sudo="${1:-$DEFAULT_SUDO}"
    local show_errors="${2:-false}"
    
    if [[ "$use_sudo" == "true" ]]; then
        export SUDO_PREFIX="sudo "
    else
        export SUDO_PREFIX=""
    fi
    
    if [[ "$show_errors" == "true" ]]; then
        export ERROR_REDIRECT=""
    else
        export ERROR_REDIRECT="2>/dev/null"
    fi
    
    # Set container command based on runtime
    if [[ "$USE_PODMAN" == "true" ]]; then
        export CONTAINER_CMD="${SUDO_PREFIX}podman"
        
        # Check for native podman compose support first
        if command -v "podman" >/dev/null 2>&1 && ${SUDO_PREFIX}podman compose --help >/dev/null 2>&1; then
            export COMPOSE_CMD="${SUDO_PREFIX}podman compose"
            export COMPOSE_PROVIDER="native"
        else
            # Fallback to podman-compose
            export COMPOSE_CMD="${SUDO_PREFIX}podman-compose"
            export COMPOSE_PROVIDER="external"
        fi
        
        # Set podman-specific environment variables
        export PODMAN_COMPOSE_WARNING_LOGS="false"
        export COMPOSE_IGNORE_ORPHANS="true"
        export PODMAN_USERNS="keep-id"
        
    else
        export CONTAINER_CMD="${SUDO_PREFIX}docker"
        export COMPOSE_CMD="${SUDO_PREFIX}docker compose"
        export COMPOSE_PROVIDER="native"
    fi
}

# =============================================================================
# UTILITY FUNCTIONS (unchanged but enhanced error messages)
# =============================================================================

# Function to handle errors consistently
handle_error() {
    local message="$1"
    local exit_code="${2:-1}"
    echo "‚ùå Error: $message" >&2
    exit "$exit_code"
}

# Function to check command status
check_status() {
    local exit_code=$?
    local message="$1"
    if [[ $exit_code -ne 0 ]]; then
        handle_error "$message" "$exit_code"
    fi
}

# Function to print colored output
print_status() {
    local level="$1"
    local message="$2"
    
    case "$level" in
        "info")
            echo "‚ÑπÔ∏è  $message"
            ;;
        "success")
            echo "‚úÖ $message"
            ;;
        "warning")
            echo "‚ö†Ô∏è  $message"
            ;;
        "error")
            echo "‚ùå $message"
            ;;
        "step")
            echo "üîÑ $message"
            ;;
        *)
            echo "$message"
            ;;
    esac
}

... (file truncated - showing first 500 of 756 lines)
```

### scripts/extract-certificates.sh
```
#!/bin/bash

# =============================================================================
# SSL CERTIFICATE EXTRACTION SCRIPT
# =============================================================================
# Extracts SSL certificates from nginx-proxy-manager container for web UI setup

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Default container runtime
CONTAINER_CMD="sudo podman"

print_header() {
    echo -e "${BLUE}======================================${NC}"
    echo -e "${BLUE}  SSL CERTIFICATE EXTRACTION TOOL${NC}"
    echo -e "${BLUE}======================================${NC}"
    echo ""
}

print_section() {
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}$(printf '=%.0s' $(seq 1 ${#1}))${NC}"
}

check_container() {
    echo -e "${YELLOW}Checking nginx-proxy-manager container...${NC}"
    
    if ! $CONTAINER_CMD container exists nginx-proxy-manager 2>/dev/null; then
        echo -e "${RED}Error: nginx-proxy-manager container not found!${NC}"
        echo "Please start the proxy services first:"
        echo "  ./scripts/start-services.sh -c proxy"
        exit 1
    fi
    
    local status=$($CONTAINER_CMD inspect --format='{{.State.Status}}' nginx-proxy-manager 2>/dev/null)
    if [[ "$status" != "running" ]]; then
        echo -e "${RED}Error: nginx-proxy-manager container is not running (status: $status)${NC}"
        echo "Please start the container first:"
        echo "  $CONTAINER_CMD start nginx-proxy-manager"
        exit 1
    fi
    
    echo -e "${GREEN}‚úì Container is running${NC}"
    echo ""
}

check_certificates() {
    echo -e "${YELLOW}Checking for SSL certificates...${NC}"
    
    if ! $CONTAINER_CMD exec nginx-proxy-manager test -f /etc/letsencrypt/live/wildcard.test/fullchain.pem 2>/dev/null; then
        echo -e "${RED}Error: Certificate not found in container!${NC}"
        echo "Please run the SSL setup script first:"
        echo "  ./scripts/setup-ssl.sh -s -e"
        exit 1
    fi
    
    if ! $CONTAINER_CMD exec nginx-proxy-manager test -f /etc/letsencrypt/live/wildcard.test/privkey.pem 2>/dev/null; then
        echo -e "${RED}Error: Private key not found in container!${NC}"
        echo "Please run the SSL setup script first:"
        echo "  ./scripts/setup-ssl.sh -s -e"
        exit 1
    fi
    
    echo -e "${GREEN}‚úì Certificates found${NC}"
    echo ""
}

extract_and_display() {
    print_section "PRIVATE KEY (Certificate Key Field)"
    echo -e "${YELLOW}Copy everything between and including the BEGIN/END lines:${NC}"
    echo ""
    echo -e "${GREEN}--- START COPYING FROM HERE ---${NC}"
    $CONTAINER_CMD exec nginx-proxy-manager cat /etc/letsencrypt/live/wildcard.test/privkey.pem 2>/dev/null
    echo -e "${GREEN}--- STOP COPYING HERE ---${NC}"
    echo ""
    echo ""
    
    print_section "CERTIFICATE (Certificate Field)"
    echo -e "${YELLOW}Copy everything between and including the BEGIN/END lines:${NC}"
    echo ""
    echo -e "${GREEN}--- START COPYING FROM HERE ---${NC}"
    $CONTAINER_CMD exec nginx-proxy-manager cat /etc/letsencrypt/live/wildcard.test/fullchain.pem 2>/dev/null
    echo -e "${GREEN}--- STOP COPYING HERE ---${NC}"
    echo ""
}

save_to_files() {
    local save_dir="$1"
    mkdir -p "$save_dir"
    
    echo -e "${YELLOW}Saving certificates to files...${NC}"
    
    # Save private key
    $CONTAINER_CMD exec nginx-proxy-manager cat /etc/letsencrypt/live/wildcard.test/privkey.pem > "$save_dir/privkey.pem" 2>/dev/null
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}‚úì Private key saved to: $save_dir/privkey.pem${NC}"
    else
        echo -e "${RED}‚úó Failed to save private key${NC}"
    fi
    
    # Save certificate
    $CONTAINER_CMD exec nginx-proxy-manager cat /etc/letsencrypt/live/wildcard.test/fullchain.pem > "$save_dir/fullchain.pem" 2>/dev/null
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}‚úì Certificate saved to: $save_dir/fullchain.pem${NC}"
    else
        echo -e "${RED}‚úó Failed to save certificate${NC}"
    fi
    
    # Create a combined file for convenience
    if [[ -f "$save_dir/privkey.pem" && -f "$save_dir/fullchain.pem" ]]; then
        cat "$save_dir/fullchain.pem" "$save_dir/privkey.pem" > "$save_dir/combined.pem"
        echo -e "${GREEN}‚úì Combined certificate saved to: $save_dir/combined.pem${NC}"
    fi
    
    echo ""
}

show_npm_instructions() {
    print_section "NGINX PROXY MANAGER SETUP INSTRUCTIONS"
    echo ""
    echo -e "${YELLOW}1. Open Nginx Proxy Manager in your browser:${NC}"
    echo "   http://localhost:81"
    echo ""
    echo -e "${YELLOW}2. Login with default credentials:${NC}"
    echo "   Email: admin@example.com"
    echo "   Password: changeme"
    echo "   (You'll be prompted to change these on first login)"
    echo ""
    echo -e "${YELLOW}3. Add SSL Certificate:${NC}"
    echo "   ‚Ä¢ Go to 'SSL Certificates' tab"
    echo "   ‚Ä¢ Click 'Add SSL Certificate'"
    echo "   ‚Ä¢ Select 'Custom'"
    echo "   ‚Ä¢ Name: wildcard.test"
    echo "   ‚Ä¢ Certificate Key: Paste the PRIVATE KEY from above"
    echo "   ‚Ä¢ Certificate: Paste the CERTIFICATE from above"
    echo "   ‚Ä¢ Click 'Save'"
    echo ""
    echo -e "${YELLOW}4. Create Proxy Hosts (example for Grafana):${NC}"
    echo "   ‚Ä¢ Go to 'Hosts' ‚Üí 'Proxy Hosts'"
    echo "   ‚Ä¢ Click 'Add Proxy Host'"
    echo "   ‚Ä¢ Domain Names: grafana.test"
    echo "   ‚Ä¢ Forward Hostname/IP: grafana"
    echo "   ‚Ä¢ Forward Port: 3000"
    echo "   ‚Ä¢ Go to 'SSL' tab"
    echo "   ‚Ä¢ SSL Certificate: Select 'wildcard.test'"
    echo "   ‚Ä¢ Force SSL: ‚úì Enable"
    echo "   ‚Ä¢ HTTP/2 Support: ‚úì Enable"
    echo "   ‚Ä¢ Click 'Save'"
    echo ""
    echo -e "${YELLOW}5. Test your setup:${NC}"
    echo "   curl -k https://grafana.test"
    echo ""
}

show_quick_services() {
    print_section "QUICK SERVICE SETUP"
    echo ""
    echo -e "${YELLOW}Common services to set up with wildcard.test certificate:${NC}"
    echo ""
    cat << 'EOF'
| Service     | Domain          | Forward Host | Port |
|-------------|-----------------|--------------|------|
| Grafana     | grafana.test    | grafana      | 3000 |
| Metabase    | metabase.test   | metabase     | 3000 |
| Adminer     | adminer.test    | adminer      | 8080 |
| phpMyAdmin  | phpmyadmin.test | phpmyadmin   | 80   |
| Mongo Exp   | mongodb.test    | mongo-express| 8081 |
| n8n         | n8n.test        | n8n          | 5678 |
| Langflow    | langflow.test   | langflow     | 7860 |
| Kibana      | kibana.test     | kibana       | 5601 |
| Mailpit     | mailpit.test    | mailpit      | 8025 |
| Gitea       | gitea.test      | gitea        | 3000 |
| NocoDB      | nocodb.test     | nocodb       | 8080 |
| pgAdmin     | pgadmin.test    | pgadmin      | 80   |
EOF
    echo ""
}

usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  -s, --save DIR    Save certificates to directory"
    echo "  -d, --docker      Use docker instead of podman"
    echo "  -q, --quiet       Only show certificates (no instructions)"
    echo "  -h, --help        Show this help"
    echo ""
    echo "EXAMPLES:"
    echo "  $0                      # Display certificates and instructions"
    echo "  $0 -s ~/ssl-certs       # Save certificates to ~/ssl-certs"
    echo "  $0 -q                   # Only show certificates"
    echo "  $0 -d                   # Use docker instead of podman"
}

# Parse command line arguments
SAVE_DIR=""
QUIET=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -s|--save)
            SAVE_DIR="$2"
            shift 2
            ;;
        -d|--docker)
            CONTAINER_CMD="sudo docker"
            shift
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Main execution
main() {
    if [[ "$QUIET" == "false" ]]; then
        print_header
    fi
    
    check_container
    check_certificates
    extract_and_display
    
    if [[ -n "$SAVE_DIR" ]]; then
        save_to_files "$SAVE_DIR"
    fi
    
    if [[ "$QUIET" == "false" ]]; then
        show_npm_instructions
        show_quick_services
        
        echo -e "${BLUE}======================================${NC}"
        echo -e "${GREEN}Certificate extraction completed!${NC}"
        echo -e "${BLUE}======================================${NC}"
    fi
}

main "$@"```

### scripts/generate-context.sh
```
#!/bin/zsh

# Smart Context Sync - Organized project documentation

# Configuration - add/remove folders as needed
FOLDERS_TO_PROCESS=(
    "compose"
    "config" 
    "scripts"
)

# Output directory
CONTEXT_DIR="./context"

# Helper function to check if file is likely text/readable
is_text_file() {
    local file="$1"
    
    # Skip known binary extensions
    case "${file##*.}" in
        jpg|jpeg|png|gif|bmp|svg|ico|pdf|zip|tar|gz|bz2|xz|7z|rar|exe|dll|so|dylib|bin|dat|db|sqlite|lock)
            return 1
            ;;
    esac
    
    # Use file command if available, otherwise assume text
    if command -v file >/dev/null 2>&1; then
        file "$file" | grep -q -E "(text|JSON|XML|script|shell|Python|JavaScript|HTML|CSS)"
    else
        return 0
    fi
}

# Generate hosts file entries dynamically from compose files
generate_hosts_file() {
    local hosts_file="$CONTEXT_DIR/hosts.txt"
    local compose_dir="compose"
    
    echo "Generating dynamic hosts file entries from compose files..."
    
    # Create hosts file header
    cat > "$hosts_file" << 'EOF'
# Microservices Host File Entries
# Dynamically generated from Docker Compose files
# Add these to your system hosts file (/etc/hosts on Linux/Mac, C:\Windows\System32\drivers\etc\hosts on Windows)
EOF
    echo "# Generated on: $(date)" >> "$hosts_file"
    echo "# Source: Parsed from $compose_dir/ directory" >> "$hosts_file"
    echo "" >> "$hosts_file"
    
    # Check if compose directory exists
    if [[ ! -d "$compose_dir" ]]; then
        echo "# ERROR: $compose_dir directory not found!" >> "$hosts_file"
        echo "Warning: $compose_dir directory not found, cannot generate dynamic hosts"
        return 1
    fi
    
    # Simple approach - just collect all domains
    local all_domains=()
    
    # Parse all compose files
    for compose_file in $(find "$compose_dir" -name "*.yml" -o -name "*.yaml" 2>/dev/null | sort); do
        echo "  Parsing $compose_file..."
        
        # Extract Host rules
        local domains=$(grep -o 'Host(`[^`]*`)' "$compose_file" 2>/dev/null | sed 's/Host(`//g' | sed 's/`)//g')
        
        # Add found domains
        for domain in $domains; do
            if [[ "$domain" == *.test ]]; then
                if [[ "$domain" != *'$'* ]]; then
                    if [[ "$domain" != *'['* ]]; then
                        all_domains+=("$domain")
                    fi
                fi
            fi
        done
        
        # If no domains found, use filename
        if [[ -z "$domains" ]]; then
            local filename=$(basename "$compose_file" .yml)
            case "$filename" in
                mariadb|mysql|postgres|mongodb|redis|elasticsearch|logstash)
                    # Skip database services
                    ;;
                *)
                    all_domains+=("${filename}.test")
                    ;;
            esac
        fi
    done
    
    # Remove duplicates and sort
    local unique_domains=($(printf '%s\n' "${all_domains[@]}" | sort -u))
    
    # Output domains grouped by lines
    echo "# All Services" >> "$hosts_file"
    local line="127.0.0.1"
    local count=0
    
    for domain in "${unique_domains[@]}"; do
        line="$line $domain"
        count=$((count + 1))
        
        if [[ $count -eq 6 ]]; then
            echo "$line" >> "$hosts_file"
            line="127.0.0.1"
            count=0
        fi
    done
    
    # Output remaining domains
    if [[ $count -gt 0 ]]; then
        echo "$line" >> "$hosts_file"
    fi
    
    echo "" >> "$hosts_file"
    echo "# Summary: ${#unique_domains[@]} domains found" >> "$hosts_file"
    
    echo "Generated dynamic hosts file: $hosts_file (${#unique_domains[@]} unique domains)"
}

# Process a single folder
process_folder() {
    local folder="$1"
    local output_file="$CONTEXT_DIR/${folder}.txt"
    local file_count=0
    
    echo "Processing folder: $folder"
    
    # If folder doesn't exist, skip it
    if [[ ! -d "$folder" ]]; then
        echo "Warning: Folder '$folder' not found, skipping"
        return
    fi
    
    # Header
    echo "# $(basename "$(pwd)") - $folder" > "$output_file"
    echo "Generated: $(date)" >> "$output_file"
    echo "Folder: $folder" >> "$output_file"
    echo "" >> "$output_file"
    
    # Get folder structure
    echo "## Folder Structure" >> "$output_file"
    if command -v tree >/dev/null 2>&1; then
        tree "$folder" >> "$output_file"
    else
        find "$folder" -type f | sort >> "$output_file"
    fi
    echo "" >> "$output_file"
    
    # Process all files in the folder
    echo "## Files" >> "$output_file"
    
    for file in $(find "$folder" -type f 2>/dev/null | sort); do
        # Check if it's a readable text file
        if is_text_file "$file"; then
            echo "" >> "$output_file"
            echo "### $file" >> "$output_file"
            echo '```' >> "$output_file"
            
            # Add the file content (limit to 500 lines to prevent massive files)
            if [[ -r "$file" ]]; then
                head -500 "$file" >> "$output_file"
                
                # Add note if file was truncated
                local total_lines=$(wc -l < "$file" 2>/dev/null || echo "0")
                if [[ $total_lines -gt 500 ]]; then
                    echo "" >> "$output_file"
                    echo "... (file truncated - showing first 500 of $total_lines lines)" >> "$output_file"
                fi
            else
                echo "(file not readable)" >> "$output_file"
            fi
            
            echo '```' >> "$output_file"
            file_count=$((file_count + 1))
        fi
    done
    
    # Footer
    echo "" >> "$output_file"
    echo "---" >> "$output_file"
    echo "Files processed: $file_count" >> "$output_file"
    
    local size=$(wc -c < "$output_file")
    echo "Created $output_file ($file_count files, $(( size / 1024 ))KB)"
}

# Main function
main() {
    local project_name=Devarch
    
    echo "Smart Context Sync for: $project_name"
    echo "=================================="
    
    # If we're in a scripts folder, go up one level
    if [[ "$(basename "$(pwd)")" == "scripts" ]] || [[ "$(basename "$(pwd)")" == "bin" ]] || [[ "$(basename "$(pwd)")" == "tools" ]]; then
        cd ..
        echo "Moved up to project root: $(pwd)"
    fi
    
    # Create context directory if it doesn't exist
    mkdir -p "$CONTEXT_DIR"
    
    # Generate hosts file entries
    generate_hosts_file
    
    # Create master index file
    local index_file="$CONTEXT_DIR/index.txt"
    echo "# $project_name - Context Index" > "$index_file"
    echo "Generated: $(date)" >> "$index_file"
    echo "" >> "$index_file"
    
    # Add git context if available
    if git rev-parse --git-dir >/dev/null 2>&1; then
        echo "## Git Status" >> "$index_file"
        echo "Branch: $(git branch --show-current 2>/dev/null || echo 'unknown')" >> "$index_file"
        echo "" >> "$index_file"
        echo "Recent commits:" >> "$index_file"
        git log --oneline -5 2>/dev/null >> "$index_file" || echo "No git history" >> "$index_file"
        echo "" >> "$index_file"
    fi
    
    # Add project structure to index
    echo "## Project Structure" >> "$index_file"
    if command -v tree >/dev/null 2>&1; then
        tree -I 'node_modules|.git|dist|build|venv|__pycache__|target|context' >> "$index_file"
    else
        find . -type d -not -path '*/.*' -not -path '*/node_modules/*' -not -path '*/dist/*' -not -path '*/build/*' -not -path '*/context/*' | sort >> "$index_file"
    fi
    echo "" >> "$index_file"
    
    # List context files that will be generated
    echo "## Context Files" >> "$index_file"
    for folder in "${FOLDERS_TO_PROCESS[@]}"; do
        echo "- ${folder}.txt - Contents of $folder/ directory" >> "$index_file"
    done
    echo "" >> "$index_file"
    
    # Process each configured folder
    local total_files=0
    local total_size=0
    
    for folder in "${FOLDERS_TO_PROCESS[@]}"; do
        process_folder "$folder"
        
        # Update totals if file was created
        local output_file="$CONTEXT_DIR/${folder}.txt"
        if [[ -f "$output_file" ]]; then
            local file_count=$(tail -1 "$output_file" | grep -o '[0-9]*' | head -1)
            local size=$(wc -c < "$output_file")
            total_files=$((total_files + file_count))
            total_size=$((total_size + size))
        fi
    done
    
    # Update index with summary
    echo "## Summary" >> "$index_file"
    echo "- Total files processed: $total_files" >> "$index_file"
    echo "- Total context size: $(( total_size / 1024 ))KB" >> "$index_file"
    echo "- Folders processed: ${FOLDERS_TO_PROCESS[*]}" >> "$index_file"
    
    echo ""
    echo "=================================="
    echo "Context generation complete!"
    echo "Output directory: $CONTEXT_DIR"
    echo "Total: $total_files files, $(( total_size / 1024 ))KB"
    echo ""
    echo "Generated files:"
    ls -la "$CONTEXT_DIR"
    echo ""
    echo "To add services to your system hosts file:"
    echo "   sudo cat $CONTEXT_DIR/hosts.txt >> /etc/hosts         # Linux/Mac"
    echo "   cat $CONTEXT_DIR/hosts.txt >> C:\\Windows\\System32\\drivers\\etc\\hosts  # Windows"
}

# Show usage if help requested
if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    echo "Smart Context Sync"
    echo "=================="
    echo ""
    echo "Generates organized context files from specified project folders."
    echo ""
    echo "Usage: $0"
    echo ""
    echo "Configuration (edit script to modify):"
    echo "- FOLDERS_TO_PROCESS: Array of folders to process"
    echo "- CONTEXT_DIR: Output directory for context files"
    echo ""
    echo "Current folders configured:"
    for folder in "${FOLDERS_TO_PROCESS[@]}"; do
        echo "  - $folder"
    done
    echo ""
    echo "Output files:"
    echo "  - ./context/index.txt - Project overview and git status"
    echo "  - ./context/{folder}.txt - Contents of each folder"
    echo "  - ./context/hosts.txt - Dynamic hosts file from compose files"
    echo ""
    exit 0
fi

# Run main function
main "$@"```

### scripts/install.sh
```
#!/bin/zsh

# =============================================================================
# MICROSERVICES INSTALLATION SCRIPT
# =============================================================================
# Streamlined installation script that leverages other modular scripts
# for a clean, maintainable setup process

# Source the central configuration
. "$(dirname "$0")/config.sh"

# =============================================================================
# SCRIPT OPTIONS & DEFAULTS
# =============================================================================

# Default values
opt_use_sudo="$DEFAULT_SUDO"
opt_show_errors=false
opt_skip_confirmation=false
opt_skip_db_setup=false
opt_skip_ssl=false
opt_skip_trust=false
opt_quick_mode=false
opt_categories_only=""

# =============================================================================
# USAGE & HELP
# =============================================================================

show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

DESCRIPTION:
    Complete installation script for the microservices architecture.
    Installs services in proper dependency order with optional configurations.

OPTIONS:
    -s, --sudo              Use sudo for container commands
    -e, --errors            Show detailed error messages
    -y, --yes               Skip confirmation prompts
    -q, --quick             Quick mode: skip SSL and trust setup
    -d, --skip-db           Skip database initialization
    --skip-ssl              Skip SSL certificate generation
    --skip-trust            Skip SSL certificate trust installation
    -c, --categories LIST   Install only specific categories (comma-separated)
    -h, --help              Show this help message

CATEGORIES:
    database, db-tools, backend, analytics, ai-services, mail, project, erp, proxy

EXAMPLES:
    $0                                    # Full installation with prompts
    $0 -y                                # Full installation, no prompts
    $0 -q                                # Quick installation (no SSL setup)
    $0 -c database,backend               # Install only database and backend services
    $0 -s -e -y                          # Use sudo, show errors, skip prompts
    $0 --categories proxy --skip-db      # Install only proxy, skip database setup

NOTES:
    - Services are installed in dependency order automatically
    - Database services are always installed first when included
    - SSL certificates work across all operating systems
    - Use --quick mode for development-only setups
EOF
}

# =============================================================================
# ARGUMENT PARSING
# =============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--sudo)
                opt_use_sudo=true
                shift
                ;;
            -e|--errors)
                opt_show_errors=true
                shift
                ;;
            -y|--yes)
                opt_skip_confirmation=true
                shift
                ;;
            -q|--quick)
                opt_quick_mode=true
                opt_skip_ssl=true
                opt_skip_trust=true
                shift
                ;;
            -d|--skip-db)
                opt_skip_db_setup=true
                shift
                ;;
            --skip-ssl)
                opt_skip_ssl=true
                shift
                ;;
            --skip-trust)
                opt_skip_trust=true
                shift
                ;;
            -c|--categories)
                if [[ -n "$2" && "$2" != -* ]]; then
                    opt_categories_only="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a value"
                fi
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                handle_error "Unknown option: $1. Use -h for help."
                ;;
        esac
    done
}

# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

validate_environment() {
    print_status "step" "Validating environment..."
    
    # Check for container runtime
    if ! command -v "$CONTAINER_RUNTIME" >/dev/null 2>&1; then
        handle_error "$CONTAINER_RUNTIME is not installed or not in PATH"
    fi
    
    # Check compose functionality
    if ! eval "$CONTAINER_CMD --version $ERROR_REDIRECT"; then
        handle_error "Container runtime is not working properly"
    fi
    
    # Check project structure
    if [[ ! -d "$COMPOSE_DIR" ]]; then
        handle_error "Compose directory not found: $COMPOSE_DIR"
    fi
    
    # Check for .env file
    if [[ ! -f "$PROJECT_ROOT/.env" ]]; then
        if [[ -f "$PROJECT_ROOT/.env-sample" ]]; then
            print_status "warning" "No .env file found, copying from .env-sample"
            cp "$PROJECT_ROOT/.env-sample" "$PROJECT_ROOT/.env"
            print_status "success" ".env file created from sample"
        else
            handle_error "No .env file found and no .env-sample available"
        fi
    fi
    
    print_status "success" "Environment validation passed"
}

validate_categories() {
    if [[ -n "$opt_categories_only" ]]; then
        local -a requested_categories
        requested_categories=(${(s:,:)opt_categories_only})
        
        for category in "${requested_categories[@]}"; do
            if [[ -z "${SERVICE_CATEGORIES[$category]}" ]]; then
                print_status "error" "Invalid category: $category"
                print_status "info" "Available categories: ${(k)SERVICE_CATEGORIES}"
                exit 1
            fi
        done
        
        print_status "info" "Will install categories: ${requested_categories[*]}"
    fi
}

# =============================================================================
# INSTALLATION FUNCTIONS
# =============================================================================

show_installation_summary() {
    print_status "info" "Installation Summary:"
    echo "  Container Runtime: $CONTAINER_RUNTIME"
    echo "  Use Sudo: $opt_use_sudo"
    echo "  Show Errors: $opt_show_errors"
    echo "  Skip DB Setup: $opt_skip_db_setup"
    echo "  Skip SSL Setup: $opt_skip_ssl"
    echo "  Skip Trust Setup: $opt_skip_trust"
    
    if [[ -n "$opt_categories_only" ]]; then
        echo "  Categories: $opt_categories_only"
    else
        echo "  Categories: All (${SERVICE_STARTUP_ORDER[*]})"
    fi
    
    echo ""
}

confirm_installation() {
    if [[ "$opt_skip_confirmation" == "false" ]]; then
        echo "This script will install and configure the microservices environment."
        echo "The installation will create containers, networks, and SSL certificates."
        echo ""
        read "response?Do you want to continue? (y/N): "
        
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            print_status "info" "Installation cancelled by user"
            exit 0
        fi
    fi
}

install_services() {
    local -a categories_to_install
    
    if [[ -n "$opt_categories_only" ]]; then
        categories_to_install=(${(s:,:)opt_categories_only})
    else
        categories_to_install=("${SERVICE_STARTUP_ORDER[@]}")
    fi
    
    print_status "step" "Starting service installation..."
    
    # Ensure network exists first
    ensure_network_exists
    
    # Install each category in order
    for category in "${categories_to_install[@]}"; do
        print_status "step" "Installing $category services..."
        start_service_category "$category"
        
        # Special handling for database category
        if [[ "$category" == "database" ]]; then
            # Wait for MongoDB specifically if it's being installed
            if [[ -n "${SERVICE_CATEGORIES[database]}" ]] && [[ "${SERVICE_CATEGORIES[database]}" == *"mongodb.yml"* ]]; then
                wait_for_mongodb
            fi
            
            # Wait a bit for other databases to initialize
            print_status "step" "Waiting for databases to initialize..."
            sleep 10
            
            # Run database setup if not skipped
            if [[ "$opt_skip_db_setup" == "false" ]]; then
                run_database_setup
            fi
        fi
        
        # Brief pause between categories
        sleep 2
    done
    
    print_status "success" "Service installation completed!"
}

run_database_setup() {
    print_status "step" "Running database setup..."
    
    local setup_args=()
    [[ "$opt_use_sudo" == "true" ]] && setup_args+=("-s")
    [[ "$opt_show_errors" == "true" ]] && setup_args+=("-e")
    setup_args+=("-m" "-p")  # Setup both MariaDB and PostgreSQL
    
    if "$SCRIPT_DIR/setup-databases.sh" "${setup_args[@]}"; then
        print_status "success" "Database setup completed"
    else
        print_status "warning" "Database setup encountered issues but continuing..."
    fi
}

setup_ssl_certificates() {
    if [[ "$opt_skip_ssl" == "true" ]]; then
        print_status "info" "Skipping SSL certificate generation"
        return 0
    fi
    
    print_status "step" "Setting up SSL certificates..."
    
    local ssl_args=()
    [[ "$opt_use_sudo" == "true" ]] && ssl_args+=("-s")
    [[ "$opt_show_errors" == "true" ]] && ssl_args+=("-e")
    
    if "$SCRIPT_DIR/setup-ssl.sh" "${ssl_args[@]}"; then
        print_status "success" "SSL certificates generated successfully"
    else
        print_status "warning" "SSL setup encountered issues but continuing..."
    fi
}

install_ssl_trust() {
    if [[ "$opt_skip_trust" == "true" ]]; then
        print_status "info" "Skipping SSL certificate trust installation"
        return 0
    fi
    
    print_status "step" "Installing SSL certificates for host system..."
    
    local trust_args=()
    [[ "$opt_use_sudo" == "true" ]] && trust_args+=("-s")
    [[ "$opt_show_errors" == "true" ]] && trust_args+=("-e")
    
    # Add Windows certificate copying if on WSL
    [[ "$OS_TYPE" == "wsl" ]] && trust_args+=("-w")
    
    if "$SCRIPT_DIR/trust-host.sh" "${trust_args[@]}"; then
        print_status "success" "SSL certificates trusted by host system"
    else
        print_status "warning" "SSL trust setup encountered issues but continuing..."
    fi
}

show_completion_message() {
    echo ""
    echo "========================================================"
    print_status "success" "Installation completed successfully!"
    echo "========================================================"
    echo ""
    
    if [[ "$opt_quick_mode" == "true" ]]; then
        echo "Quick mode installation completed. Services are accessible via localhost ports."
        echo "Run the following for SSL setup later:"
        echo "  $SCRIPT_DIR/setup-ssl.sh && $SCRIPT_DIR/trust-host.sh"
        echo ""
    fi
    
    echo "You can now access your services:"
    echo ""
    echo "üåê Web Interfaces:"
    echo "  - Nginx Proxy Manager: https://nginx.test (or http://localhost:81)"
    echo "  - Grafana Dashboard: https://grafana.test (or http://localhost:9001)"
    echo "  - Metabase Analytics: https://metabase.test (or http://localhost:8085)"
    echo ""
    echo "üóÑÔ∏è  Database Tools:"
    echo "  - Adminer: https://adminer.test (or http://localhost:8082)"
    echo "  - phpMyAdmin: https://phpmyadmin.test (or http://localhost:8083)"
    echo "  - Mongo Express: https://mongodb.test (or http://localhost:8084)"
    echo ""
    echo "ü§ñ AI & Analytics:"
    echo "  - n8n Workflows: https://n8n.test (or http://localhost:9100)"
    echo "  - Langflow: https://langflow.test (or http://localhost:9110)"
    echo "  - Kibana: https://kibana.test (or http://localhost:9120)"
    echo ""
    echo "üìä Business Applications:"
    echo "  - Matomo Analytics: https://matomo.test (or http://localhost:9010)"
    echo ""
    echo "üíª Development Tools:"
    echo "  - Mailpit: https://mailpit.test (or http://localhost:9200)"
    echo "  - Gitea: https://gitea.test (or http://localhost:9210)"
    echo ""
    echo "üìã Management Commands:"
    echo "  - View all services: $SCRIPT_DIR/show-services.sh"
    echo "  - Stop all services: $SCRIPT_DIR/stop-services.sh"
    echo "  - Start services: $SCRIPT_DIR/start-services.sh"
    echo ""
    echo "üîß Default Credentials:"
    echo "  - Username: admin"
    echo "  - Password: 123456"
    echo "  - Email: admin@site.test"
    echo ""
    echo "========================================================"
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

main() {
    # Parse command line arguments
    parse_arguments "$@"
    
    # Set up command context based on options
    setup_command_context "$opt_use_sudo" "$opt_show_errors"
    
    # Validate environment and arguments
    validate_environment
    validate_categories
    
    # Show summary and get confirmation
    show_installation_summary
    confirm_installation
    
    # Start installation process
    print_status "step" "Starting microservices installation..."
    
    # Install services
    install_services
    
    # Setup SSL if not skipped
    setup_ssl_certificates
    
    # Trust SSL certificates if not skipped
    install_ssl_trust
    
    # Show completion message
    show_completion_message
    
    print_status "success" "Installation process completed!"
}

# =============================================================================
# SCRIPT ENTRY POINT
# =============================================================================

# Only run main if script is executed directly (not sourced)
if [[ "${(%):-%x}" == "${0}" ]]; then
    main "$@"
fi```

### scripts/laravel/setup-laravel.sh
```
#!/bin/zsh

# Simple Laravel setup script
# Usage: ./setup-laravel.sh <git-url> [project-name]

if [[ -z "$1" ]]; then
    echo "Usage: $0 <git-url> [project-name]"
    exit 1
fi

GIT_URL="$1"
PROJECT_NAME="${2:-$(basename "$1" .git)}"

echo "üöÄ Setting up Laravel project: $PROJECT_NAME"

# Clone the project
echo "üì• Cloning project..."
cd ./apps
git clone "$GIT_URL" "$PROJECT_NAME"
cd "$PROJECT_NAME"

# Copy .env file
echo "üìù Setting up .env file..."
if [[ -f ".env.example" ]]; then
    cp .env.example .env
elif [[ -f ".env.sample" ]]; then
    cp .env.sample .env
else
    echo "‚ö†Ô∏è  No .env template found"
fi

# Execute remaining commands inside the PHP container
sudo podman exec -w /var/www/html/$PROJECT_NAME php zsh -c "
# Fix permissions
echo 'üîê Setting permissions...'
chmod -R 775 /var/www/html/$PROJECT_NAME
chown -R www-data:www-data .

# Install dependencies
echo 'üì¶ Installing Composer dependencies...'
composer install

echo 'üì¶ Installing NPM dependencies...'
npm install

# Generate key
echo 'üîë Generating app key...'
php artisan key:generate

# Build assets
echo 'üèóÔ∏è  Building assets...'
npm run build

# Run migrations
echo 'üóÑÔ∏è  Running migrations...'
php artisan migrate
"

echo "‚úÖ Done! Project available at: https://${PROJECT_NAME}.test"```

### scripts/runtime-switcher.sh
```
#!/bin/bash

# =============================================================================
# CONTAINER RUNTIME SWITCHER
# =============================================================================
# Switches between Podman and Docker as drop-in replacements

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
CONFIG_FILE="$SCRIPT_DIR/config.sh"

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

print_status() {
    local level="$1"
    local message="$2"
    
    case "$level" in
        "info")
            echo -e "${BLUE}‚ÑπÔ∏è  $message${NC}"
            ;;
        "success")
            echo -e "${GREEN}‚úÖ $message${NC}"
            ;;
        "warning")
            echo -e "${YELLOW}‚ö†Ô∏è  $message${NC}"
            ;;
        "error")
            echo -e "${RED}‚ùå $message${NC}"
            ;;
    esac
}

get_current_runtime() {
    # Check Docker first (more reliable detection)
    if command -v docker >/dev/null 2>&1; then
        # Check if Docker daemon is running
        if sudo systemctl is-active docker >/dev/null 2>&1 || pgrep -f "dockerd" >/dev/null 2>&1; then
            # Try a simple docker command to confirm it's working
            if sudo docker info >/dev/null 2>&1; then
                echo "docker"
                return
            fi
        fi
    fi
    
    # Check Podman
    if command -v podman >/dev/null 2>&1; then
        # Check if podman socket is active or podman is responsive
        if systemctl --user is-active podman.socket >/dev/null 2>&1 || podman info >/dev/null 2>&1; then
            echo "podman"
            return
        fi
    fi
    
    echo "none"
}

stop_all_services() {
    print_status "info" "Stopping all microservices before runtime switch..."
    
    # Use the existing stop-services.sh script if available
    if [[ -f "$SCRIPT_DIR/stop-services.sh" ]]; then
        "$SCRIPT_DIR/stop-services.sh" --force --timeout 10 2>/dev/null || true
    else
        print_status "warning" "stop-services.sh not found, attempting manual cleanup..."
        cleanup_runtime_containers
    fi
}

cleanup_runtime_containers() {
    # Clean up both runtimes to ensure clean state
    cleanup_runtime "podman"
    cleanup_runtime "docker"
}

cleanup_runtime() {
    local runtime="$1"
    print_status "info" "Cleaning up $runtime resources..."
    
    if [[ "$runtime" == "podman" ]]; then
        # Stop all podman containers
        local containers=$(podman ps -q 2>/dev/null || true)
        if [[ -n "$containers" ]]; then
            podman stop $containers 2>/dev/null || true
            podman rm $containers 2>/dev/null || true
        fi
        
        # Remove networks
        podman network rm microservices-net 2>/dev/null || true
        
    elif [[ "$runtime" == "docker" ]]; then
        # Stop all docker containers  
        local containers=$(sudo docker ps -q 2>/dev/null || true)
        if [[ -n "$containers" ]]; then
            sudo docker stop $containers 2>/dev/null || true
            sudo docker rm $containers 2>/dev/null || true
        fi
        
        # Remove networks
        sudo docker network rm microservices-net 2>/dev/null || true
    fi
}

switch_to_docker() {
    print_status "info" "Switching to Docker..."
    
    # Stop podman services
    if command -v podman >/dev/null 2>&1; then
        systemctl --user stop podman.socket 2>/dev/null || true
        pkill -f podman 2>/dev/null || true
        sleep 2  # Give it time to stop
    fi
    
    # Start Docker
    if command -v docker >/dev/null 2>&1; then
        sudo systemctl start docker
        sleep 3  # Give Docker time to start
        
        # Verify Docker is working
        if sudo docker info >/dev/null 2>&1; then
            # Update config.sh
            if [[ -f "$CONFIG_FILE" ]]; then
                sed -i 's/export CONTAINER_RUNTIME="podman"/export CONTAINER_RUNTIME="docker"/' "$CONFIG_FILE"
                sed -i 's/export USE_PODMAN=true/export USE_PODMAN=false/' "$CONFIG_FILE"
            fi
            
            print_status "success" "Docker is now active"
            return 0
        else
            print_status "error" "Docker failed to start properly"
            return 1
        fi
    else
        print_status "error" "Docker not found. Please install Docker first."
        return 1
    fi
}

switch_to_podman() {
    print_status "info" "Switching to Podman..."
    
    # Stop Docker
    if command -v docker >/dev/null 2>&1; then
        sudo systemctl stop docker 2>/dev/null || true
        pkill -f dockerd 2>/dev/null || true
        sleep 2  # Give it time to stop
    fi
    
    # Start Podman
    if command -v podman >/dev/null 2>&1; then
        systemctl --user start podman.socket 2>/dev/null || true
        sleep 2  # Give Podman time to start
        
        # Verify Podman is working
        if podman info >/dev/null 2>&1; then
            # Update config.sh
            if [[ -f "$CONFIG_FILE" ]]; then
                sed -i 's/export CONTAINER_RUNTIME="docker"/export CONTAINER_RUNTIME="podman"/' "$CONFIG_FILE"
                sed -i 's/export USE_PODMAN=false/export USE_PODMAN=true/' "$CONFIG_FILE"
            fi
            
            print_status "success" "Podman is now active"
            return 0
        else
            print_status "error" "Podman failed to start properly"
            return 1
        fi
    else
        print_status "error" "Podman not found. Please install Podman first."
        return 1
    fi
}

show_status() {
    local current=$(get_current_runtime)
    
    echo -e "${BLUE}=== Container Runtime Status ===${NC}"
    echo ""
    
    case "$current" in
        "podman")
            print_status "success" "Currently using: Podman"
            ;;
        "docker")
            print_status "success" "Currently using: Docker"
            ;;
        "none")
            print_status "warning" "No active container runtime detected"
            ;;
    esac
    
    echo ""
    echo "Available runtimes:"
    if command -v podman >/dev/null 2>&1; then
        echo -e "  ${GREEN}‚úì${NC} Podman installed"
    else
        echo -e "  ${RED}‚úó${NC} Podman not installed"
    fi
    
    if command -v docker >/dev/null 2>&1; then
        echo -e "  ${GREEN}‚úì${NC} Docker installed"
    else
        echo -e "  ${RED}‚úó${NC} Docker not installed"
    fi
    
    echo ""
    echo "Container Status:"
    
    # Show Podman containers
    if command -v podman >/dev/null 2>&1; then
        local podman_count=$(podman ps -q 2>/dev/null | wc -l || echo "0")
        if [[ "$podman_count" -gt 0 ]]; then
            echo -e "  ${YELLOW}‚ö†Ô∏è${NC}  $podman_count containers running in Podman"
        else
            echo -e "  ${GREEN}‚úì${NC} No containers running in Podman"
        fi
    fi
    
    # Show Docker containers  
    if command -v docker >/dev/null 2>&1; then
        local docker_count=$(sudo docker ps -q 2>/dev/null | wc -l || echo "0")
        if [[ "$docker_count" -gt 0 ]]; then
            echo -e "  ${YELLOW}‚ö†Ô∏è${NC}  $docker_count containers running in Docker"
        else
            echo -e "  ${GREEN}‚úì${NC} No containers running in Docker"
        fi
    fi
    
    echo ""
}

usage() {
    echo "Usage: $0 [COMMAND]"
    echo ""
    echo "Commands:"
    echo "  docker     Switch to Docker"
    echo "  podman     Switch to Podman"
    echo "  status     Show current runtime status"
    echo "  help       Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 docker     # Switch to Docker"
    echo "  $0 podman     # Switch to Podman"
    echo "  $0 status     # Show current status"
    echo ""
    echo "Notes:"
    echo "  - All running containers will be stopped during the switch"
    echo "  - The config.sh file will be updated automatically"
    echo "  - Restart your services after switching runtimes"
}

# Main execution
case "${1:-status}" in
    "docker")
        stop_all_services
        switch_to_docker
        echo ""
        print_status "info" "To start services with Docker, run: ./scripts/start-services.sh"
        ;;
    "podman")
        stop_all_services
        switch_to_podman
        echo ""
        print_status "info" "To start services with Podman, run: ./scripts/start-services.sh"
        ;;
    "status")
        show_status
        ;;
    "help"|"-h"|"--help")
        usage
        ;;
    *)
        print_status "error" "Unknown command: $1"
        usage
        exit 1
        ;;
esac```

### scripts/setup-databases.sh
```
#!/bin/zsh

# =============================================================================
# DATABASE SETUP SCRIPT
# =============================================================================
# Initializes databases and creates required schemas/users for all services
# Supports MariaDB, MySQL, PostgreSQL, and MongoDB

# Source the central configuration
. "$(dirname "$0")/config.sh"

# =============================================================================
# SCRIPT OPTIONS & DEFAULTS
# =============================================================================

# Default values
opt_use_sudo="$DEFAULT_SUDO"
opt_show_errors=false
opt_setup_mariadb=false
opt_setup_mysql=false
opt_setup_postgres=false
opt_setup_mongodb=false
opt_setup_all=false
opt_create_test_data=false
opt_timeout=120

# =============================================================================
# USAGE & HELP
# =============================================================================

show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

DESCRIPTION:
    Initializes databases and creates required schemas, users, and configurations
    for all microservices. Supports MariaDB, MySQL, PostgreSQL, and MongoDB.

OPTIONS:
    -s, --sudo              Use sudo for container commands
    -e, --errors            Show detailed error messages
    -m, --mariadb           Setup MariaDB databases
    -y, --mysql             Setup MySQL databases  
    -p, --postgres          Setup PostgreSQL databases
    -g, --mongodb           Setup MongoDB databases
    -a, --all               Setup all available databases
    -t, --test-data         Create test data in databases
    -T, --timeout SECONDS   Database connection timeout (default: 120)
    -h, --help              Show this help message

DATABASES CREATED:
    MariaDB/MySQL:
        - npm (Nginx Proxy Manager)
        - matomo (Analytics)
        
    PostgreSQL:
        - metabase (Analytics)
        - nocodb (No-code database)
        
    MongoDB:
        - admin (Administrative)
        - langflow (AI workflows)
        - n8n (Automation)

EXAMPLES:
    $0 -a                           # Setup all databases
    $0 -m -p                        # Setup MariaDB and PostgreSQL only
    $0 -s -e -a                     # Use sudo, show errors, setup all
    $0 --postgres --test-data       # Setup PostgreSQL with test data
    $0 --all --timeout 180          # Setup all with 3-minute timeout

NOTES:
    - Databases must be running before executing this script
    - Script will wait for database containers to be ready
    - Test data is useful for development environments
    - Use appropriate timeout for slower systems
EOF
}

# =============================================================================
# ARGUMENT PARSING
# =============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--sudo)
                opt_use_sudo=true
                shift
                ;;
            -e|--errors)
                opt_show_errors=true
                shift
                ;;
            -m|--mariadb)
                opt_setup_mariadb=true
                shift
                ;;
            -y|--mysql)
                opt_setup_mysql=true
                shift
                ;;
            -p|--postgres)
                opt_setup_postgres=true
                shift
                ;;
            -g|--mongodb)
                opt_setup_mongodb=true
                shift
                ;;
            -a|--all)
                opt_setup_all=true
                opt_setup_mariadb=true
                opt_setup_mysql=true
                opt_setup_postgres=true
                opt_setup_mongodb=true
                shift
                ;;
            -t|--test-data)
                opt_create_test_data=true
                shift
                ;;
            -T|--timeout)
                if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                    opt_timeout="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a numeric value"
                fi
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                handle_error "Unknown option: $1. Use -h for help."
                ;;
        esac
    done
    
    # If no specific databases selected, show usage
    if [[ "$opt_setup_all" == "false" && 
          "$opt_setup_mariadb" == "false" && 
          "$opt_setup_mysql" == "false" && 
          "$opt_setup_postgres" == "false" && 
          "$opt_setup_mongodb" == "false" ]]; then
        print_status "error" "No databases specified for setup"
        show_usage
        exit 1
    fi
}

# =============================================================================
# DATABASE VALIDATION FUNCTIONS
# =============================================================================

wait_for_database() {
    local db_type="$1"
    local container_name="$2"
    local timeout="$opt_timeout"
    local counter=0
    
    print_status "step" "Waiting for $db_type ($container_name) to be ready..."
    
    while [[ $counter -lt $timeout ]]; do
        case "$db_type" in
            "mariadb"|"mysql")
                # Try direct connection with root user instead of healthcheck
                if eval "$CONTAINER_CMD exec $container_name mariadb -u root -p\$MYSQL_ROOT_PASSWORD -e 'SELECT 1;' >/dev/null 2>&1"; then
                    print_status "success" "$db_type is ready!"
                    return 0
                fi
                
                # Fallback: Check if mysqladmin ping works
                if eval "$CONTAINER_CMD exec $container_name mysqladmin ping -h localhost -u root -p\$MYSQL_ROOT_PASSWORD >/dev/null 2>&1"; then
                    print_status "success" "$db_type is ready!"
                    return 0
                fi
                ;;
            "postgres")
                # More robust postgres check
                if eval "$CONTAINER_CMD exec $container_name pg_isready -U postgres >/dev/null 2>&1"; then
                    # Also verify we can actually connect
                    if eval "$CONTAINER_CMD exec $container_name psql -U postgres -c 'SELECT 1;' >/dev/null 2>&1"; then
                        print_status "success" "$db_type is ready!"
                        return 0
                    fi
                fi
                ;;
            "mongodb")
                if eval "$CONTAINER_CMD exec $container_name mongosh --quiet --eval 'db.adminCommand(\"ping\")' >/dev/null 2>&1"; then
                    print_status "success" "$db_type is ready!"
                    return 0
                fi
                ;;
        esac
        
        # Check if container is still running
        if ! eval "$CONTAINER_CMD ps --format '{{.Names}}' | grep -q '^$container_name$' 2>/dev/null"; then
            handle_error "$container_name container is not running"
        fi
        
        print_status "info" "$db_type not ready yet... ($counter/$timeout seconds)"
        sleep 3  # Increased sleep time
        counter=$((counter + 3))
    done
    
    handle_error "$db_type connection timeout after $timeout seconds"
}

validate_database_containers() {
    print_status "step" "Validating database containers..."
    
    local -a required_containers=()
    
    [[ "$opt_setup_mariadb" == "true" ]] && required_containers+="mariadb"
    [[ "$opt_setup_mysql" == "true" ]] && required_containers+="mysql"
    [[ "$opt_setup_postgres" == "true" ]] && required_containers+="postgres"
    [[ "$opt_setup_mongodb" == "true" ]] && required_containers+="mongodb"
    
    for container in "${required_containers[@]}"; do
        if ! eval "$CONTAINER_CMD ps --format '{{.Names}}' | grep -q '^$container$' $ERROR_REDIRECT"; then
            handle_error "$container container is not running. Please start database services first."
        fi
    done
    
    print_status "success" "All required database containers are running"
}

# =============================================================================
# DATABASE SETUP FUNCTIONS
# =============================================================================

setup_mariadb() {
    print_status "step" "Setting up MariaDB databases and users..."
    
    wait_for_database "mariadb" "mariadb"
    
    # Enhanced MariaDB setup with better conflict handling
    local mariadb_setup_sql="
-- Create databases with IF NOT EXISTS to avoid conflicts
CREATE DATABASE IF NOT EXISTS npm CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE DATABASE IF NOT EXISTS matomo CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE DATABASE IF NOT EXISTS microservices CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- Drop and recreate users to ensure clean state
DROP USER IF EXISTS 'npm_user'@'%';
DROP USER IF EXISTS 'matomo_user'@'%';
DROP USER IF EXISTS 'app_user'@'%';

-- Create users
CREATE USER 'npm_user'@'%' IDENTIFIED BY '${ADMIN_PASSWORD}';
CREATE USER 'matomo_user'@'%' IDENTIFIED BY '${ADMIN_PASSWORD}';
CREATE USER 'app_user'@'%' IDENTIFIED BY '${ADMIN_PASSWORD}';

-- Grant privileges
GRANT ALL PRIVILEGES ON npm.* TO 'npm_user'@'%';
GRANT ALL PRIVILEGES ON matomo.* TO 'matomo_user'@'%';
GRANT ALL PRIVILEGES ON microservices.* TO 'app_user'@'%';

FLUSH PRIVILEGES;
"
    
    # Use mariadb command with better error handling
    if eval "$CONTAINER_CMD exec -i mariadb mariadb -u root -p\$MYSQL_ROOT_PASSWORD 2>/dev/null << 'EOF'
$mariadb_setup_sql
EOF"; then
        print_status "success" "MariaDB databases and users created successfully"
        
        # Create test data if requested
        if [[ "$opt_create_test_data" == "true" ]]; then
            create_mariadb_test_data
        fi
    else
        print_status "error" "Failed to setup MariaDB databases"
        print_status "info" "Attempting to show MariaDB error details..."
        # Show what went wrong
        eval "$CONTAINER_CMD exec mariadb mariadb -u root -p\$MYSQL_ROOT_PASSWORD -e 'SHOW DATABASES;' 2>&1" || true
        return 1
    fi
}

setup_mysql() {
    print_status "step" "Setting up MySQL databases and users..."
    
    wait_for_database "mysql" "mysql"
    
    # Create databases and users for MySQL
    local mysql_setup_sql="
-- WordPress Database
CREATE DATABASE IF NOT EXISTS wordpress CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER IF NOT EXISTS 'wordpress_user'@'%' IDENTIFIED BY '${ADMIN_PASSWORD}';
GRANT ALL PRIVILEGES ON wordpress.* TO 'wordpress_user'@'%';

-- General MySQL application database
CREATE DATABASE IF NOT EXISTS mysql_apps CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER IF NOT EXISTS 'mysql_app_user'@'%' IDENTIFIED BY '${ADMIN_PASSWORD}';
GRANT ALL PRIVILEGES ON mysql_apps.* TO 'mysql_app_user'@'%';

-- Laravel/PHP application database
CREATE DATABASE IF NOT EXISTS laravel CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER IF NOT EXISTS 'laravel_user'@'%' IDENTIFIED BY '${ADMIN_PASSWORD}';
GRANT ALL PRIVILEGES ON laravel.* TO 'laravel_user'@'%';

FLUSH PRIVILEGES;
"
    
    if eval "$CONTAINER_CMD exec -i mysql mysql -u root -p\$MYSQL_ROOT_PASSWORD << 'EOF'
$mysql_setup_sql
EOF" $ERROR_REDIRECT; then
        print_status "success" "MySQL databases and users created successfully"
        
        # Create test data if requested
        if [[ "$opt_create_test_data" == "true" ]]; then
            create_mysql_test_data
        fi
    else
        handle_error "Failed to setup MySQL databases"
    fi
}

setup_postgres() {
    print_status "step" "Setting up PostgreSQL databases and users..."
    
    wait_for_database "postgres" "postgres"
    
    # Enhanced PostgreSQL setup with conflict resolution
    local postgres_setup_sql="
-- Terminate existing connections to databases we might need to recreate
SELECT pg_terminate_backend(pid) FROM pg_stat_activity 
WHERE datname IN ('metabase', 'nocodb') AND pid <> pg_backend_pid();

-- Wait a moment for connections to close
SELECT pg_sleep(2);

-- Drop existing databases if they exist (CASCADE to handle dependencies)
DROP DATABASE IF EXISTS metabase;
DROP DATABASE IF EXISTS nocodb; 

-- Drop existing users if they exist
DROP USER IF EXISTS metabase_user;
DROP USER IF EXISTS nocodb_user;

-- Create users first
CREATE USER metabase_user WITH PASSWORD '${ADMIN_PASSWORD}';
CREATE USER nocodb_user WITH PASSWORD '${ADMIN_PASSWORD}';

-- Create databases
CREATE DATABASE metabase OWNER metabase_user;
CREATE DATABASE nocodb OWNER nocodb_user;

-- Grant additional privileges
GRANT ALL PRIVILEGES ON DATABASE metabase TO metabase_user;
GRANT ALL PRIVILEGES ON DATABASE nocodb TO nocodb_user;
"
    
    if eval "$CONTAINER_CMD exec -i postgres psql -U postgres 2>/dev/null << 'EOF'
$postgres_setup_sql
EOF"; then
        print_status "success" "PostgreSQL databases and users created successfully"
        
        # Create test data if requested
        if [[ "$opt_create_test_data" == "true" ]]; then
            create_postgres_test_data
        fi
    else
        print_status "error" "Failed to setup PostgreSQL databases"
        print_status "info" "Attempting to show PostgreSQL error details..."
        # Show current state
        eval "$CONTAINER_CMD exec postgres psql -U postgres -c '\l' 2>&1" || true
        return 1
    fi
}

setup_mongodb() {
    print_status "step" "Setting up MongoDB databases and collections..."
    
    wait_for_database "mongodb" "mongodb"
    
    # Enhanced MongoDB setup
    local mongodb_setup_js="
// Switch to admin database for user management
use admin;

// Remove existing users if they exist
try { db.dropUser('langflow_user'); } catch(e) { print('langflow_user did not exist'); }
try { db.dropUser('n8n_user'); } catch(e) { print('n8n_user did not exist'); }
try { db.dropUser('app_user'); } catch(e) { print('app_user did not exist'); }

// Create application-specific users
db.createUser({
    user: 'langflow_user',
    pwd: '${ADMIN_PASSWORD}',
    roles: [
        { role: 'readWrite', db: 'langflow' },
        { role: 'dbAdmin', db: 'langflow' }
    ]
});

db.createUser({
    user: 'n8n_user', 
    pwd: '${ADMIN_PASSWORD}',
    roles: [
        { role: 'readWrite', db: 'n8n' },
        { role: 'dbAdmin', db: 'n8n' }
    ]
});

db.createUser({
    user: 'app_user',
    pwd: '${ADMIN_PASSWORD}',
    roles: [
        { role: 'readWrite', db: 'microservices' },
        { role: 'dbAdmin', db: 'microservices' }
    ]
});

// Create and initialize databases
use langflow;
db.flows.deleteMany({});  // Clear existing data
db.flows.insertOne({ name: 'sample_flow', created_at: new Date() });

use n8n;
db.workflows.deleteMany({});  // Clear existing data
db.workflows.insertOne({ name: 'sample_workflow', created_at: new Date() });

use microservices;
db.config.deleteMany({});  // Clear existing data
db.config.insertOne({ service: 'mongodb', initialized: true, created_at: new Date() });

print('MongoDB databases and users created successfully');
"
    
    if eval "$CONTAINER_CMD exec -i mongodb mongosh --quiet 2>/dev/null << 'EOF'
$mongodb_setup_js
EOF"; then
        print_status "success" "MongoDB databases and users created successfully"
        
        # Create test data if requested
        if [[ "$opt_create_test_data" == "true" ]]; then
            create_mongodb_test_data
        fi
    else
        print_status "error" "Failed to setup MongoDB databases"
        print_status "info" "Attempting to show MongoDB error details..."
        # Show current state
        eval "$CONTAINER_CMD exec mongodb mongosh --eval 'show dbs' 2>&1" || true
        return 1
    fi
}

# =============================================================================
# TEST DATA CREATION FUNCTIONS
# =============================================================================

create_mariadb_test_data() {
    print_status "step" "Creating MariaDB test data..."
    
    local test_data_sql="
USE microservices;

CREATE TABLE IF NOT EXISTS users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO users (username, email) VALUES 
('admin', 'admin@site.test'),
('testuser', 'test@site.test'),
('developer', 'dev@site.test')
ON DUPLICATE KEY UPDATE username=VALUES(username);

CREATE TABLE IF NOT EXISTS services (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    status ENUM('running', 'stopped', 'error') DEFAULT 'running',
    port INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO services (name, status, port) VALUES
('nginx', 'running', 80),
('postgres', 'running', 5432),
('redis', 'running', 6379)
ON DUPLICATE KEY UPDATE name=VALUES(name);
"
    
    eval "$CONTAINER_CMD exec -i mariadb mariadb -u root -p\$MYSQL_ROOT_PASSWORD << 'EOF'
$test_data_sql
EOF" $ERROR_REDIRECT
    
    print_status "success" "MariaDB test data created"
}

create_mysql_test_data() {
    print_status "step" "Creating MySQL test data..."
    
    local test_data_sql="

... (file truncated - showing first 500 of 701 lines)
```

### scripts/setup-podman-socket.sh
```
#!/bin/bash

# =============================================================================
# PODMAN SOCKET SETUP FOR TRAEFIK
# =============================================================================
# Configure Podman to work with Traefik's Docker provider

set -e

print_status() {
    echo "üîß $1"
}

print_success() {
    echo "‚úÖ $1"
}

print_error() {
    echo "‚ùå $1"
}

# =============================================================================
# ENABLE PODMAN SOCKET
# =============================================================================

setup_podman_socket() {
    print_status "Setting up Podman socket for Traefik..."
    
    # Enable and start Podman socket (user mode)
    systemctl --user enable podman.socket
    systemctl --user start podman.socket
    
    # Verify socket is running
    if systemctl --user is-active podman.socket >/dev/null 2>&1; then
        print_success "Podman socket is active"
    else
        print_error "Failed to start Podman socket"
        exit 1
    fi
    
    # Show socket location
    SOCKET_PATH="/run/user/$(id -u)/podman/podman.sock"
    if [ -S "$SOCKET_PATH" ]; then
        print_success "Socket available at: $SOCKET_PATH"
    else
        print_error "Socket not found at expected location"
        exit 1
    fi
}

# =============================================================================
# ALTERNATIVE: SYSTEMD SOCKET (ROOT)
# =============================================================================

setup_system_socket() {
    print_status "Setting up system-wide Podman socket (requires sudo)..."
    
    # Enable and start system socket
    sudo systemctl enable podman.socket
    sudo systemctl start podman.socket
    
    # Verify socket is running
    if sudo systemctl is-active podman.socket >/dev/null 2>&1; then
        print_success "System Podman socket is active"
    else
        print_error "Failed to start system Podman socket"
        exit 1
    fi
    
    # Show socket location
    SOCKET_PATH="/run/podman/podman.sock"
    if sudo test -S "$SOCKET_PATH"; then
        print_success "Socket available at: $SOCKET_PATH"
        
        # Make socket accessible to your user
        sudo chmod 666 "$SOCKET_PATH"
        print_success "Socket permissions updated"
    else
        print_error "Socket not found at expected location"
        exit 1
    fi
}

# =============================================================================
# PODMAN API SERVICE (TCP)
# =============================================================================

setup_podman_api() {
    print_status "Setting up Podman API service on TCP..."
    
    # Start Podman API service
    podman system service --time=0 tcp://localhost:8888 &
    
    # Store PID for later cleanup
    echo $! > /tmp/podman-api.pid
    
    print_success "Podman API service started on tcp://localhost:8888"
    print_status "To stop: kill \$(cat /tmp/podman-api.pid)"
}

# =============================================================================
# TEST CONNECTIVITY
# =============================================================================

test_socket_connectivity() {
    local socket_path="$1"
    
    print_status "Testing socket connectivity..."
    
    # Test with curl
    if command -v curl >/dev/null 2>&1; then
        if curl -s --unix-socket "$socket_path" http://localhost/version >/dev/null 2>&1; then
            print_success "Socket responds to API calls"
            return 0
        fi
    fi
    
    # Test with podman directly
    if DOCKER_HOST="unix://$socket_path" podman version >/dev/null 2>&1; then
        print_success "Socket accessible via Podman"
        return 0
    fi
    
    print_error "Socket not responding to API calls"
    return 1
}

# =============================================================================
# CONFIGURE TRAEFIK LABELS FOR SERVICES
# =============================================================================

add_traefik_labels() {
    print_status "Example Traefik labels for your services..."
    
    cat << 'EOF'
# Add these labels to your service definitions:

services:
  your-service:
    # ... other config ...
    labels:
      # Enable Traefik
      - "traefik.enable=true"
      
      # HTTP Router
      - "traefik.http.routers.your-service.rule=Host(`your-service.test`)"
      - "traefik.http.routers.your-service.entrypoints=websecure"
      
      # HTTPS Router
      - "traefik.http.routers.your-service-secure.rule=Host(`your-service.test`)"
      - "traefik.http.routers.your-service-secure.entrypoints=websecure"
      - "traefik.http.routers.your-service-secure.tls=true"
      
      # Service definition
      - "traefik.http.services.your-service.loadbalancer.server.port=80"
      
      # Network
      - "traefik.docker.network=microservices-net"
      
      # Middleware (optional)
      - "traefik.http.routers.your-service-secure.middlewares=default-headers"

networks:
  microservices-net:
    external: true
EOF
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

main() {
    echo "=== Podman Socket Setup for Traefik ==="
    echo ""
    
    echo "Choose setup method:"
    echo "1) User socket (recommended) - /run/user/\$(id -u)/podman/podman.sock"
    echo "2) System socket (requires sudo) - /run/podman/podman.sock"
    echo "3) TCP API service - tcp://localhost:8888"
    echo "4) Show example labels"
    echo ""
    
    read -p "Enter choice (1-4): " choice
    
    case $choice in
        1)
            setup_podman_socket
            SOCKET_PATH="/run/user/$(id -u)/podman/podman.sock"
            test_socket_connectivity "$SOCKET_PATH"
            echo ""
            echo "Update your Traefik compose file with:"
            echo "- /run/user/\$(id -u)/podman/podman.sock:/var/run/podman/podman.sock:ro"
            ;;
        2)
            setup_system_socket
            SOCKET_PATH="/run/podman/podman.sock"
            test_socket_connectivity "$SOCKET_PATH"
            echo ""
            echo "Update your Traefik compose file with:"
            echo "- /run/podman/podman.sock:/var/run/podman/podman.sock:ro"
            ;;
        3)
            setup_podman_api
            echo ""
            echo "Update your Traefik config with:"
            echo "endpoint: \"tcp://host.docker.internal:8888\""
            ;;
        4)
            add_traefik_labels
            ;;
        *)
            print_error "Invalid choice"
            exit 1
            ;;
    esac
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi```

### scripts/setup-ssl.sh
```
#!/bin/zsh

# =============================================================================
# SSL CERTIFICATE SETUP SCRIPT
# =============================================================================
# Generates and configures SSL certificates for all microservices
# Cross-platform support for Linux, macOS, Windows, and WSL

# Source the central configuration
. "$(dirname "$0")/config.sh"

# =============================================================================
# SCRIPT OPTIONS & DEFAULTS
# =============================================================================

# Default values
opt_use_sudo="$DEFAULT_SUDO"
opt_show_errors=false
opt_force_regenerate=false
opt_custom_domain="$SSL_DOMAIN"
opt_cert_days="$SSL_DAYS_VALID"
opt_key_size=4096
opt_export_formats=false
opt_verify_only=false

# Certificate paths
CERT_CONTAINER_DIR="$SSL_CERT_DIR"
CERT_TEMP_DIR="/tmp/ssl-microservices-$$"

# =============================================================================
# USAGE & HELP
# =============================================================================

show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

DESCRIPTION:
    Generates wildcard SSL certificates for the microservices architecture.
    Creates certificates that work across all operating systems and browsers.

OPTIONS:
    -s, --sudo              Use sudo for container commands
    -e, --errors            Show detailed error messages
    -f, --force             Force regeneration of existing certificates
    -d, --domain DOMAIN     Custom domain (default: *.test)
    -k, --key-size SIZE     RSA key size in bits (default: 4096)
    -t, --days DAYS         Certificate validity in days (default: 3650)
    -x, --export            Export certificates in multiple formats
    -v, --verify            Only verify existing certificates
    -h, --help              Show this help message

SUPPORTED FORMATS:
    - PEM (default): fullchain.pem, privkey.pem
    - PFX/P12: For Windows IIS
    - DER: Binary format
    - CRT: Certificate only

EXAMPLES:
    $0                                  # Generate default wildcard certificate
    $0 -f                              # Force regenerate certificates
    $0 -d "*.local" -t 1825            # Custom domain, 5-year validity
    $0 -x                              # Generate and export all formats
    $0 -v                              # Verify existing certificates only
    $0 -s -e -f                        # Use sudo, show errors, force regen

CERTIFICATE LOCATIONS:
    Container: $CERT_CONTAINER_DIR/
    Exported:  $PROJECT_ROOT/ssl/

NOTES:
    - Certificates work with Chrome, Firefox, Safari, and Edge
    - Wildcard certificates cover all *.test subdomains
    - Generated certificates are suitable for development use
    - For production, consider using Let's Encrypt or commercial CA
EOF
}

# =============================================================================
# ARGUMENT PARSING
# =============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--sudo)
                opt_use_sudo=true
                shift
                ;;
            -e|--errors)
                opt_show_errors=true
                shift
                ;;
            -f|--force)
                opt_force_regenerate=true
                shift
                ;;
            -d|--domain)
                if [[ -n "$2" && "$2" != -* ]]; then
                    opt_custom_domain="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a domain value"
                fi
                ;;
            -k|--key-size)
                if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                    opt_key_size="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a numeric key size"
                fi
                ;;
            -t|--days)
                if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                    opt_cert_days="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a numeric days value"
                fi
                ;;
            -x|--export)
                opt_export_formats=true
                shift
                ;;
            -v|--verify)
                opt_verify_only=true
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                handle_error "Unknown option: $1. Use -h for help."
                ;;
        esac
    done
}

# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

validate_nginx_container() {
    print_status "step" "Validating nginx-proxy-manager container..."
    
    if ! eval "$CONTAINER_CMD container exists nginx-proxy-manager $ERROR_REDIRECT"; then
        handle_error "nginx-proxy-manager container not found. Please start proxy services first."
    fi
    
    # Check if container is running
    local container_status
    container_status=$(eval "$CONTAINER_CMD inspect --format='{{.State.Status}}' nginx-proxy-manager 2>/dev/null" || echo "unknown")
    
    if [[ "$container_status" != "running" ]]; then
        handle_error "nginx-proxy-manager container is not running. Current status: $container_status"
    fi
    
    print_status "success" "nginx-proxy-manager container is running"
}

validate_domain_format() {
    local domain="$opt_custom_domain"
    print_status "info" "Using domain: $domain"
}

check_existing_certificates() {
    if [[ "$opt_verify_only" == "true" ]]; then
        return 0
    fi
    
    local cert_exists=false
    
    if eval "$CONTAINER_CMD exec nginx-proxy-manager test -f $CERT_CONTAINER_DIR/fullchain.pem $ERROR_REDIRECT"; then
        cert_exists=true
        print_status "info" "Existing certificate found"
        
        if [[ "$opt_force_regenerate" == "false" ]]; then
            print_status "warning" "Certificate already exists. Use -f to force regeneration."
            verify_certificates
            exit 0
        else
            print_status "info" "Force regeneration requested"
        fi
    fi
}

# =============================================================================
# CERTIFICATE GENERATION FUNCTIONS
# =============================================================================

prepare_certificate_environment() {
    print_status "step" "Preparing certificate environment..."
    
    # Create certificate directory in container
    eval "$CONTAINER_CMD exec nginx-proxy-manager mkdir -p $CERT_CONTAINER_DIR $ERROR_REDIRECT"
    check_status "Failed to create certificate directory in container"
    
    # Create temporary directory on host
    mkdir -p "$CERT_TEMP_DIR"
    
    # Create export directory if needed
    if [[ "$opt_export_formats" == "true" ]]; then
        mkdir -p "$PROJECT_ROOT/ssl"
    fi
    
    print_status "success" "Certificate environment prepared"
}

generate_openssl_config() {
    local config_file="$CERT_TEMP_DIR/openssl.conf"
    local domain="$opt_custom_domain"
    local base_domain="${domain#\*.}"  # Remove *. prefix if present
    
    cat > "$config_file" << EOF
[req]
default_bits = $opt_key_size
prompt = no
default_md = sha256
req_extensions = v3_req
distinguished_name = dn

[dn]
C = US
ST = Development
L = Local
O = Microservices Development
OU = IT Department
CN = $domain

[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = $domain
DNS.2 = $base_domain
DNS.3 = localhost
DNS.4 = *.localhost
EOF

    # Add common service subdomains
    local -a service_domains=(
        "nginx.$base_domain"
        "adminer.$base_domain"
        "phpmyadmin.$base_domain"
        "mongodb.$base_domain"
        "metabase.$base_domain"
        "nocodb.$base_domain"
        "pgadmin.$base_domain"
        "redis.$base_domain"
        "grafana.$base_domain"
        "prometheus.$base_domain"
        "matomo.$base_domain"
        "n8n.$base_domain"
        "langflow.$base_domain"
        "kibana.$base_domain"
        "elasticsearch.$base_domain"
        "mailpit.$base_domain"
        "gitea.$base_domain"
    )
    
    local dns_counter=5
    for service_domain in "${service_domains[@]}"; do
        echo "DNS.$dns_counter = $service_domain" >> "$config_file"
        ((dns_counter++))
    done
    
    print_status "success" "OpenSSL configuration generated with ${#service_domains[@]} service domains"
}

generate_certificate() {
    print_status "step" "Generating SSL certificate..."
    
    # First generate the config inside the container
    local container_config="/tmp/openssl.conf"
    local container_cert="$CERT_CONTAINER_DIR/fullchain.pem"
    local container_key="$CERT_CONTAINER_DIR/privkey.pem"
    
    # Copy our config to the container
    eval "$CONTAINER_CMD cp '$CERT_TEMP_DIR/openssl.conf' nginx-proxy-manager:/tmp/openssl.conf $ERROR_REDIRECT"
    check_status "Failed to copy OpenSSL config to container"
    
    # Generate certificate directly in the container
    local openssl_cmd="openssl req -x509 -nodes -days $opt_cert_days -newkey rsa:$opt_key_size"
    openssl_cmd="$openssl_cmd -keyout '$container_key' -out '$container_cert'"
    openssl_cmd="$openssl_cmd -config '$container_config' -extensions v3_req"
    
    if eval "$CONTAINER_CMD exec nginx-proxy-manager $openssl_cmd $ERROR_REDIRECT"; then
        print_status "success" "SSL certificate generated successfully"
    else
        print_status "error" "Failed to generate SSL certificate. Trying alternative method..."
        
        # Alternative: Generate on host and copy to container
        generate_certificate_on_host
    fi
    
    # Set proper permissions
    eval "$CONTAINER_CMD exec nginx-proxy-manager chmod 644 $container_cert $ERROR_REDIRECT"
    eval "$CONTAINER_CMD exec nginx-proxy-manager chmod 600 $container_key $ERROR_REDIRECT"
}

generate_certificate_on_host() {
    print_status "step" "Generating certificate on host as fallback..."
    
    local key_file="$CERT_TEMP_DIR/privkey.pem"
    local cert_file="$CERT_TEMP_DIR/fullchain.pem"
    local config_file="$CERT_TEMP_DIR/openssl.conf"
    
    # Generate certificate on host
    local openssl_cmd="openssl req -x509 -nodes -days $opt_cert_days -newkey rsa:$opt_key_size"
    openssl_cmd="$openssl_cmd -keyout '$key_file' -out '$cert_file'"
    openssl_cmd="$openssl_cmd -config '$config_file' -extensions v3_req"
    
    if eval "$openssl_cmd $ERROR_REDIRECT"; then
        print_status "success" "Certificate generated on host"
        
        # Copy to container
        eval "$CONTAINER_CMD cp '$cert_file' nginx-proxy-manager:$CERT_CONTAINER_DIR/fullchain.pem $ERROR_REDIRECT"
        check_status "Failed to copy certificate to container"
        
        eval "$CONTAINER_CMD cp '$key_file' nginx-proxy-manager:$CERT_CONTAINER_DIR/privkey.pem $ERROR_REDIRECT"
        check_status "Failed to copy private key to container"
        
        print_status "success" "Certificate copied to container"
    else
        handle_error "Failed to generate SSL certificate"
    fi
}

export_certificate_formats() {
    if [[ "$opt_export_formats" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Exporting certificate in multiple formats..."
    
    local export_dir="$PROJECT_ROOT/ssl"
    local domain_safe="${opt_custom_domain//\*/wildcard}"
    
    # Copy certificates from container to export directory
    eval "$CONTAINER_CMD cp nginx-proxy-manager:$CERT_CONTAINER_DIR/fullchain.pem '$export_dir/${domain_safe}.crt' $ERROR_REDIRECT"
    eval "$CONTAINER_CMD cp nginx-proxy-manager:$CERT_CONTAINER_DIR/privkey.pem '$export_dir/${domain_safe}.key' $ERROR_REDIRECT"
    
    # Generate additional formats
    local cert_file="$export_dir/${domain_safe}.crt"
    local key_file="$export_dir/${domain_safe}.key"
    
    # Export PFX format (for Windows)
    openssl pkcs12 -export -out "$export_dir/${domain_safe}.pfx" \
        -inkey "$key_file" -in "$cert_file" \
        -passout pass:password $ERROR_REDIRECT
    
    # Export DER format
    openssl x509 -outform der -in "$cert_file" -out "$export_dir/${domain_safe}.der" $ERROR_REDIRECT
    
    # Create combined file
    cat "$cert_file" "$key_file" > "$export_dir/${domain_safe}.pem"
    
    # Create info file
    cat > "$export_dir/certificate-info.txt" << EOF
SSL Certificate Information
==========================
Domain: $opt_custom_domain
Generated: $(date)
Validity: $opt_cert_days days
Key Size: $opt_key_size bits

Files:
- ${domain_safe}.crt    - Certificate (PEM format)
- ${domain_safe}.key    - Private Key (PEM format)
- ${domain_safe}.pem    - Combined Certificate + Key
- ${domain_safe}.pfx    - PKCS#12 format (password: password)
- ${domain_safe}.der    - Binary certificate format

Usage:
- Web servers: Use .crt and .key files
- Windows IIS: Use .pfx file
- Java applications: Convert .der to .jks format
EOF
    
    print_status "success" "Certificates exported to $export_dir"
}

restart_nginx_container() {
    print_status "step" "Restarting nginx-proxy-manager to apply certificates..."
    
    eval "$CONTAINER_CMD restart nginx-proxy-manager $ERROR_REDIRECT"
    check_status "Failed to restart nginx-proxy-manager"
    
    # Wait for container to be ready
    sleep 5
    
    # Verify container is running
    local max_wait=30
    local counter=0
    while [[ $counter -lt $max_wait ]]; do
        local container_status
        container_status=$(eval "$CONTAINER_CMD inspect --format='{{.State.Status}}' nginx-proxy-manager 2>/dev/null" || echo "unknown")
        
        if [[ "$container_status" == "running" ]]; then
            print_status "success" "nginx-proxy-manager restarted successfully"
            return 0
        fi
        
        sleep 1
        ((counter++))
    done
    
    handle_error "nginx-proxy-manager failed to start after restart"
}

# =============================================================================
# CERTIFICATE VERIFICATION FUNCTIONS
# =============================================================================

verify_certificates() {
    print_status "step" "Verifying SSL certificates..."
    
    # Check if certificates exist in container
    if ! eval "$CONTAINER_CMD exec nginx-proxy-manager test -f $CERT_CONTAINER_DIR/fullchain.pem $ERROR_REDIRECT"; then
        handle_error "Certificate file not found in container"
    fi
    
    if ! eval "$CONTAINER_CMD exec nginx-proxy-manager test -f $CERT_CONTAINER_DIR/privkey.pem $ERROR_REDIRECT"; then
        handle_error "Private key file not found in container"
    fi
    
    # Copy certificate to temp for verification
    mkdir -p "$CERT_TEMP_DIR"
    eval "$CONTAINER_CMD cp nginx-proxy-manager:$CERT_CONTAINER_DIR/fullchain.pem $CERT_TEMP_DIR/verify.crt $ERROR_REDIRECT"
    
    # Verify certificate details
    local cert_info
    cert_info=$(openssl x509 -in "$CERT_TEMP_DIR/verify.crt" -noout -text 2>/dev/null)
    
    if [[ $? -eq 0 ]]; then
        print_status "success" "Certificate is valid"
        
        # Extract key information
        local subject
        local validity
        local san_domains
        
        subject=$(echo "$cert_info" | grep "Subject:" | sed 's/.*Subject: //')
        validity=$(echo "$cert_info" | grep "Not After" | sed 's/.*Not After : //')
        san_domains=$(echo "$cert_info" | grep -A1 "Subject Alternative Name" | tail -1 | tr ',' '\n' | wc -l)
        
        print_status "info" "Certificate Details:"
        echo "  Subject: $subject"
        echo "  Valid Until: $validity"
        echo "  SAN Domains: $san_domains"
        
        # Check if certificate covers our domain
        if echo "$cert_info" | grep -q "$opt_custom_domain" $ERROR_REDIRECT; then
            print_status "success" "Certificate covers domain: $opt_custom_domain"
        else
            print_status "warning" "Certificate may not cover domain: $opt_custom_domain"
        fi
        
    else
        handle_error "Certificate verification failed"
    fi
}

test_certificate_installation() {
    print_status "step" "Testing certificate installation..."
    
    # Test if nginx can read the certificates
    if eval "$CONTAINER_CMD exec nginx-proxy-manager openssl x509 -in $CERT_CONTAINER_DIR/fullchain.pem -noout $ERROR_REDIRECT"; then
        print_status "success" "Certificate is readable by nginx"
    else
        print_status "warning" "Certificate may not be readable by nginx"
    fi
    
    # Test private key
    if eval "$CONTAINER_CMD exec nginx-proxy-manager openssl rsa -in $CERT_CONTAINER_DIR/privkey.pem -check -noout $ERROR_REDIRECT"; then
        print_status "success" "Private key is valid"
    else
        print_status "warning" "Private key validation failed"
    fi
    
    # Test key-certificate match
    local cert_hash key_hash
    cert_hash=$(eval "$CONTAINER_CMD exec nginx-proxy-manager openssl x509 -noout -modulus -in $CERT_CONTAINER_DIR/fullchain.pem | openssl md5" 2>/dev/null)
    key_hash=$(eval "$CONTAINER_CMD exec nginx-proxy-manager openssl rsa -noout -modulus -in $CERT_CONTAINER_DIR/privkey.pem | openssl md5" 2>/dev/null)
    
    if [[ "$cert_hash" == "$key_hash" && -n "$cert_hash" ]]; then
        print_status "success" "Certificate and private key match"
    else
        print_status "warning" "Certificate and private key may not match"
    fi
}

# =============================================================================
# CLEANUP FUNCTIONS
# =============================================================================


... (file truncated - showing first 500 of 588 lines)
```

### scripts/show-services.sh
```
#!/bin/zsh

# Source configuration and dependencies
. "$(dirname "$0")/config.sh"

# Colorize output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# Function to print section header
print_header() {
  echo ""
  echo -e "${BLUE}=== $1 ===${NC}"
  echo ""
}

# Function to print service info
print_service() {
  local name=$1
  local local_url=$2
  local proxy_url=$3
  
  echo -e "${GREEN}${name}${NC}"
  echo -e "  ${YELLOW}Local:${NC} ${local_url}"
  echo -e "  ${YELLOW}Proxy:${NC} ${proxy_url}"
  echo ""
}

# Display welcome message
echo -e "${BLUE}===============================================${NC}"
echo -e "${BLUE}      MICROSERVICES ARCHITECTURE DIRECTORY     ${NC}"
echo -e "${BLUE}===============================================${NC}"
echo ""
echo -e "Each service can be accessed both ${YELLOW}locally${NC} via port and through the ${YELLOW}proxy${NC} via domain name."

# Proxy & SSL
print_header "üåê REVERSE PROXY & SSL"
print_service "Nginx Proxy Manager" "http://localhost:81" "https://nginx.test"

# Database Services
print_header "üóÑÔ∏è DATABASE SERVICES"
print_service "MariaDB" "localhost:8501" "mariadb:3306 (internal)"
print_service "MySQL" "localhost:8505" "mysql:3306 (internal)"
print_service "PostgreSQL" "localhost:8502" "postgres:5432 (internal)"
print_service "MongoDB" "localhost:8503" "mongodb:27017 (internal)"
print_service "Redis" "localhost:8504" "redis:6379 (internal)"

# Database Management Tools
print_header "üîß DATABASE MANAGEMENT TOOLS"
print_service "Adminer" "http://localhost:8082" "https://adminer.test"
print_service "phpMyAdmin" "http://localhost:8083" "https://phpmyadmin.test"
print_service "Mongo Express" "http://localhost:8084" "https://mongodb.test"
print_service "Metabase" "http://localhost:8085" "https://metabase.test"
print_service "NocoDB" "http://localhost:8086" "https://nocodb.test"
print_service "pgAdmin" "http://localhost:8087" "https://pgadmin.test"
print_service "Redis Commander" "http://localhost:8088" "https://redis.test"

# Backend Services
print_header "‚öôÔ∏è BACKEND SERVICES"
print_service ".NET Core" "http://localhost:8010" "https://dotnet.test"
print_service "Go" "http://localhost:8020" "https://go.test"
print_service "Node.js" "http://localhost:8030" "https://node.test"
print_service "PHP" "http://localhost:8000" "https://php.test"
print_service "Python" "http://localhost:8040" "https://python.test"

# Analytics & Monitoring
print_header "üìä ANALYTICS & MONITORING"
print_service "Elasticsearch" "http://localhost:9130" "https://elasticsearch.test"
print_service "Kibana" "http://localhost:9120" "https://kibana.test"
print_service "Grafana" "http://localhost:9001" "https://grafana.test"
print_service "Prometheus" "http://localhost:9090" "https://prometheus.test"
print_service "Matomo Analytics" "http://localhost:9010" "https://matomo.test"

# AI & Workflow Services
print_header "ü§ñ AI & WORKFLOW SERVICES"
print_service "Langflow" "http://localhost:9110" "https://langflow.test"
print_service "n8n" "http://localhost:9100" "https://n8n.test"

# Mail Services
print_header "üìß MAIL SERVICES"
print_service "Mailpit" "http://localhost:9200" "https://mailpit.test"

# Project Management
print_header "üìã PROJECT MANAGEMENT"
print_service "Gitea" "http://localhost:9210" "https://gitea.test"

# Print footer with credentials and tips
print_header "üîê DEFAULT CREDENTIALS"
echo -e "${YELLOW}Username:${NC} admin"
echo -e "${YELLOW}Password:${NC} 123456"
echo -e "${YELLOW}Email:${NC} admin@site.test"

print_header "üìã QUICK MANAGEMENT COMMANDS"
echo "Start all services:    $SCRIPT_DIR/start-services.sh"
echo "Stop all services:     $SCRIPT_DIR/stop-services.sh"
echo "Setup databases:       $SCRIPT_DIR/setup-databases.sh -a"
echo "Setup SSL:            $SCRIPT_DIR/setup-ssl.sh"
echo "Install SSL trust:     $SCRIPT_DIR/trust-host.sh"

print_header "üí° QUICK TIPS"
echo "1. Use local ports for development and direct database access"
echo "2. Use the proxy URLs for a production-like environment"
echo "3. All services are on the same Docker network: 'microservices-net'"
echo "4. Configure your local hosts file if needed:"
echo "   echo '127.0.0.1 nginx.test grafana.test metabase.test' >> /etc/hosts"
echo ""
echo -e "${BLUE}===============================================${NC}"```

### scripts/socket-manager.sh
```
#!/bin/zsh

# =============================================================================
# PODMAN SOCKET MANAGER - NO BULLSHIT VERSION (ZSH OPTIMIZED)
# =============================================================================

cmd_status() {
    echo "=== SOCKET STATUS ==="
    echo "User: $(whoami) ($(id -u))"
    echo "Rootless socket: $(systemctl --user is-active podman.socket)"
    echo "Rootful socket: $(sudo systemctl is-active podman.socket 2>/dev/null || echo 'inactive')"
    echo "Rootless file: $(test -S /run/user/$(id -u)/podman/podman.sock && echo 'exists' || echo '‚ùå MISSING')"
    echo "Rootful file: $(sudo test -S /run/podman/podman.sock && echo 'exists' || echo '‚ùå MISSING')"
    echo "DOCKER_HOST: ${DOCKER_HOST:-not set}"
    echo ""
    
    # Quick connectivity test
    if test -S /run/user/$(id -u)/podman/podman.sock; then
        if DOCKER_HOST="unix:///run/user/$(id -u)/podman/podman.sock" podman version >/dev/null 2>&1; then
            echo "Rootless connectivity: WORKING"
        else
            echo "Rootless connectivity: BROKEN"
        fi
    fi
    
    if sudo test -S /run/podman/podman.sock; then
        if sudo DOCKER_HOST="unix:///run/podman/podman.sock" podman version >/dev/null 2>&1; then
            echo "Rootful connectivity: WORKING"
        else
            echo "Rootful connectivity: BROKEN"
        fi
    fi
}

cmd_start_rootless() {
    print "Starting rootless socket..."
    
    # Stop rootful first
    sudo systemctl stop podman.socket 2>/dev/null
    
    # Enable lingering
    sudo loginctl enable-linger $(whoami)
    
    # Start rootless
    systemctl --user enable --now podman.socket
    
    print "Waiting for socket..."
    sleep 2
    
    if [[ -S /run/user/$(id -u)/podman/podman.sock ]]; then
        print "‚úÖ Rootless socket started successfully"
        print "Export this: export DOCKER_HOST=\"unix:///run/user/$(id -u)/podman/podman.sock\""
    else
        print "‚ùå Socket failed to start"
        return 1
    fi
}

cmd_start_rootful() {
    print "Starting rootful socket..."
    
    # Stop rootless first
    systemctl --user stop podman.socket 2>/dev/null
    
    # Start rootful
    sudo systemctl enable --now podman.socket
    
    print "Waiting for socket..."
    sleep 2
    
    if sudo test -S /run/podman/podman.sock; then
        print "‚úÖ Rootful socket started successfully"
        print "Export this: export DOCKER_HOST=\"unix:///run/podman/podman.sock\""
    else
        print "‚ùå Socket failed to start"
        return 1
    fi
}

cmd_stop() {
    print "Stopping all sockets..."
    systemctl --user stop podman.socket 2>/dev/null
    sudo systemctl stop podman.socket 2>/dev/null
    print "‚úÖ All sockets stopped"
}

cmd_test() {
    print "=== TESTING SOCKETS ==="
    
    if [[ -S /run/user/$(id -u)/podman/podman.sock ]]; then
        print "Testing rootless..."
        if DOCKER_HOST="unix:///run/user/$(id -u)/podman/podman.sock" podman version >/dev/null 2>&1; then
            print "‚úÖ Rootless socket responds"
        else
            print "‚ùå Rootless socket not responding"
        fi
    else
        print "‚ö™ Rootless socket not found"
    fi
    
    if sudo test -S /run/podman/podman.sock; then
        print "Testing rootful..."
        if sudo DOCKER_HOST="unix:///run/podman/podman.sock" podman version >/dev/null 2>&1; then
            print "‚úÖ Rootful socket responds"
        else
            print "‚ùå Rootful socket not responding"
        fi
    else
        print "‚ö™ Rootful socket not found"
    fi
}

cmd_logs() {
    local type="${1:-rootless}"
    print "Showing $type socket logs (Ctrl+C to exit)..."
    
    case "$type" in
        rootless)
            journalctl --user -u podman.socket -f
            ;;
        rootful)
            sudo journalctl -u podman.socket -f
            ;;
        *)
            print "Usage: logs [rootless|rootful]"
            ;;
    esac
}

cmd_fix() {
    print "=== FIXING BROKEN SOCKETS ==="
    
    print "Killing conflicting processes..."
    pkill -f "podman system service" 2>/dev/null || true
    
    print "Stopping all sockets..."
    systemctl --user stop podman.socket 2>/dev/null
    sudo systemctl stop podman.socket 2>/dev/null
    
    print "Checking permissions..."
    if [[ -S /run/user/$(id -u)/podman/podman.sock ]]; then
        chmod 660 /run/user/$(id -u)/podman/podman.sock
        print "Fixed rootless permissions"
    fi
    
    if sudo test -S /run/podman/podman.sock; then
        sudo chmod 660 /run/podman/podman.sock
        print "Fixed rootful permissions"
    fi
    
    print "Restarting rootless socket..."
    systemctl --user start podman.socket
    
    sleep 2
    cmd_test
}

cmd_nuke() {
    print "=== NUCLEAR RESET ==="
    print "This will destroy everything and start fresh!"
    read -q "?Are you sure? (y/N): "
    print
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print "Cancelled"
        return 0
    fi
    
    print "Stopping everything..."
    systemctl --user stop podman.socket 2>/dev/null
    sudo systemctl stop podman.socket 2>/dev/null
    pkill -f podman 2>/dev/null || true
    
    print "Removing socket files..."
    rm -rf /run/user/$(id -u)/podman/ 2>/dev/null || true
    sudo rm -rf /run/podman/ 2>/dev/null || true
    
    print "Waiting 5 seconds..."
    sleep 5
    
    print "Starting fresh rootless socket..."
    sudo loginctl enable-linger $(whoami)
    systemctl --user enable --now podman.socket
    
    sleep 3
    cmd_test
}

cmd_env() {
    print "=== ENVIRONMENT SETUP ==="
    
    if systemctl --user is-active podman.socket >/dev/null 2>&1; then
        print "Rootless socket is active. Add to ~/.zshrc:"
        print 'export DOCKER_HOST="unix:///run/user/$(id -u)/podman/podman.sock"'
        print ""
        print "Or run now:"
        print "export DOCKER_HOST=\"unix:///run/user/$(id -u)/podman/podman.sock\""
    elif sudo systemctl is-active podman.socket >/dev/null 2>&1; then
        print "Rootful socket is active. Add to ~/.zshrc:"
        print 'export DOCKER_HOST="unix:///run/podman/podman.sock"'
        print ""
        print "Or run now:"
        print "export DOCKER_HOST=\"unix:///run/podman/podman.sock\""
    else
        print "No active sockets found. Start one first:"
        print "$0 start-rootless"
    fi
}

cmd_traefik() {
    print "=== TRAEFIK INTEGRATION ==="
    
    if systemctl --user is-active podman.socket >/dev/null 2>&1; then
        print "Using rootless socket. Add to traefik compose volumes:"
        print "  - /run/user/$(id -u)/podman/podman.sock:/var/run/docker.sock:ro"
    elif sudo systemctl is-active podman.socket >/dev/null 2>&1; then
        print "Using rootful socket. Add to traefik compose volumes:"
        print "  - /run/podman/podman.sock:/var/run/docker.sock:ro"
    else
        print "No active sockets. Start one first:"
        print "$0 start-rootless"
        return 1
    fi
    
    print ""
    print "Test traefik can see the socket:"
    print "podman exec traefik ls -la /var/run/docker.sock"
}

usage() {
    cat << EOF
Podman Socket Manager

COMMANDS:
  status           Show socket status and connectivity
  start-rootless   Start rootless socket (recommended)
  start-rootful    Start rootful socket (needs sudo)
  stop             Stop all sockets
  test             Test socket connectivity
  logs [type]      Show socket logs (rootless/rootful)
  fix              Try to fix broken sockets
  nuke             Nuclear reset - destroy and rebuild
  env              Show environment setup
  traefik          Show traefik integration info

EXAMPLES:
  $0 status                # Check what's running
  $0 start-rootless       # Start rootless (preferred)
  $0 test                 # Test if sockets work
  $0 fix                  # Fix broken sockets
  $0 logs rootless        # Show logs

EOF
}

# Main command dispatch
case "${1:-status}" in
    status|s)           cmd_status ;;
    start-rootless|sr)  cmd_start_rootless ;;
    start-rootful|sf)   cmd_start_rootful ;;
    stop)               cmd_stop ;;
    test|t)             cmd_test ;;
    logs|l)             cmd_logs "$2" ;;
    fix|f)              cmd_fix ;;
    nuke|n)             cmd_nuke ;;
    env|e)              cmd_env ;;
    traefik|tr)         cmd_traefik ;;
    help|h|-h|--help)   usage ;;
    *)                  echo "Unknown command: $1"; usage; exit 1 ;;
esac```

### scripts/start-services.sh
```
#!/bin/zsh

# =============================================================================
# MICROSERVICES STARTUP SCRIPT
# =============================================================================
# Enhanced service startup with dependency management, health monitoring,
# and selective service control

# Source the central configuration
. "$(dirname "$0")/config.sh"

# =============================================================================
# SCRIPT OPTIONS & DEFAULTS
# =============================================================================

# Default values
opt_use_sudo="$DEFAULT_SUDO"
opt_show_errors=false
opt_force_recreate=false
opt_categories_only=""
opt_exclude_categories=""
opt_parallel_start=false
opt_wait_healthy=true
opt_health_timeout=120
opt_restart_policy="unless-stopped"
opt_dry_run=false
opt_verbose=false

# =============================================================================
# USAGE & HELP
# =============================================================================

show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

DESCRIPTION:
    Enhanced service startup script with dependency management, health monitoring,
    and selective service control. Starts services in proper dependency order.

OPTIONS:
    -s, --sudo              Use sudo for container commands
    -e, --errors            Show detailed error messages
    -f, --force             Force recreate containers (docker compose up --force-recreate)
    -c, --categories LIST   Start only specific categories (comma-separated)
    -x, --exclude LIST      Exclude specific categories (comma-separated)
    -p, --parallel          Start services in parallel within categories
    -w, --no-wait           Don't wait for health checks
    -t, --timeout SECONDS   Health check timeout (default: 120)
    -r, --restart POLICY    Restart policy (no, always, unless-stopped, on-failure)
    -d, --dry-run           Show what would be started without actually starting
    -v, --verbose           Show detailed progress information
    -h, --help              Show this help message

CATEGORIES (in dependency order):
    database      - MariaDB, MySQL, PostgreSQL, MongoDB, Redis
    db-tools      - Adminer, phpMyAdmin, Mongo Express, Metabase, NocoDB, pgAdmin
    backend       - .NET, Go, Node.js, PHP, Python applications
    analytics     - Elasticsearch, Kibana, Logstash, Grafana, Prometheus, Matomo
    ai-services   - Langflow, n8n automation platforms
    mail          - Mailpit email testing
    project       - Gitea repository management
    proxy         - Nginx Proxy Manager

RESTART POLICIES:
    no              - Do not restart containers automatically
    always          - Always restart containers
    unless-stopped  - Restart unless explicitly stopped (default)
    on-failure      - Restart only on failure

EXAMPLES:
    $0                                 # Start all services in dependency order
    $0 -c database,backend             # Start only database and backend services
    $0 -x dbms,backend                     # Start all except dbms and backend services
    $0 -f -p                           # Force recreate and parallel start
    $0 -d -v                           # Dry run with verbose output
    $0 -w -t 60                        # Skip health checks, 60s timeout
    $0 --restart always --force        # Force recreate with always restart

DEPENDENCY HANDLING:
    - Database services start first and wait for readiness
    - MongoDB gets special handling for replica set initialization
    - Services within categories can start in parallel with -p option
    - Health checks ensure services are ready before dependent services start

NOTES:
    - Services are started in dependency order automatically
    - Use --parallel for faster startup within categories
    - Health checks prevent cascading failures
    - Dry run mode shows exactly what would be executed
EOF
}

# =============================================================================
# ARGUMENT PARSING
# =============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--sudo)
                opt_use_sudo=true
                shift
                ;;
            -e|--errors)
                opt_show_errors=true
                shift
                ;;
            -f|--force)
                opt_force_recreate=true
                shift
                ;;
            -c|--categories)
                if [[ -n "$2" && "$2" != -* ]]; then
                    opt_categories_only="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a comma-separated list of categories"
                fi
                ;;
            -x|--exclude)
                if [[ -n "$2" && "$2" != -* ]]; then
                    opt_exclude_categories="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a comma-separated list of categories"
                fi
                ;;
            -p|--parallel)
                opt_parallel_start=true
                shift
                ;;
            -w|--no-wait)
                opt_wait_healthy=false
                shift
                ;;
            -t|--timeout)
                if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                    opt_health_timeout="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a numeric timeout value"
                fi
                ;;
            -r|--restart)
                if [[ -n "$2" && "$2" != -* ]]; then
                    case "$2" in
                        no|always|unless-stopped|on-failure)
                            opt_restart_policy="$2"
                            ;;
                        *)
                            handle_error "Invalid restart policy: $2"
                            ;;
                    esac
                    shift 2
                else
                    handle_error "Option $1 requires a restart policy"
                fi
                ;;
            -d|--dry-run)
                opt_dry_run=true
                opt_verbose=true  # Dry run implies verbose
                shift
                ;;
            -v|--verbose)
                opt_verbose=true
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                handle_error "Unknown option: $1. Use -h for help."
                ;;
        esac
    done
}

# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

validate_categories() {
    # Validate included categories
    if [[ -n "$opt_categories_only" ]]; then
        local -a requested_categories
        requested_categories=(${(s:,:)opt_categories_only})
        
        for category in "${requested_categories[@]}"; do
            if [[ -z "${SERVICE_CATEGORIES[$category]}" ]]; then
                handle_error "Invalid category: $category. Available: ${(k)SERVICE_CATEGORIES}"
            fi
        done
        
        print_status "info" "Will start categories: ${requested_categories[*]}"
    fi
    
    # Validate excluded categories
    if [[ -n "$opt_exclude_categories" ]]; then
        local -a excluded_categories
        excluded_categories=(${(s:,:)opt_exclude_categories})
        
        for category in "${excluded_categories[@]}"; do
            if [[ -z "${SERVICE_CATEGORIES[$category]}" ]]; then
                handle_error "Invalid exclude category: $category. Available: ${(k)SERVICE_CATEGORIES}"
            fi
        done
        
        print_status "info" "Will exclude categories: ${excluded_categories[*]}"
    fi
}

validate_environment() {
    print_status "step" "Validating environment..."
    
    # Check container runtime
    if ! command -v "$CONTAINER_RUNTIME" >/dev/null 2>&1; then
        handle_error "$CONTAINER_RUNTIME is not installed or not in PATH"
    fi
    
    # Test container runtime
    if ! eval "$CONTAINER_CMD --version $ERROR_REDIRECT"; then
        handle_error "$CONTAINER_RUNTIME is not working properly"
    fi
    
    # Check compose directory
    if [[ ! -d "$COMPOSE_DIR" ]]; then
        handle_error "Compose directory not found: $COMPOSE_DIR"
    fi
    
    # Check .env file
    if [[ ! -f "$PROJECT_ROOT/.env" ]]; then
        print_status "warning" "No .env file found"
        if [[ -f "$PROJECT_ROOT/.env-sample" ]]; then
            print_status "info" "Consider copying .env-sample to .env"
        fi
    fi
    
    print_status "success" "Environment validation passed"
}

# =============================================================================
# SERVICE MANAGEMENT FUNCTIONS
# =============================================================================

get_startup_categories() {
    local -a categories_to_start
    
    if [[ -n "$opt_categories_only" ]]; then
        # Use only specified categories, but maintain dependency order
        local -a requested_categories
        requested_categories=(${(s:,:)opt_categories_only})
        
        # Filter SERVICE_STARTUP_ORDER to only include requested categories
        for category in "${SERVICE_STARTUP_ORDER[@]}"; do
            if [[ " ${requested_categories[*]} " =~ " $category " ]]; then
                categories_to_start+=("$category")
            fi
        done
    else
        # Use all categories
        categories_to_start=("${SERVICE_STARTUP_ORDER[@]}")
    fi
    
    # Remove excluded categories
    if [[ -n "$opt_exclude_categories" ]]; then
        local -a excluded_categories
        excluded_categories=(${(s:,:)opt_exclude_categories})
        
        local -a filtered_categories
        for category in "${categories_to_start[@]}"; do
            if [[ ! " ${excluded_categories[*]} " =~ " $category " ]]; then
                filtered_categories+=("$category")
            fi
        done
        categories_to_start=("${filtered_categories[@]}")
    fi
    
    echo "${categories_to_start[@]}"
}

start_service_file() {
    local service_file="$1"
    local category="$2"
    local full_path="$(resolve_service_path "$service_file" "$category")"
    
    if [[ ! -f "$full_path" ]]; then
        print_status "warning" "Service file not found: $service_file"
        return 1
    fi
    
    local service_name="${service_file%.yml}"
    
    if [[ "$opt_verbose" == "true" ]]; then
        print_status "step" "Starting $service_name from $service_file..."
    fi
    
    # Build compose command
    local compose_args=("-f" "$full_path" "up" "-d")
    
    # Add restart policy if not default
    if [[ "$opt_restart_policy" != "unless-stopped" ]]; then
        compose_args+=("--restart" "$opt_restart_policy")
    fi
    
    # Add force recreate if requested
    if [[ "$opt_force_recreate" == "true" ]]; then
        compose_args+=("--force-recreate")
    fi
    
    # Execute or show dry run
    if [[ "$opt_dry_run" == "true" ]]; then
        echo "DRY RUN: $COMPOSE_CMD ${compose_args[*]}"
        return 0
    fi
    
    # Execute the command
    if eval "$COMPOSE_CMD ${compose_args[*]} $ERROR_REDIRECT"; then
        if [[ "$opt_verbose" == "true" ]]; then
            print_status "success" "$service_name started successfully"
        fi
        return 0
    else
        print_status "error" "Failed to start $service_name"
        return 1
    fi
}

start_category_parallel() {
    local category="$1"
    local service_files="$2"
    
    local -a files pids
    files=(${=service_files})
    
    print_status "step" "Starting $category services in parallel..."
    
    # Start all services in background
    for service_file in "${files[@]}"; do
        if [[ "$opt_dry_run" == "true" ]]; then
            start_service_file "$service_file" "$category"
        else
            start_service_file "$service_file" "$category" &
            pids+=($!)
        fi
    done
    
    if [[ "$opt_dry_run" == "false" ]]; then
        # Wait for all parallel starts to complete
        local failed=0
        for pid in "${pids[@]}"; do
            if ! wait "$pid"; then
                ((failed++))
            fi
        done
        
        if [[ $failed -eq 0 ]]; then
            print_status "success" "$category services started successfully"
        else
            print_status "warning" "$failed service(s) in $category failed to start"
        fi
    fi
}

start_category_sequential() {
    local category="$1"
    local service_files="$2"
    
    local -a files
    files=(${=service_files})
    
    print_status "step" "Starting $category services sequentially..."
    
    local failed=0
    for service_file in "${files[@]}"; do
        if ! start_service_file "$service_file" "$category"; then
            ((failed++))
        fi
        
        # Brief pause between services
        if [[ "$opt_dry_run" == "false" ]]; then
            sleep 1
        fi
    done
    
    if [[ $failed -eq 0 ]]; then
        print_status "success" "$category services started successfully"
    else
        print_status "warning" "$failed service(s) in $category failed to start"
    fi
}

wait_for_category_health() {
    local category="$1"
    
    if [[ "$opt_wait_healthy" == "false" || "$opt_dry_run" == "true" ]]; then
        return 0
    fi
    
    print_status "step" "Waiting for $category services to be healthy..."
    
    # Special handling for different categories
    case "$category" in
        "database")
            # Wait for MongoDB specifically if it's in this category
            local service_files
            service_files=$(get_service_files "$category")
            if [[ "$service_files" == *"mongodb.yml"* ]]; then
                wait_for_mongodb "$opt_health_timeout"
            fi
            
            # Brief wait for other databases
            sleep 5
            ;;
        "proxy")
            # Wait longer for nginx proxy manager
            sleep 10
            ;;
        *)
            # Standard wait for other services
            sleep 3
            ;;
    esac
    
    print_status "success" "$category services are ready"
}

# =============================================================================
# NETWORK AND ENVIRONMENT SETUP
# =============================================================================

setup_environment() {
    print_status "step" "Setting up environment..."
    
    # Create network if it doesn't exist
    ensure_network_exists
    
    # Create necessary directories
    create_required_directories
    
    print_status "success" "Environment setup completed"
}

create_required_directories() {
    local -a required_dirs=(
        "$APPS_DIR"
        "$LOGS_DIR"
        "$LOGS_DIR/nginx"
        "$LOGS_DIR/dotnet"
        "$LOGS_DIR/go"
        "$LOGS_DIR/node"
        "$LOGS_DIR/python"
    )
    
    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            if [[ "$opt_dry_run" == "true" ]]; then
                echo "DRY RUN: mkdir -p $dir"
            else
                mkdir -p "$dir"
                if [[ "$opt_verbose" == "true" ]]; then
                    print_status "info" "Created directory: $dir"
                fi
            fi
        fi
    done
}

# =============================================================================
# MAIN EXECUTION FUNCTIONS
# =============================================================================

show_startup_summary() {
    local -a categories_to_start
    categories_to_start=($(get_startup_categories))
    
    print_status "info" "Service Startup Summary:"
    echo "  Container Runtime: $CONTAINER_RUNTIME"
    echo "  Use Sudo: $opt_use_sudo"
    echo "  Show Errors: $opt_show_errors"
    echo "  Force Recreate: $opt_force_recreate"
    echo "  Parallel Start: $opt_parallel_start"
    echo "  Wait for Health: $opt_wait_healthy"
    echo "  Health Timeout: ${opt_health_timeout}s"
    echo "  Restart Policy: $opt_restart_policy"
    echo "  Dry Run: $opt_dry_run"
    echo ""
    echo "  Categories to start: ${categories_to_start[*]}"
    echo ""
}

run_startup_process() {
    local -a categories_to_start
    categories_to_start=($(get_startup_categories))
    
    if [[ ${#categories_to_start[@]} -eq 0 ]]; then
        print_status "warning" "No categories selected for startup"
        return 0
    fi

... (file truncated - showing first 500 of 593 lines)
```

### scripts/stop-services.sh
```
#!/bin/zsh

# =============================================================================
# MICROSERVICES SHUTDOWN SCRIPT
# =============================================================================
# Enhanced service shutdown with selective control, cleanup options,
# and graceful dependency handling

# Source the central configuration
. "$(dirname "$0")/config.sh"

# =============================================================================
# SCRIPT OPTIONS & DEFAULTS
# =============================================================================

# Default values
opt_use_sudo="$DEFAULT_SUDO"
opt_show_errors=false
opt_categories_only=""
opt_exclude_categories=""
opt_remove_images=false
opt_remove_volumes=false
opt_remove_networks=false
opt_force_stop=false
opt_graceful_timeout=30
opt_dry_run=false
opt_verbose=false
opt_cleanup_orphans=true

# =============================================================================
# USAGE & HELP
# =============================================================================

show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

DESCRIPTION:
    Enhanced service shutdown script with selective control, cleanup options,
    and graceful dependency handling. Stops services in reverse dependency order.

OPTIONS:
    -s, --sudo              Use sudo for container commands
    -e, --errors            Show detailed error messages
    -c, --categories LIST   Stop only specific categories (comma-separated)
    -x, --exclude LIST      Exclude specific categories (comma-separated)
    -i, --remove-images     Remove all container images after stopping
    -v, --remove-volumes    Remove all volumes (WARNING: destroys data)
    -n, --remove-networks   Remove created networks
    -f, --force             Force stop containers (SIGKILL)
    -t, --timeout SECONDS   Graceful shutdown timeout (default: 30)
    -d, --dry-run           Show what would be stopped without execution
    --verbose               Show detailed progress information
    --no-orphans           Skip cleanup of orphaned containers
    -h, --help              Show this help message

CATEGORIES (stopped in reverse dependency order):
    proxy         - Nginx Proxy Manager
    project       - Gitea repository management
    mail          - Mailpit email testing
    ai-services   - Langflow, n8n automation platforms
    analytics     - Elasticsearch, Kibana, Logstash, Grafana, Prometheus, Matomo
    backend       - .NET, Go, Node.js, PHP, Python applications
    db-tools      - Adminer, phpMyAdmin, Mongo Express, Metabase, NocoDB, pgAdmin
    database      - MariaDB, MySQL, PostgreSQL, MongoDB, Redis

CLEANUP OPTIONS:
    --remove-images    Remove all downloaded container images
    --remove-volumes   Remove all data volumes (DESTROYS ALL DATA)
    --remove-networks  Remove created Docker networks

EXAMPLES:
    $0                                 # Stop all services gracefully
    $0 -c backend,analytics            # Stop only backend and analytics
    $0 -x database                     # Stop all except database services
    $0 -f -t 10                        # Force stop with 10s timeout
    $0 -i -v                           # Stop and cleanup images/volumes
    $0 -d --verbose                    # Dry run with detailed output
    $0 --remove-volumes                # Stop all and remove data volumes

SHUTDOWN ORDER:
    Services are stopped in reverse dependency order to prevent
    connection errors and ensure graceful shutdown.

NOTES:
    - Use --remove-volumes with extreme caution (destroys all data)
    - Force stop may cause data corruption in databases
    - Dry run shows exactly what would be executed
    - Orphan cleanup removes containers not managed by compose files
EOF
}

# =============================================================================
# ARGUMENT PARSING
# =============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--sudo)
                opt_use_sudo=true
                shift
                ;;
            -e|--errors)
                opt_show_errors=true
                shift
                ;;
            -c|--categories)
                if [[ -n "$2" && "$2" != -* ]]; then
                    opt_categories_only="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a comma-separated list of categories"
                fi
                ;;
            -x|--exclude)
                if [[ -n "$2" && "$2" != -* ]]; then
                    opt_exclude_categories="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a comma-separated list of categories"
                fi
                ;;
            -i|--remove-images)
                opt_remove_images=true
                shift
                ;;
            -v|--remove-volumes)
                opt_remove_volumes=true
                shift
                ;;
            -n|--remove-networks)
                opt_remove_networks=true
                shift
                ;;
            -f|--force)
                opt_force_stop=true
                shift
                ;;
            -t|--timeout)
                if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                    opt_graceful_timeout="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a numeric timeout value"
                fi
                ;;
            -d|--dry-run)
                opt_dry_run=true
                opt_verbose=true
                shift
                ;;
            --verbose)
                opt_verbose=true
                shift
                ;;
            --no-orphans)
                opt_cleanup_orphans=false
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                handle_error "Unknown option: $1. Use -h for help."
                ;;
        esac
    done
}

# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

validate_categories() {
    if [[ -n "$opt_categories_only" ]]; then
        local -a requested_categories
        requested_categories=(${(s:,:)opt_categories_only})
        
        for category in "${requested_categories[@]}"; do
            if [[ -z "${SERVICE_CATEGORIES[$category]}" ]]; then
                handle_error "Invalid category: $category. Available: ${(k)SERVICE_CATEGORIES}"
            fi
        done
        
        print_status "info" "Will stop categories: ${requested_categories[*]}"
    fi
    
    if [[ -n "$opt_exclude_categories" ]]; then
        local -a excluded_categories
        excluded_categories=(${(s:,:)opt_exclude_categories})
        
        for category in "${excluded_categories[@]}"; do
            if [[ -z "${SERVICE_CATEGORIES[$category]}" ]]; then
                handle_error "Invalid exclude category: $category. Available: ${(k)SERVICE_CATEGORIES}"
            fi
        done
        
        print_status "info" "Will exclude categories: ${excluded_categories[*]}"
    fi
}

validate_destructive_operations() {
    if [[ "$opt_remove_volumes" == "true" && "$opt_dry_run" == "false" ]]; then
        print_status "warning" "WARNING: --remove-volumes will destroy ALL data!"
        echo "This will permanently delete:"
        echo "  - Database data (PostgreSQL, MySQL, MongoDB)"
        echo "  - Application files and configurations"
        echo "  - Log files and user uploads"
        echo ""
        
        if [[ -t 0 ]]; then  # Check if running interactively
            read "response?Are you absolutely sure? Type 'DELETE ALL DATA' to confirm: "
            if [[ "$response" != "DELETE ALL DATA" ]]; then
                print_status "info" "Volume removal cancelled"
                opt_remove_volumes=false
            fi
        else
            print_status "error" "Non-interactive mode: volume removal requires explicit confirmation"
            exit 1
        fi
    fi
}

# =============================================================================
# SERVICE MANAGEMENT FUNCTIONS
# =============================================================================

get_shutdown_categories() {
    local -a categories_to_stop
    
    if [[ -n "$opt_categories_only" ]]; then
        local -a requested_categories
        requested_categories=(${(s:,:)opt_categories_only})
        
        # Reverse the startup order and filter
        local -a reversed_order
        for ((i = ${#SERVICE_STARTUP_ORDER[@]}; i > 0; i--)); do
            reversed_order+=("${SERVICE_STARTUP_ORDER[i]}")
        done
        
        for category in "${reversed_order[@]}"; do
            if [[ " ${requested_categories[*]} " =~ " $category " ]]; then
                categories_to_stop+=("$category")
            fi
        done
    else
        # Reverse the startup order for shutdown
        for ((i = ${#SERVICE_STARTUP_ORDER[@]}; i > 0; i--)); do
            categories_to_stop+=("${SERVICE_STARTUP_ORDER[i]}")
        done
    fi
    
    # Remove excluded categories
    if [[ -n "$opt_exclude_categories" ]]; then
        local -a excluded_categories
        excluded_categories=(${(s:,:)opt_exclude_categories})
        
        local -a filtered_categories
        for category in "${categories_to_stop[@]}"; do
            if [[ ! " ${excluded_categories[*]} " =~ " $category " ]]; then
                filtered_categories+=("$category")
            fi
        done
        categories_to_stop=("${filtered_categories[@]}")
    fi
    
    echo "${categories_to_stop[@]}"
}

stop_service_file() {
    local service_file="$1"
    local category="$2"
    local full_path="$(resolve_service_path "$service_file" "$category")"
    
    if [[ ! -f "$full_path" ]]; then
        if [[ "$opt_verbose" == "true" ]]; then
            print_status "warning" "Service file not found: $service_file"
        fi
        return 1
    fi
    
    local service_name="${service_file%.yml}"
    
    if [[ "$opt_verbose" == "true" ]]; then
        print_status "step" "Stopping $service_name from $service_file..."
    fi
    
    # Build compose command
    local compose_args=("-f" "$full_path" "down")
    
    # Add timeout if not default
    if [[ "$opt_graceful_timeout" != "30" ]]; then
        compose_args+=("--timeout" "$opt_graceful_timeout")
    fi
    
    # Add remove orphans
    if [[ "$opt_cleanup_orphans" == "true" ]]; then
        compose_args+=("--remove-orphans")
    fi
    
    # Execute or show dry run
    if [[ "$opt_dry_run" == "true" ]]; then
        echo "DRY RUN: $COMPOSE_CMD ${compose_args[*]}"
        return 0
    fi
    
    # Execute the command
    if eval "$COMPOSE_CMD ${compose_args[*]} $ERROR_REDIRECT"; then
        if [[ "$opt_verbose" == "true" ]]; then
            print_status "success" "$service_name stopped successfully"
        fi
        return 0
    else
        print_status "warning" "Failed to stop $service_name (may already be stopped)"
        return 1
    fi
}

stop_category() {
    local category="$1"
    local service_files
    service_files=$(get_service_files "$category")
    
    if [[ -z "$service_files" ]]; then
        print_status "warning" "No services found for category: $category"
        return 0
    fi
    
    print_status "step" "Stopping $category services..."
    
    local -a files
    files=(${=service_files})
    
    local failed=0
    for service_file in "${files[@]}"; do
        if ! stop_service_file "$service_file" "$category"; then
            ((failed++))
        fi
    done
    
    if [[ $failed -eq 0 ]]; then
        print_status "success" "$category services stopped successfully"
    else
        print_status "warning" "$failed service(s) in $category had issues stopping"
    fi
}

force_stop_containers() {
    if [[ "$opt_force_stop" == "false" || "$opt_dry_run" == "true" ]]; then
        return 0
    fi
    
    print_status "step" "Force stopping any remaining containers..."
    
    # Get all running containers related to our services
    local containers
    containers=$(eval "$CONTAINER_CMD ps -q --filter 'network=$NETWORK_NAME' $ERROR_REDIRECT" || echo "")
    
    if [[ -n "$containers" ]]; then
        local container_list
        container_list=(${(f)containers})
        
        for container in "${container_list[@]}"; do
            if [[ "$opt_verbose" == "true" ]]; then
                local name
                name=$(eval "$CONTAINER_CMD inspect --format='{{.Name}}' $container 2>/dev/null" | sed 's/^///' || echo "unknown")
                print_status "warning" "Force stopping container: $name"
            fi
            
            eval "$CONTAINER_CMD kill $container $ERROR_REDIRECT" || true
        done
        
        print_status "success" "Force stopped remaining containers"
    else
        print_status "info" "No containers to force stop"
    fi
}

# =============================================================================
# CLEANUP FUNCTIONS
# =============================================================================

cleanup_images() {
    if [[ "$opt_remove_images" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Removing container images..."
    
    if [[ "$opt_dry_run" == "true" ]]; then
        echo "DRY RUN: $CONTAINER_CMD rmi \$($CONTAINER_CMD images -q)"
        return 0
    fi
    
    local images
    images=$(eval "$CONTAINER_CMD images -q $ERROR_REDIRECT" || echo "")
    
    if [[ -n "$images" ]]; then
        local image_list
        image_list=(${(f)images})
        
        local removed=0
        for image in "${image_list[@]}"; do
            if eval "$CONTAINER_CMD rmi -f $image $ERROR_REDIRECT"; then
                ((removed++))
            fi
        done
        
        print_status "success" "Removed $removed container images"
    else
        print_status "info" "No images to remove"
    fi
}

cleanup_volumes() {
    if [[ "$opt_remove_volumes" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Removing data volumes..."
    
    if [[ "$opt_dry_run" == "true" ]]; then
        echo "DRY RUN: $CONTAINER_CMD volume rm \$($CONTAINER_CMD volume ls -q)"
        return 0
    fi
    
    local volumes
    volumes=$(eval "$CONTAINER_CMD volume ls -q $ERROR_REDIRECT" || echo "")
    
    if [[ -n "$volumes" ]]; then
        local volume_list
        volume_list=(${(f)volumes})
        
        local removed=0
        for volume in "${volume_list[@]}"; do
            if eval "$CONTAINER_CMD volume rm -f $volume $ERROR_REDIRECT"; then
                ((removed++))
            fi
        done
        
        print_status "success" "Removed $removed data volumes"
    else
        print_status "info" "No volumes to remove"
    fi
}

cleanup_networks() {
    if [[ "$opt_remove_networks" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Removing networks..."
    
    if [[ "$opt_dry_run" == "true" ]]; then
        echo "DRY RUN: $CONTAINER_CMD network rm $NETWORK_NAME"
        return 0
    fi
    
    # Remove our specific network
    if eval "$CONTAINER_CMD network exists $NETWORK_NAME $ERROR_REDIRECT"; then
        if eval "$CONTAINER_CMD network rm $NETWORK_NAME $ERROR_REDIRECT"; then
            print_status "success" "Removed network: $NETWORK_NAME"
        else
            print_status "warning" "Failed to remove network: $NETWORK_NAME"
        fi
    else
        print_status "info" "Network $NETWORK_NAME does not exist"
    fi
    
    # Cleanup unused networks
    eval "$CONTAINER_CMD network prune -f $ERROR_REDIRECT" || true
}

cleanup_system() {
    if [[ "$opt_dry_run" == "true" ]]; then
        echo "DRY RUN: $CONTAINER_CMD system prune -f"
        return 0
    fi
    
    print_status "step" "Cleaning up system resources..."
    
    # Prune unused containers, networks, and build cache
    eval "$CONTAINER_CMD system prune -f $ERROR_REDIRECT" || true
    
    print_status "success" "System cleanup completed"
}

# =============================================================================
# MAIN EXECUTION FUNCTIONS
# =============================================================================

show_shutdown_summary() {
    local -a categories_to_stop
    categories_to_stop=($(get_shutdown_categories))
    
    print_status "info" "Service Shutdown Summary:"
    echo "  Container Runtime: $CONTAINER_RUNTIME"
    echo "  Use Sudo: $opt_use_sudo"

... (file truncated - showing first 500 of 602 lines)
```

### scripts/trust-host.sh
```
#!/bin/zsh

# =============================================================================
# SSL CERTIFICATE TRUST INSTALLATION SCRIPT
# =============================================================================
# Cross-platform SSL certificate trust installation for all operating systems
# Supports Linux, macOS, Windows, and WSL with automatic detection

# Source the central configuration
. "$(dirname "$0")/config.sh"

# =============================================================================
# SCRIPT OPTIONS & DEFAULTS
# =============================================================================

# Default values
opt_use_sudo="$DEFAULT_SUDO"
opt_show_errors=false
opt_copy_to_windows=true
opt_install_firefox=false
opt_install_chrome=false
opt_install_system=true
opt_backup_existing=true
opt_cert_name="wildcard.test"
opt_export_formats=false
opt_verify_installation=true

# Certificate paths
CERT_CONTAINER_PATH="$SSL_CERT_DIR/fullchain.pem"
TEMP_CERT_DIR="/tmp/ssl-trust-$$"

# OS-specific paths - PROPERLY USED IN FUNCTIONS
declare -A TRUST_PATHS=(
    [arch_system]="/etc/ca-certificates/trust-source/anchors"
    [arch_update]="trust extract-compat"
    [ubuntu_system]="/usr/local/share/ca-certificates"
    [ubuntu_update]="update-ca-certificates"
    [rhel_system]="/etc/pki/ca-trust/source/anchors"
    [rhel_update]="update-ca-trust"
    [macos_system]="/System/Library/Keychains/SystemRootCertificates.keychain"
    [macos_login]="/Library/Keychains/System.keychain"
    [windows_user]="Cert:\\CurrentUser\\Root"
    [windows_machine]="Cert:\\LocalMachine\\Root"
)

# =============================================================================
# USAGE & HELP
# =============================================================================

show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

DESCRIPTION:
    Cross-platform SSL certificate trust installation script. Automatically
    detects your operating system and installs SSL certificates in the
    appropriate trust stores for browsers and system applications.

OPTIONS:
    -s, --sudo              Use sudo for system operations
    -e, --errors            Show detailed error messages
    -w, --windows           Copy certificate to Windows (WSL only)
    -f, --firefox           Install certificate for Firefox
    -c, --chrome            Install certificate for Chrome/Chromium
    --no-system             Skip system trust store installation
    --no-backup             Skip backing up existing certificates
    -n, --name NAME         Certificate name (default: wildcard.test)
    -x, --export            Export certificates in multiple formats
    --no-verify             Skip installation verification
    -h, --help              Show this help message

SUPPORTED PLATFORMS:
    Linux (Ubuntu/Debian) - system ca-certificates
    Linux (RHEL/CentOS)   - ca-trust anchors
    Linux (Arch)          - ca-certificates-utils
    macOS                 - Keychain Access
    Windows               - Certificate Store (via PowerShell)
    WSL                   - Linux + Windows integration

BROWSER SUPPORT:
    Chrome/Edge           - Uses system trust store automatically
    Firefox               - Requires separate installation (--firefox)
    Safari                - Uses system trust store (macOS)

EXAMPLES:
    $0                              # Auto-detect OS and install
    $0 -w                          # WSL: Install on Linux + copy to Windows
    $0 -f -c                       # Install for Firefox and Chrome
    $0 --no-system -f              # Only Firefox, skip system
    $0 -s -x                       # Use sudo, export multiple formats
    $0 --name custom.local         # Custom certificate name

INSTALLATION LOCATIONS:
    Arch Linux: /etc/ca-certificates/trust-source/anchors/
    Ubuntu:     /usr/local/share/ca-certificates/
    macOS:      System Keychain
    Windows:    LocalMachine\\Root (requires admin)
    Firefox:    Browser-specific certificate store

NOTES:
    - System installation usually requires administrator privileges
    - Firefox uses its own certificate store separate from system
    - Windows installation requires PowerShell with admin rights
    - Verification tests actual HTTPS connections to confirm installation
EOF
}

# =============================================================================
# ARGUMENT PARSING
# =============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--sudo)
                opt_use_sudo=true
                shift
                ;;
            -e|--errors)
                opt_show_errors=true
                shift
                ;;
            -w|--windows)
                opt_copy_to_windows=true
                shift
                ;;
            -f|--firefox)
                opt_install_firefox=true
                shift
                ;;
            -c|--chrome)
                opt_install_chrome=true
                shift
                ;;
            --no-system)
                opt_install_system=false
                shift
                ;;
            --no-backup)
                opt_backup_existing=false
                shift
                ;;
            -n|--name)
                if [[ -n "$2" && "$2" != -* ]]; then
                    opt_cert_name="$2"
                    shift 2
                else
                    handle_error "Option $1 requires a certificate name"
                fi
                ;;
            -x|--export)
                opt_export_formats=true
                shift
                ;;
            --no-verify)
                opt_verify_installation=false
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                handle_error "Unknown option: $1. Use -h for help."
                ;;
        esac
    done
}

# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

validate_environment() {
    print_status "step" "Validating environment and detecting OS..."
    
    # Check if nginx container exists and is running
    if ! eval "$CONTAINER_CMD container exists nginx-proxy-manager $ERROR_REDIRECT"; then
        handle_error "nginx-proxy-manager container not found. Run setup-ssl.sh first."
    fi
    
    local container_status
    container_status=$(eval "$CONTAINER_CMD inspect --format='{{.State.Status}}' nginx-proxy-manager 2>/dev/null" || echo "unknown")
    
    if [[ "$container_status" != "running" ]]; then
        handle_error "nginx-proxy-manager container is not running"
    fi
    
    # Check if certificate exists in container
    if ! eval "$CONTAINER_CMD exec nginx-proxy-manager test -f $CERT_CONTAINER_PATH $ERROR_REDIRECT"; then
        handle_error "SSL certificate not found in container. Run setup-ssl.sh first."
    fi
    
    print_status "success" "Environment validation passed"
    print_status "info" "Detected OS: $OS_TYPE"
}

detect_linux_distribution() {
    if [[ "$OS_TYPE" != "linux" && "$OS_TYPE" != "wsl" ]]; then
        return 0
    fi
    
    if command -v lsb_release >/dev/null 2>&1; then
        LINUX_DISTRO=$(lsb_release -si 2>/dev/null | tr '[:upper:]' '[:lower:]')
    elif [[ -f /etc/os-release ]]; then
        LINUX_DISTRO=$(grep '^ID=' /etc/os-release | cut -d'=' -f2 | tr -d '"' | tr '[:upper:]' '[:lower:]')
    elif [[ -f /etc/arch-release ]]; then
        LINUX_DISTRO="arch"
    elif [[ -f /etc/redhat-release ]]; then
        LINUX_DISTRO="rhel"
    else
        LINUX_DISTRO="unknown"
    fi
    
    print_status "info" "Linux distribution: $LINUX_DISTRO"
}

check_prerequisites() {
    case "$OS_TYPE" in
        "linux"|"wsl")
            detect_linux_distribution
            
            case "$LINUX_DISTRO" in
                "arch"|"manjaro")
                    if ! command -v trust >/dev/null 2>&1; then
                        print_status "warning" "ca-certificates-utils not found. Installing..."
                        if [[ "$opt_use_sudo" == "true" ]]; then
                            sudo pacman -S --noconfirm ca-certificates-utils || handle_error "Failed to install ca-certificates-utils"
                        else
                            handle_error "ca-certificates-utils package not installed. Run: sudo pacman -S ca-certificates-utils"
                        fi
                    fi
                    ;;
                "ubuntu"|"debian")
                    if ! command -v update-ca-certificates >/dev/null 2>&1; then
                        handle_error "ca-certificates package not installed. Run: apt install ca-certificates"
                    fi
                    ;;
                "rhel"|"centos"|"fedora")
                    if ! command -v update-ca-trust >/dev/null 2>&1; then
                        handle_error "ca-certificates package not installed. Run: yum install ca-certificates"
                    fi
                    ;;
            esac
            ;;
        "macos")
            if ! command -v security >/dev/null 2>&1; then
                handle_error "macOS security command not available"
            fi
            ;;
    esac
}

# =============================================================================
# CERTIFICATE PREPARATION FUNCTIONS
# =============================================================================

prepare_certificate_files() {
    print_status "step" "Preparing certificate files..."
    
    # Create temporary directory
    mkdir -p "$TEMP_CERT_DIR"
    
    # Copy certificate from container
    eval "$CONTAINER_CMD cp nginx-proxy-manager:$CERT_CONTAINER_PATH $TEMP_CERT_DIR/cert.pem $ERROR_REDIRECT"
    check_status "Failed to copy certificate from container"
    
    # Verify certificate
    if ! openssl x509 -in "$TEMP_CERT_DIR/cert.pem" -noout -text >/dev/null 2>&1; then
        handle_error "Invalid certificate file"
    fi
    
    print_status "success" "Certificate files prepared"
}

backup_existing_certificates() {
    if [[ "$opt_backup_existing" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Backing up existing certificates..."
    
    local backup_dir="$PROJECT_ROOT/ssl-backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$backup_dir"
    
    case "$LINUX_DISTRO" in
        "arch"|"manjaro")
            local cert_path="${TRUST_PATHS[arch_system]}/$opt_cert_name.crt"
            [[ -f "$cert_path" ]] && cp "$cert_path" "$backup_dir/"
            ;;
        "ubuntu"|"debian")
            local cert_path="${TRUST_PATHS[ubuntu_system]}/$opt_cert_name.crt"
            [[ -f "$cert_path" ]] && cp "$cert_path" "$backup_dir/"
            ;;
        "rhel"|"centos"|"fedora")
            local cert_path="${TRUST_PATHS[rhel_system]}/$opt_cert_name.crt"
            [[ -f "$cert_path" ]] && cp "$cert_path" "$backup_dir/"
            ;;
    esac
    
    print_status "success" "Existing certificates backed up to: $backup_dir"
}

# =============================================================================
# PLATFORM-SPECIFIC INSTALLATION FUNCTIONS
# =============================================================================

install_linux_system_trust() {
    if [[ "$opt_install_system" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Installing certificate to Linux system trust store..."
    
    case "$LINUX_DISTRO" in
        "arch"|"manjaro")
            local cert_path="${TRUST_PATHS[arch_system]}/$opt_cert_name.crt"
            local update_cmd="${TRUST_PATHS[arch_update]}"
            
            print_status "info" "Installing to Arch Linux trust store: $cert_path"
            
            if [[ "$opt_use_sudo" == "true" ]]; then
                sudo cp "$TEMP_CERT_DIR/cert.pem" "$cert_path"
                sudo chmod 644 "$cert_path"
                sudo $update_cmd
            else
                cp "$TEMP_CERT_DIR/cert.pem" "$cert_path" 2>/dev/null || {
                    print_status "error" "Permission denied. Try with --sudo option"
                    return 1
                }
                $update_cmd
            fi
            ;;
            
        "ubuntu"|"debian")
            local cert_path="${TRUST_PATHS[ubuntu_system]}/$opt_cert_name.crt"
            local update_cmd="${TRUST_PATHS[ubuntu_update]}"
            
            print_status "info" "Installing to Ubuntu/Debian trust store: $cert_path"
            
            if [[ "$opt_use_sudo" == "true" ]]; then
                sudo cp "$TEMP_CERT_DIR/cert.pem" "$cert_path"
                sudo chmod 644 "$cert_path"
                sudo $update_cmd
            else
                cp "$TEMP_CERT_DIR/cert.pem" "$cert_path" 2>/dev/null || {
                    print_status "error" "Permission denied. Try with --sudo option"
                    return 1
                }
                $update_cmd
            fi
            ;;
            
        "rhel"|"centos"|"fedora")
            local cert_path="${TRUST_PATHS[rhel_system]}/$opt_cert_name.crt"
            local update_cmd="${TRUST_PATHS[rhel_update]}"
            
            print_status "info" "Installing to RHEL/CentOS trust store: $cert_path"
            
            if [[ "$opt_use_sudo" == "true" ]]; then
                sudo cp "$TEMP_CERT_DIR/cert.pem" "$cert_path"
                sudo chmod 644 "$cert_path"
                sudo $update_cmd
            else
                cp "$TEMP_CERT_DIR/cert.pem" "$cert_path" 2>/dev/null || {
                    print_status "error" "Permission denied. Try with --sudo option"
                    return 1
                }
                $update_cmd
            fi
            ;;
            
        *)
            print_status "warning" "Unsupported Linux distribution: $LINUX_DISTRO"
            return 1
            ;;
    esac
    
    print_status "success" "Certificate installed to Linux system trust store"
}

install_macos_system_trust() {
    if [[ "$opt_install_system" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Installing certificate to macOS system trust store..."
    
    # Import certificate to system keychain
    if security add-trusted-cert -d -r trustRoot -k "${TRUST_PATHS[macos_login]}" "$TEMP_CERT_DIR/cert.pem" 2>/dev/null; then
        print_status "success" "Certificate installed to macOS system trust store"
    else
        # Try with sudo
        if [[ "$opt_use_sudo" == "true" ]]; then
            if sudo security add-trusted-cert -d -r trustRoot -k "${TRUST_PATHS[macos_login]}" "$TEMP_CERT_DIR/cert.pem"; then
                print_status "success" "Certificate installed to macOS system trust store (with sudo)"
            else
                print_status "error" "Failed to install certificate to macOS trust store"
                return 1
            fi
        else
            print_status "error" "Permission denied. Try with --sudo option"
            return 1
        fi
    fi
}

install_wsl2_windows_trust() {
    if [[ "$opt_copy_to_windows" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Preparing certificate for Windows installation (WSL2)..."
    
    # Copy certificate to Windows accessible location
    local windows_cert_path="/mnt/c/temp/$opt_cert_name.crt"
    mkdir -p "/mnt/c/temp"
    cp "$TEMP_CERT_DIR/cert.pem" "$windows_cert_path"
    
    # Generate PowerShell script for certificate installation
    cat > "/mnt/c/temp/install-cert.ps1" << EOF
param(
    [string]\$CertPath = "C:\\temp\\$opt_cert_name.crt"
)

Write-Host "Installing SSL certificate: \$CertPath" -ForegroundColor Yellow

try {
    # Check if certificate file exists
    if (-not (Test-Path \$CertPath)) {
        throw "Certificate file not found: \$CertPath"
    }

    # Load the certificate
    \$cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2(\$CertPath)
    Write-Host "Certificate loaded: \$(\$cert.Subject)" -ForegroundColor Green
    
    # Open the LocalMachine Root store
    \$store = New-Object System.Security.Cryptography.X509Certificates.X509Store([System.Security.Cryptography.X509Certificates.StoreName]::Root, [System.Security.Cryptography.X509Certificates.StoreLocation]::LocalMachine)
    \$store.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::ReadWrite)
    
    # Add the certificate
    \$store.Add(\$cert)
    \$store.Close()
    
    Write-Host "Certificate installed successfully to Windows trust store!" -ForegroundColor Green
    Write-Host "You can now access https://nginx.test and other services without SSL warnings." -ForegroundColor Cyan
    
    # Test the installation
    Write-Host "Testing certificate installation..." -ForegroundColor Yellow
    \$installedCerts = Get-ChildItem -Path Cert:\\LocalMachine\\Root | Where-Object { \$_.Subject -like "*wildcard.test*" -or \$_.Subject -like "*\*.test*" }
    if (\$installedCerts) {
        Write-Host "Certificate verification: PASSED" -ForegroundColor Green
        \$installedCerts | ForEach-Object { Write-Host "Found: \$(\$_.Subject)" -ForegroundColor Cyan }
    } else {
        Write-Host "Certificate verification: FAILED" -ForegroundColor Red
    }
    
    exit 0
} catch {
    Write-Error "Failed to install certificate: \$_"
    Write-Host "Try running PowerShell as Administrator" -ForegroundColor Yellow
    exit 1
}
EOF
    
    print_status "success" "Certificate prepared for Windows installation"
    echo ""
    print_status "info" "Windows Installation Instructions:"
    echo "  1. Open PowerShell as Administrator in Windows"
    echo "  2. Run: PowerShell -ExecutionPolicy Bypass -File C:\\temp\\install-cert.ps1"
    echo ""
    print_status "info" "Alternative Manual Installation:"
    echo "  1. Navigate to C:\\temp\\$opt_cert_name.crt in Windows Explorer"
    echo "  2. Double-click the certificate file"
    echo "  3. Click 'Install Certificate'"
    echo "  4. Select 'Local Machine' and click 'Next'"
    echo "  5. Select 'Place all certificates in the following store'"
    echo "  6. Click 'Browse' and select 'Trusted Root Certification Authorities'"
    echo "  7. Click 'Next' and 'Finish'"
}

install_firefox_trust() {
    if [[ "$opt_install_firefox" == "false" ]]; then
        return 0
    fi
    
    print_status "step" "Installing certificate for Firefox..."
    
    # Find Firefox profiles
    local firefox_dir=""
    case "$OS_TYPE" in
        "linux"|"wsl")
            firefox_dir="$HOME/.mozilla/firefox"
            ;;
        "macos")
            firefox_dir="$HOME/Library/Application Support/Firefox/Profiles"
            ;;
        "windows")
            firefox_dir="/mnt/c/Users/$USER/AppData/Roaming/Mozilla/Firefox/Profiles"

... (file truncated - showing first 500 of 759 lines)
```

### scripts/wordpress/install-starred-repos.sh
```
#!/bin/zsh
WWW_DIR="/var/www"

set -a  # Automatically export all variables
source $WWW_DIR/.env
set +a  # Stop automatically exporting variables

# Define variables
SITE_TITLE="Playground"
DB_NAME="playground"

DB_USER="${MARIADB_USER}"
DB_PASS="${MARIADB_PASSWORD}"
DB_HOST="${MARIADB_HOST}"
SITE_DIR="$WWW_DIR/html/$DB_NAME"
WP_DIR="$SITE_DIR/public"
SITE_URL="$DB_NAME.test"
ADMIN_USER="${ADMIN_USER}"
ADMIN_PASSWORD="${ADMIN_PASSWORD}"
ADMIN_EMAIL="${ADMIN_EMAIL}"

# GitHub repositories for plugins and themes
PLUGIN_REPOS=(
    "https://github.com/pronamic/gravityforms.git"
    "https://github.com/pronamic/advanced-custom-fields-pro.git"
    "https://github.com/pronamic/woocommerce-subscriptions.git"
    "https://github.com/pronamic/facetwp.git"
)

# Install plugins
cd "$WP_DIR/wp-content/plugins" || exit
for PLUGIN_REPO in "${PLUGIN_REPOS[@]}"; do
    PLUGIN_DIR=$(basename "$PLUGIN_REPO" .git)
    git clone "$PLUGIN_REPO" || { echo "Failed to clone plugin $PLUGIN_REPO"; }
    wp plugin activate "$PLUGIN_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate plugin $PLUGIN_DIR"; }
done

echo "Starred Repos Installed and Activated"```

### scripts/wordpress/install-wp-bare.sh
```
#!/bin/zsh
WWW_DIR="/var/www"

set -a  # Automatically export all variables
source $WWW_DIR/.env
set +a  # Stop automatically exporting variables

# Define variables
SITE_TITLE="WP Bare"
DB_NAME="wpbare"

DB_USER="${MARIADB_USER}"
DB_PASS="${MARIADB_PASSWORD}"
DB_HOST="${MARIADB_HOST}"
SITE_DIR="$WWW_DIR/html/$DB_NAME"
WP_DIR="$SITE_DIR/public"
SITE_URL="$DB_NAME.test"
ADMIN_USER="${ADMIN_USER}"
ADMIN_PASSWORD="${ADMIN_PASSWORD}"
ADMIN_EMAIL="${ADMIN_EMAIL}"

# Ensure parent directory exists
mkdir -p "$SITE_DIR"

# Download WordPress
wp core download --path="$WP_DIR" --allow-root || { echo "Failed to download WordPress"; }

# Create the wp-config.php file
wp config create --dbname="$DB_NAME" --dbuser="$DB_USER" --dbpass="$DB_PASS" --dbhost="$DB_HOST" --path="$WP_DIR" --allow-root || { echo "Failed to create wp-config.php"; }

# Set debugging
wp config set WP_DEBUG false --raw --path="$WP_DIR" --allow-root || { echo "Failed to set WP_DEBUG";}

# Create the database
wp db create --path="$WP_DIR" --allow-root || { echo "Failed to create database"; }

# Install WordPress
wp core install --url="$SITE_URL" --title="$SITE_TITLE" --admin_user="$ADMIN_USER" --admin_password="$ADMIN_PASSWORD" --admin_email="$ADMIN_EMAIL" --path="$WP_DIR" --allow-root || { echo "Failed to install WordPress"; }

# Set month- and year-based folders
wp option update uploads_use_yearmonth_folders 0 --path="$WP_DIR" --allow-root || { echo "Failed to set upload folder";}

echo "WordPress installed successfully!"

# Delete default post and page
wp post delete 1 --force --path="$WP_DIR" --allow-root || echo "Post ID 1 not found."
wp post delete 2 --force --path="$WP_DIR" --allow-root || echo "Post ID 2 not found."
wp post delete 3 --force --path="$WP_DIR" --allow-root || echo "Post ID 3 not found."

# Delete default plugins
wp plugin delete akismet hello --path="$WP_DIR" --allow-root || echo "No default plugins found to delete."

# GitHub repositories for plugins and themes
PLUGIN_REPOS=(
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/all-in-one-wp-migration.git"
)

THEME_REPOS=(
    # "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makerstarter.git"
)

DEFAULT_THEMES=(
    "twentytwentythree"
    "twentytwentyfour"
    # "twentytwentyfive"
)

# Install plugins
cd "$WP_DIR/wp-content/plugins" || exit
for PLUGIN_REPO in "${PLUGIN_REPOS[@]}"; do
    PLUGIN_DIR=$(basename "$PLUGIN_REPO" .git)
    git clone "$PLUGIN_REPO" || { echo "Failed to clone plugin $PLUGIN_REPO"; }
    wp plugin activate "$PLUGIN_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate plugin $PLUGIN_DIR"; }
done

# Install themes
cd "$WP_DIR/wp-content/themes" || exit
for THEME_REPO in "${THEME_REPOS[@]}"; do
    THEME_DIR=$(basename "$THEME_REPO" .git)
    git clone "$THEME_REPO" || { echo "Failed to clone theme $THEME_REPO"; }
    wp theme activate "$THEME_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate theme $THEME_DIR"; }
done

# Delete themes
cd "$WP_DIR/wp-content/themes" || exit
for THEME in "${DEFAULT_THEMES[@]}"; do
    wp theme delete "$THEME" --path="$WP_DIR" --allow-root || { echo "Failed to delete theme $THEME_DIR"; }
done

# Create necessary directories and set permissions for All in One WP Migration
AI1WM_BACKUPS_DIR="$WP_DIR/wp-content/ai1wm-backups"
mkdir -p "$AI1WM_BACKUPS_DIR" && echo "AI1WM Backup Folder Created at $AI1WM_BACKUPS_DIR" || { echo "Failed to create $AI1WM_BACKUPS_DIR"; }
chmod -R 777 "$AI1WM_BACKUPS_DIR" && echo "AI1WM Backup Folder Permissions set (777)" || { echo "Failed to set permissions on $AI1WM_BACKUPS_DIR"; }

AI1WM_STORAGE_DIR="$WP_DIR/wp-content/plugins/all-in-one-wp-migration/storage"
mkdir -p "$AI1WM_STORAGE_DIR" && echo "AI1WM Storage Folder Created at $AI1WM_STORAGE_DIR" || { echo "Failed to create $AI1WM_STORAGE_DIR"; exit 1; }
chmod -R 777 "$AI1WM_STORAGE_DIR" && echo "AI1WM Storage Folder Permissions set (777)" || { echo "Failed to set permissions on $AI1WM_STORAGE_DIR"; exit 1; }

# Uploads Directory
UPLOADS_DIR="$WP_DIR/wp-content/uploads"
mkdir -p "$UPLOADS_DIR" && echo "Uploads Folder Created at $UPLOADS_DIR" || { echo "Failed to create $UPLOADS_DIR"; exit 1; }
chmod -R 777 "$UPLOADS_DIR" && echo "Uploads Folder Permissions set (777)" || { echo "Failed to set permissions on $UPLOADS_DIR"; exit 1; }

# Themes Directory
THEMES_DIR="$WP_DIR/wp-content/themes"
chmod -R 777 "$THEMES_DIR" && echo "Themes Folder Permissions set (777)" || { echo "Failed to set permissions on $THEMES_DIR"; exit 1; }

# Plugins Directory
PLUGINS_DIR="$WP_DIR/wp-content/plugins"
chmod -R 777 "$PLUGINS_DIR" && echo "Plugins Folder Permissions set (777)" || { echo "Failed to set permissions on $PLUGINS_DIR"; exit 1; }

# Set permalink structure
wp rewrite structure '%postname%' --path="$WP_DIR" --allow-root || { echo "Failed to set permalink structure"; }

# Set permissions
sudo chown -R www-data:www-data /var/www/html/
sudo chmod -R 777 /var/www/html/

# Send installation summary email
EMAIL_SUBJECT="WordPress Installation Summary"
EMAIL_BODY="$SITE_TITLE installed successfully at $SITE_DIR and accessible at http://$SITE_URL"

# Send email using sendmail
wp eval "wp_mail('$ADMIN_EMAIL', '$EMAIL_SUBJECT', '$EMAIL_BODY');" --path="$WP_DIR" --allow-root || { echo "Failed to send email"; }

# Send a sample test email
TEST_EMAIL_SUBJECT="Test Email from WordPress Setup Script"
TEST_EMAIL_BODY="This is a test email to verify that the mail configuration is working correctly.\n\nThanks,\nThe Setup Script"

wp eval "wp_mail('$ADMIN_EMAIL', '$TEST_EMAIL_SUBJECT', '$TEST_EMAIL_BODY');" --path="$WP_DIR" --allow-root || { echo "Failed to send test email"; }

echo "Installation summary email and test email have been sent to $ADMIN_EMAIL"

echo "$SITE_TITLE installed successfully at $SITE_DIR and accessible at http://$SITE_URL"```

### scripts/wordpress/install-wp-clean.sh
```
#!/bin/zsh
WWW_DIR="/var/www"

set -a  # Automatically export all variables
source $WWW_DIR/.env
set +a  # Stop automatically exporting variables

# Define variables
SITE_TITLE="WP Clean"
DB_NAME="wpclean"

DB_USER="${MARIADB_USER}"
DB_PASS="${MARIADB_PASSWORD}"
DB_HOST="${MARIADB_HOST}"
SITE_DIR="$WWW_DIR/html/$DB_NAME"
WP_DIR="$SITE_DIR/public"
SITE_URL="$DB_NAME.test"
ADMIN_USER="${ADMIN_USER}"
ADMIN_PASSWORD="${ADMIN_PASSWORD}"
ADMIN_EMAIL="${ADMIN_EMAIL}"

# Ensure parent directory exists
mkdir -p "$SITE_DIR"

# Download WordPress
wp core download --path="$WP_DIR" --allow-root || { echo "Failed to download WordPress"; }

# Create the wp-config.php file
wp config create --dbname="$DB_NAME" --dbuser="$DB_USER" --dbpass="$DB_PASS" --dbhost="$DB_HOST" --path="$WP_DIR" --allow-root || { echo "Failed to create wp-config.php"; }

# Set debugging
wp config set WP_DEBUG false --raw --path="$WP_DIR" --allow-root || { echo "Failed to set WP_DEBUG";}

# Create the database
wp db create --path="$WP_DIR" --allow-root || { echo "Failed to create database"; }

# Install WordPress
wp core install --url="$SITE_URL" --title="$SITE_TITLE" --admin_user="$ADMIN_USER" --admin_password="$ADMIN_PASSWORD" --admin_email="$ADMIN_EMAIL" --path="$WP_DIR" --allow-root || { echo "Failed to install WordPress"; }

# Set month- and year-based folders
wp option update uploads_use_yearmonth_folders 0 --path="$WP_DIR" --allow-root || { echo "Failed to set upload folder";}

echo "WordPress installed successfully!"

# Delete default post and page
wp post delete 1 --force --path="$WP_DIR" --allow-root || echo "Post ID 1 not found."
wp post delete 2 --force --path="$WP_DIR" --allow-root || echo "Post ID 2 not found."
wp post delete 3 --force --path="$WP_DIR" --allow-root || echo "Post ID 3 not found."

# Delete default plugins
wp plugin delete akismet hello --path="$WP_DIR" --allow-root || echo "No default plugins found to delete."

# GitHub repositories for plugins and themes
PLUGIN_REPOS=(
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/typerocket-pro-v6.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/all-in-one-wp-migration.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/admin-site-enhancements-pro.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makermaker.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makerblocks.git"
)

THEME_REPOS=(
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makerstarter.git"
)

DEFAULT_THEMES=(
    "twentytwentythree"
    "twentytwentyfour"
    "twentytwentyfive"
)

# Install plugins
cd "$WP_DIR/wp-content/plugins" || exit
for PLUGIN_REPO in "${PLUGIN_REPOS[@]}"; do
    PLUGIN_DIR=$(basename "$PLUGIN_REPO" .git)
    git clone "$PLUGIN_REPO" || { echo "Failed to clone plugin $PLUGIN_REPO"; }
    wp plugin activate "$PLUGIN_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate plugin $PLUGIN_DIR"; }
done

# Install themes
cd "$WP_DIR/wp-content/themes" || exit
for THEME_REPO in "${THEME_REPOS[@]}"; do
    THEME_DIR=$(basename "$THEME_REPO" .git)
    git clone "$THEME_REPO" || { echo "Failed to clone theme $THEME_REPO"; }
    wp theme activate "$THEME_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate theme $THEME_DIR"; }
done

# Delete themes
cd "$WP_DIR/wp-content/themes" || exit
for THEME in "${DEFAULT_THEMES[@]}"; do
    wp theme delete "$THEME" --path="$WP_DIR" --allow-root || { echo "Failed to delete theme $THEME_DIR"; }
done

# Create necessary directories and set permissions for All in One WP Migration
AI1WM_BACKUPS_DIR="$WP_DIR/wp-content/ai1wm-backups"
mkdir -p "$AI1WM_BACKUPS_DIR" && echo "AI1WM Backup Folder Created at $AI1WM_BACKUPS_DIR" || { echo "Failed to create $AI1WM_BACKUPS_DIR"; }
chmod -R 777 "$AI1WM_BACKUPS_DIR" && echo "AI1WM Backup Folder Permissions set (777)" || { echo "Failed to set permissions on $AI1WM_BACKUPS_DIR"; }

AI1WM_STORAGE_DIR="$WP_DIR/wp-content/plugins/all-in-one-wp-migration/storage"
mkdir -p "$AI1WM_STORAGE_DIR" && echo "AI1WM Storage Folder Created at $AI1WM_STORAGE_DIR" || { echo "Failed to create $AI1WM_STORAGE_DIR"; exit 1; }
chmod -R 777 "$AI1WM_STORAGE_DIR" && echo "AI1WM Storage Folder Permissions set (777)" || { echo "Failed to set permissions on $AI1WM_STORAGE_DIR"; exit 1; }

# Uploads Directory
UPLOADS_DIR="$WP_DIR/wp-content/uploads"
mkdir -p "$UPLOADS_DIR" && echo "Uploads Folder Created at $UPLOADS_DIR" || { echo "Failed to create $UPLOADS_DIR"; exit 1; }
chmod -R 777 "$UPLOADS_DIR" && echo "Uploads Folder Permissions set (777)" || { echo "Failed to set permissions on $UPLOADS_DIR"; exit 1; }

# Themes Directory
THEMES_DIR="$WP_DIR/wp-content/themes"
chmod -R 777 "$THEMES_DIR" && echo "Themes Folder Permissions set (777)" || { echo "Failed to set permissions on $THEMES_DIR"; exit 1; }

# Plugins Directory
PLUGINS_DIR="$WP_DIR/wp-content/plugins"
chmod -R 777 "$PLUGINS_DIR" && echo "Plugins Folder Permissions set (777)" || { echo "Failed to set permissions on $PLUGINS_DIR"; exit 1; }

# Copy Makermaker Galaxy Files to WordPress Root Directory
GALAXY_DIR="$WP_DIR/wp-content/plugins/makermaker/galaxy"
GALAXY_FILE="$GALAXY_DIR/galaxy_makermaker"
GALAXY_CONFIG="$GALAXY_DIR/galaxy-makermaker-config.php"
cp "$GALAXY_FILE" "$WP_DIR"
sed "s/\$sitename = 'playground'/\$sitename = '$DB_NAME'/" "$GALAXY_CONFIG" > "$GALAXY_CONFIG.tmp"
mv "$GALAXY_CONFIG.tmp" "$GALAXY_CONFIG"
cp "$GALAXY_CONFIG" "$WP_DIR"

# Set permalink structure
wp rewrite structure '%postname%' --path="$WP_DIR" --allow-root || { echo "Failed to set permalink structure"; }

# Send installation summary email
EMAIL_SUBJECT="WordPress Installation Summary"
EMAIL_BODY="$SITE_TITLE installed successfully at $SITE_DIR and accessible at http://$SITE_URL"

# Send email using sendmail
wp eval "wp_mail('$ADMIN_EMAIL', '$EMAIL_SUBJECT', '$EMAIL_BODY');" --path="$WP_DIR" --allow-root || { echo "Failed to send email"; }

# Send a sample test email
TEST_EMAIL_SUBJECT="Test Email from WordPress Setup Script"
TEST_EMAIL_BODY="This is a test email to verify that the mail configuration is working correctly.\n\nThanks,\nThe Setup Script"

wp eval "wp_mail('$ADMIN_EMAIL', '$TEST_EMAIL_SUBJECT', '$TEST_EMAIL_BODY');" --path="$WP_DIR" --allow-root || { echo "Failed to send test email"; }

echo "Installation summary email and test email have been sent to $ADMIN_EMAIL"

echo "$SITE_TITLE installed successfully at $SITE_DIR and accessible at http://$SITE_URL"```

### scripts/wordpress/install-wp-custom.sh
```
#!/bin/zsh
WWW_DIR="/var/www"

set -a  # Automatically export all variables
source $WWW_DIR/.env
set +a  # Stop automatically exporting variables

# Define variables
SITE_TITLE="WP Custom"
DB_NAME="wpcustom"

DB_USER="${MARIADB_USER}"
DB_PASS="${MARIADB_PASSWORD}"
DB_HOST="${MARIADB_HOST}"
SITE_DIR="$WWW_DIR/html/$DB_NAME"
WP_DIR="$SITE_DIR/public"
SITE_URL="$DB_NAME.test"
ADMIN_USER="${ADMIN_USER}"
ADMIN_PASSWORD="${ADMIN_PASSWORD}"
ADMIN_EMAIL="${ADMIN_EMAIL}"

# Ensure parent directory exists
mkdir -p "$SITE_DIR"

# Download WordPress
wp core download --path="$WP_DIR" --allow-root || { echo "Failed to download WordPress"; }

# Create the wp-config.php file
wp config create --dbname="$DB_NAME" --dbuser="$DB_USER" --dbpass="$DB_PASS" --dbhost="$DB_HOST" --path="$WP_DIR" --allow-root || { echo "Failed to create wp-config.php"; }

# Set debugging
wp config set WP_DEBUG false --raw --path="$WP_DIR" --allow-root || { echo "Failed to set WP_DEBUG";}

# Create the database
wp db create --path="$WP_DIR" --allow-root || { echo "Failed to create database"; }

# Install WordPress
wp core install --url="$SITE_URL" --title="$SITE_TITLE" --admin_user="$ADMIN_USER" --admin_password="$ADMIN_PASSWORD" --admin_email="$ADMIN_EMAIL" --path="$WP_DIR" --allow-root || { echo "Failed to install WordPress"; }

# Set month- and year-based folders
wp option update uploads_use_yearmonth_folders 0 --path="$WP_DIR" --allow-root || { echo "Failed to set upload folder";}


echo "WordPress installed successfully!"

# Delete default post and page
wp post delete 1 --force --path="$WP_DIR" --allow-root || echo "Post ID 1 not found."
wp post delete 2 --force --path="$WP_DIR" --allow-root || echo "Post ID 2 not found."
wp post delete 3 --force --path="$WP_DIR" --allow-root || echo "Post ID 3 not found."

# Delete default plugins
wp plugin delete akismet hello --path="$WP_DIR" --allow-root || echo "No default plugins found to delete."

# GitHub repositories for plugins and themes
PLUGIN_REPOS=(
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/typerocket-pro-v6.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/all-in-one-wp-migration.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/admin-site-enhancements-pro.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/advanced-custom-fields-pro.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/acf-extended-pro.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makermaker.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makerblocks.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/gravityforms.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/manual-image-crop.git"
)

THEME_REPOS=(
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makerstarter.git"
)

DEFAULT_THEMES=(
    "twentytwentythree"
    "twentytwentyfour"
    "twentytwentyfive"
)

# Install plugins
cd "$WP_DIR/wp-content/plugins" || exit
for PLUGIN_REPO in "${PLUGIN_REPOS[@]}"; do
    PLUGIN_DIR=$(basename "$PLUGIN_REPO" .git)
    git clone "$PLUGIN_REPO" || { echo "Failed to clone plugin $PLUGIN_REPO"; }
    wp plugin activate "$PLUGIN_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate plugin $PLUGIN_DIR"; }
done

# Install themes
cd "$WP_DIR/wp-content/themes" || exit
for THEME_REPO in "${THEME_REPOS[@]}"; do
    THEME_DIR=$(basename "$THEME_REPO" .git)
    git clone "$THEME_REPO" || { echo "Failed to clone theme $THEME_REPO"; }
    wp theme activate "$THEME_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate theme $THEME_DIR"; }
done

# Delete themes
cd "$WP_DIR/wp-content/themes" || exit
for THEME in "${DEFAULT_THEMES[@]}"; do
    wp theme delete "$THEME" --path="$WP_DIR" --allow-root || { echo "Failed to delete theme $THEME_DIR"; }
done

# Create necessary directories and set permissions for All in One WP Migration
AI1WM_BACKUPS_DIR="$WP_DIR/wp-content/ai1wm-backups"
mkdir -p "$AI1WM_BACKUPS_DIR" && echo "AI1WM Backup Folder Created at $AI1WM_BACKUPS_DIR" || { echo "Failed to create $AI1WM_BACKUPS_DIR"; }
chmod -R 777 "$AI1WM_BACKUPS_DIR" && echo "AI1WM Backup Folder Permissions set (777)" || { echo "Failed to set permissions on $AI1WM_BACKUPS_DIR"; }

AI1WM_STORAGE_DIR="$WP_DIR/wp-content/plugins/all-in-one-wp-migration/storage"
mkdir -p "$AI1WM_STORAGE_DIR" && echo "AI1WM Storage Folder Created at $AI1WM_STORAGE_DIR" || { echo "Failed to create $AI1WM_STORAGE_DIR"; exit 1; }
chmod -R 777 "$AI1WM_STORAGE_DIR" && echo "AI1WM Storage Folder Permissions set (777)" || { echo "Failed to set permissions on $AI1WM_STORAGE_DIR"; exit 1; }

# Uploads Directory
UPLOADS_DIR="$WP_DIR/wp-content/uploads"
mkdir -p "$UPLOADS_DIR" && echo "Uploads Folder Created at $UPLOADS_DIR" || { echo "Failed to create $UPLOADS_DIR"; exit 1; }
chmod -R 777 "$UPLOADS_DIR" && echo "Uploads Folder Permissions set (777)" || { echo "Failed to set permissions on $UPLOADS_DIR"; exit 1; }

# Themes Directory
THEMES_DIR="$WP_DIR/wp-content/themes"
chmod -R 777 "$THEMES_DIR" && echo "Themes Folder Permissions set (777)" || { echo "Failed to set permissions on $THEMES_DIR"; exit 1; }

# Plugins Directory
PLUGINS_DIR="$WP_DIR/wp-content/plugins"
chmod -R 777 "$PLUGINS_DIR" && echo "Plugins Folder Permissions set (777)" || { echo "Failed to set permissions on $PLUGINS_DIR"; exit 1; }

# Copy Makermaker Galaxy Files to WordPress Root Directory
TYPEROCKET_DIR="$WP_DIR/wp-content/plugins/typerocket-pro-v6/typerocket"
MAKERMAKER_DIR="$WP_DIR/wp-content/plugins/makermaker"
MAKERSTARTER_DIR="$WP_DIR/wp-content/themes/makerstarter"
MAKERBLOCKS_DIR="$WP_DIR/wp-content/plugins/makerblocks"

GALAXY_FILE="$TYPEROCKET_DIR/galaxy"
GALAXY_CONFIG="$MAKERMAKER_DIR/galaxy/galaxy-config.php"

MAKERMAKER_GALAXY_FILE="$MAKERMAKER_DIR/galaxy/galaxy_makermaker"
MAKERMAKER_GALAXY_CONFIG="$MAKERMAKER_DIR/galaxy/galaxy-makermaker-config.php"

cp "$GALAXY_FILE" "$WP_DIR"
cp "$GALAXY_CONFIG" "$WP_DIR"

cp "$MAKERMAKER_GALAXY_FILE" "$WP_DIR"
sed "s/\$sitename = 'playground'/\$sitename = '$DB_NAME'/" "$MAKERMAKER_GALAXY_CONFIG" > "$MAKERMAKER_GALAXY_CONFIG.tmp"
mv "$MAKERMAKER_GALAXY_CONFIG.tmp" "$MAKERMAKER_GALAXY_CONFIG"
cp "$MAKERMAKER_GALAXY_CONFIG" "$WP_DIR"

# Copy TypeRocket Override Folders Maker Starter Theme
cp -R "$TYPEROCKET_DIR/app" "$MAKERSTARTER_DIR"
cp -R "$TYPEROCKET_DIR/config" "$MAKERSTARTER_DIR"
cp -R "$TYPEROCKET_DIR/resources" "$MAKERSTARTER_DIR"
cp -R "$TYPEROCKET_DIR/routes" "$MAKERSTARTER_DIR"
mkdir "$MAKERSTARTER_DIR/storage"

# Set permalink structure
wp rewrite structure '%postname%' --path="$WP_DIR" --allow-root || { echo "Failed to set permalink structure"; }

# Send installation summary email
EMAIL_SUBJECT="WordPress Installation Summary"
EMAIL_BODY="$SITE_TITLE installed successfully at $SITE_DIR and accessible at http://$SITE_URL"

# Send email using sendmail
wp eval "wp_mail('$ADMIN_EMAIL', '$EMAIL_SUBJECT', '$EMAIL_BODY');" --path="$WP_DIR" --allow-root || { echo "Failed to send email"; }

# Send a sample test email
TEST_EMAIL_SUBJECT="Test Email from WordPress Setup Script"
TEST_EMAIL_BODY="This is a test email to verify that the mail configuration is working correctly.\n\nThanks,\nThe Setup Script"

wp eval "wp_mail('$ADMIN_EMAIL', '$TEST_EMAIL_SUBJECT', '$TEST_EMAIL_BODY');" --path="$WP_DIR" --allow-root || { echo "Failed to send test email"; }

echo "Installation summary email and test email have been sent to $ADMIN_EMAIL"

echo "$SITE_TITLE installed successfully at $SITE_DIR and accessible at http://$SITE_URL"```

### scripts/wordpress/install-wp-loaded.sh
```
#!/bin/zsh
WWW_DIR="/var/www"

set -a  # Automatically export all variables
source $WWW_DIR/.env
set +a  # Stop automatically exporting variables

# Define variables
SITE_TITLE="WP Loaded"
DB_NAME="wploaded"

DB_USER="${MARIADB_USER}"
DB_PASS="${MARIADB_PASSWORD}"
DB_HOST="${MARIADB_HOST}"
SITE_DIR="$WWW_DIR/html/$DB_NAME"
WP_DIR="$SITE_DIR/public"
SITE_URL="$DB_NAME.test"
ADMIN_USER="${ADMIN_USER}"
ADMIN_PASSWORD="${ADMIN_PASSWORD}"
ADMIN_EMAIL="${ADMIN_EMAIL}"

# Ensure parent directory exists
mkdir -p "$SITE_DIR"

# Download WordPress
wp core download --path="$WP_DIR" --allow-root || { echo "Failed to download WordPress"; }

# Create the wp-config.php file
wp config create --dbname="$DB_NAME" --dbuser="$DB_USER" --dbpass="$DB_PASS" --dbhost="$DB_HOST" --path="$WP_DIR" --allow-root || { echo "Failed to create wp-config.php"; }

# Set debugging
wp config set WP_DEBUG false --raw --path="$WP_DIR" --allow-root || { echo "Failed to set WP_DEBUG";}

# Create the database
wp db create --path="$WP_DIR" --allow-root || { echo "Failed to create database"; }

# Install WordPress
wp core install --url="$SITE_URL" --title="$SITE_TITLE" --admin_user="$ADMIN_USER" --admin_password="$ADMIN_PASSWORD" --admin_email="$ADMIN_EMAIL" --path="$WP_DIR" --allow-root || { echo "Failed to install WordPress"; }

# Set month- and year-based folders
wp option update uploads_use_yearmonth_folders 0 --path="$WP_DIR" --allow-root || { echo "Failed to set upload folder";}


echo "WordPress installed successfully!"

# Delete default post and page
wp post delete 1 --force --path="$WP_DIR" --allow-root || echo "Post ID 1 not found."
wp post delete 2 --force --path="$WP_DIR" --allow-root || echo "Post ID 2 not found."
wp post delete 3 --force --path="$WP_DIR" --allow-root || echo "Post ID 3 not found."

# Delete default plugins
wp plugin delete akismet hello --path="$WP_DIR" --allow-root || echo "No default plugins found to delete."

# GitHub repositories for plugins and themes
PLUGIN_REPOS=(
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/typerocket-pro-v6.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/all-in-one-wp-migration.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/admin-site-enhancements-pro.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/advanced-custom-fields-pro.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/acf-extended-pro.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makermaker.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makerblocks.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/gravityforms.git"
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/manual-image-crop.git"
)

THEME_REPOS=(
    "https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/makerstarter.git"
)

DEFAULT_THEMES=(
    "twentytwentythree"
    "twentytwentyfour"
    "twentytwentyfive"
)

# Install plugins
cd "$WP_DIR/wp-content/plugins" || exit
for PLUGIN_REPO in "${PLUGIN_REPOS[@]}"; do
    PLUGIN_DIR=$(basename "$PLUGIN_REPO" .git)
    git clone "$PLUGIN_REPO" || { echo "Failed to clone plugin $PLUGIN_REPO"; }
    wp plugin activate "$PLUGIN_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate plugin $PLUGIN_DIR"; }
done

# Install themes
cd "$WP_DIR/wp-content/themes" || exit
for THEME_REPO in "${THEME_REPOS[@]}"; do
    THEME_DIR=$(basename "$THEME_REPO" .git)
    git clone "$THEME_REPO" || { echo "Failed to clone theme $THEME_REPO"; }
    wp theme activate "$THEME_DIR" --path="$WP_DIR" --allow-root || { echo "Failed to activate theme $THEME_DIR"; }
done

# Delete themes
cd "$WP_DIR/wp-content/themes" || exit
for THEME in "${DEFAULT_THEMES[@]}"; do
    wp theme delete "$THEME" --path="$WP_DIR" --allow-root || { echo "Failed to delete theme $THEME_DIR"; }
done

# Install plugins from WordPress Repo
wp plugin install debug-bar debug-bar-actions-and-filters-addon classic-editor default-featured-image plugin-inspector log-deprecated-notices query-monitor theme-check wordpress-beta-tester show-current-template theme-inspector view-admin-as --path="$WP_DIR" --allow-root

# Create necessary directories and set permissions for All in One WP Migration
AI1WM_BACKUPS_DIR="$WP_DIR/wp-content/ai1wm-backups"
mkdir -p "$AI1WM_BACKUPS_DIR" && echo "AI1WM Backup Folder Created at $AI1WM_BACKUPS_DIR" || { echo "Failed to create $AI1WM_BACKUPS_DIR"; }
chmod -R 777 "$AI1WM_BACKUPS_DIR" && echo "AI1WM Backup Folder Permissions set (777)" || { echo "Failed to set permissions on $AI1WM_BACKUPS_DIR"; }

AI1WM_STORAGE_DIR="$WP_DIR/wp-content/plugins/all-in-one-wp-migration/storage"
mkdir -p "$AI1WM_STORAGE_DIR" && echo "AI1WM Storage Folder Created at $AI1WM_STORAGE_DIR" || { echo "Failed to create $AI1WM_STORAGE_DIR"; exit 1; }
chmod -R 777 "$AI1WM_STORAGE_DIR" && echo "AI1WM Storage Folder Permissions set (777)" || { echo "Failed to set permissions on $AI1WM_STORAGE_DIR"; exit 1; }

# Uploads Directory
UPLOADS_DIR="$WP_DIR/wp-content/uploads"
mkdir -p "$UPLOADS_DIR" && echo "Uploads Folder Created at $UPLOADS_DIR" || { echo "Failed to create $UPLOADS_DIR"; exit 1; }
chmod -R 777 "$UPLOADS_DIR" && echo "Uploads Folder Permissions set (777)" || { echo "Failed to set permissions on $UPLOADS_DIR"; exit 1; }

# Themes Directory
THEMES_DIR="$WP_DIR/wp-content/themes"
chmod -R 777 "$THEMES_DIR" && echo "Themes Folder Permissions set (777)" || { echo "Failed to set permissions on $THEMES_DIR"; exit 1; }

# Plugins Directory
PLUGINS_DIR="$WP_DIR/wp-content/plugins"
chmod -R 777 "$PLUGINS_DIR" && echo "Plugins Folder Permissions set (777)" || { echo "Failed to set permissions on $PLUGINS_DIR"; exit 1; }

# Copy Makermaker Galaxy Files to WordPress Root Directory
GALAXY_DIR="$WP_DIR/wp-content/plugins/makermaker/galaxy"
GALAXY_FILE="$GALAXY_DIR/galaxy_makermaker"
GALAXY_CONFIG="$GALAXY_DIR/galaxy-makermaker-config.php"
cp "$GALAXY_FILE" "$WP_DIR"
sed "s/\$sitename = 'playground'/\$sitename = '$DB_NAME'/" "$GALAXY_CONFIG" > "$GALAXY_CONFIG.tmp"
mv "$GALAXY_CONFIG.tmp" "$GALAXY_CONFIG"
cp "$GALAXY_CONFIG" "$WP_DIR"

# Set permalink structure
wp rewrite structure '%postname%' --path="$WP_DIR" --allow-root || { echo "Failed to set permalink structure"; }

# Send installation summary email
EMAIL_SUBJECT="WordPress Installation Summary"
EMAIL_BODY="$SITE_TITLE installed successfully at $SITE_DIR and accessible at http://$SITE_URL"

# Send email using sendmail
wp eval "wp_mail('$ADMIN_EMAIL', '$EMAIL_SUBJECT', '$EMAIL_BODY');" --path="$WP_DIR" --allow-root || { echo "Failed to send email"; }

# Send a sample test email
TEST_EMAIL_SUBJECT="Test Email from WordPress Setup Script"
TEST_EMAIL_BODY="This is a test email to verify that the mail configuration is working correctly.\n\nThanks,\nThe Setup Script"

wp eval "wp_mail('$ADMIN_EMAIL', '$TEST_EMAIL_SUBJECT', '$TEST_EMAIL_BODY');" --path="$WP_DIR" --allow-root || { echo "Failed to send test email"; }

echo "Installation summary email and test email have been sent to $ADMIN_EMAIL"

echo "$SITE_TITLE installed successfully at $SITE_DIR and accessible at http://$SITE_URL"```

---
Files processed: 19
