# NGINX PROXY MANAGER ADMIN
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name nginx.test npm.test nginx-proxy-manager.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    set $upstream_npm "nginx-proxy-manager:81";

    location / {
        proxy_pass http://$upstream_npm;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_npm;
    }

    location /api {
        proxy_pass http://$upstream_npm/api;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_npm;
    }

    location @fallback_npm {
        return 503 "Nginx Proxy Manager is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/nginx-admin.error.log;
    access_log /var/log/nginx/nginx-admin.access.log;
}

# DATABASE MANAGEMENT TOOLS
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name adminer.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_adminer adminer:8080;
        proxy_pass http://$upstream_adminer;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_adminer;
    }

    location @fallback_adminer {
        return 503 "Adminer service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/adminer.error.log;
    access_log /var/log/nginx/adminer.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name phpmyadmin.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_phpmyadmin phpmyadmin:80;
        proxy_pass http://$upstream_phpmyadmin;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_phpmyadmin;
    }

    location @fallback_phpmyadmin {
        return 503 "phpMyAdmin service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/phpmyadmin.error.log;
    access_log /var/log/nginx/phpmyadmin.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name mongodb.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_mongodb mongo-express:8081;
        proxy_pass http://$upstream_mongodb;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_mongodb;
    }

    location @fallback_mongodb {
        return 503 "MongoDB Express service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/mongodb.error.log;
    access_log /var/log/nginx/mongodb.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name cloudbeaver.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_cloudbeaver cloudbeaver:8978;
        proxy_pass http://$upstream_cloudbeaver;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_cloudbeaver;
    }

    location @fallback_cloudbeaver {
        return 503 "Cloudbeaver service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/cloudbeaver.error.log;
    access_log /var/log/nginx/cloudbeaver.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name metabase.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_metabase metabase:3000;
        proxy_pass http://$upstream_metabase;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_metabase;
    }

    location @fallback_metabase {
        return 503 "Metabase service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/metabase.error.log;
    access_log /var/log/nginx/metabase.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name nocodb.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_nocodb nocodb:8080;
        proxy_pass http://$upstream_nocodb;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_nocodb;
    }

    location @fallback_nocodb {
        return 503 "NocoDB service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/nocodb.error.log;
    access_log /var/log/nginx/nocodb.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name pgadmin.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_pgadmin pgadmin:80;
        proxy_pass http://$upstream_pgadmin;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_pgadmin;
    }

    location @fallback_pgadmin {
        return 503 "pgAdmin service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/pgadmin.error.log;
    access_log /var/log/nginx/pgadmin.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name redis.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_redis redis-commander:8081;
        proxy_pass http://$upstream_redis;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_redis;
    }

    location @fallback_redis {
        return 503 "Redis Commander service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/redis.error.log;
    access_log /var/log/nginx/redis.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name drawdb.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_drawdb drawdb:80;
        proxy_pass http://$upstream_drawdb;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_drawdb;
    }

    location @fallback_drawdb {
        return 503 "DrawDB service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/drawdb.error.log;
    access_log /var/log/nginx/drawdb.access.log;
}

# BACKEND SERVICES
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name dotnet.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_dotnet dotnet:80;
        proxy_pass http://$upstream_dotnet;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_dotnet;
    }

    location @fallback_dotnet {
        return 503 ".NET service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/dotnet.error.log;
    access_log /var/log/nginx/dotnet.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name go.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_go go:8080;
        proxy_pass http://$upstream_go;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_go;
    }

    location @fallback_go {
        return 503 "Go service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/go.error.log;
    access_log /var/log/nginx/go.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name node.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_node node:3000;
        proxy_pass http://$upstream_node;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_node;
    }

    location @fallback_node {
        return 503 "Node.js service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/node.error.log;
    access_log /var/log/nginx/node.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name python.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_python python:8000;
        proxy_pass http://$upstream_python;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_python;
    }

    location @fallback_python {
        return 503 "Python service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/python.error.log;
    access_log /var/log/nginx/python.access.log;
}

# ANALYTICS & MONITORING
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name elasticsearch.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_elasticsearch elasticsearch:9200;
        proxy_pass http://$upstream_elasticsearch;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_elasticsearch;
    }

    location @fallback_elasticsearch {
        return 503 "Elasticsearch service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/elasticsearch.error.log;
    access_log /var/log/nginx/elasticsearch.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name kibana.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_kibana kibana:5601;
        proxy_pass http://$upstream_kibana;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_kibana;
    }

    location @fallback_kibana {
        return 503 "Kibana service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/kibana.error.log;
    access_log /var/log/nginx/kibana.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name logstash.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_logstash logstash:9600;
        proxy_pass http://$upstream_logstash;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_logstash;
    }

    location @fallback_logstash {
        return 503 "Logstash service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/logstash.error.log;
    access_log /var/log/nginx/logstash.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name grafana.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_grafana grafana:3000;
        proxy_pass http://$upstream_grafana;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_grafana;
    }

    location @fallback_grafana {
        return 503 "Grafana service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/grafana.error.log;
    access_log /var/log/nginx/grafana.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name prometheus.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_prometheus prometheus:9090;
        proxy_pass http://$upstream_prometheus;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_prometheus;
    }

    location @fallback_prometheus {
        return 503 "Prometheus service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/prometheus.error.log;
    access_log /var/log/nginx/prometheus.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name matomo.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_matomo matomo:80;
        proxy_pass http://$upstream_matomo;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_matomo;
    }

    location @fallback_matomo {
        return 503 "Matomo service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/matomo.error.log;
    access_log /var/log/nginx/matomo.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name cadvisor.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_cadvisor cadvisor:8080;
        proxy_pass http://$upstream_cadvisor;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_cadvisor;
    }

    location @fallback_cadvisor {
        return 503 "cAdvisor service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/cadvisor.error.log;
    access_log /var/log/nginx/cadvisor.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name otel.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_otel otel-collector:8889;
        proxy_pass http://$upstream_otel;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_otel;
    }

    location @fallback_otel {
        return 503 "OpenTelemetry Collector service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/otel.error.log;
    access_log /var/log/nginx/otel.access.log;
}

# AI SERVICES
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name langflow.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_langflow langflow:7860;
        proxy_pass http://$upstream_langflow;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_langflow;
    }

    location @fallback_langflow {
        return 503 "Langflow service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/langflow.error.log;
    access_log /var/log/nginx/langflow.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name n8n.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_n8n n8n:5678;
        proxy_pass http://$upstream_n8n;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_n8n;
    }

    location @fallback_n8n {
        return 503 "n8n service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/n8n.error.log;
    access_log /var/log/nginx/n8n.access.log;
}

# PROJECT MANAGEMENT
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name gitea.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_gitea gitea:3000;
        proxy_pass http://$upstream_gitea;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_gitea;
    }

    location @fallback_gitea {
        return 503 "Gitea service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/gitea.error.log;
    access_log /var/log/nginx/gitea.access.log;
}

# MAIL SERVICES
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name mailpit.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_mailpit mailpit:8025;
        proxy_pass http://$upstream_mailpit;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_mailpit;
    }

    location @fallback_mailpit {
        return 503 "Mailpit service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/mailpit.error.log;
    access_log /var/log/nginx/mailpit.access.log;
}

# MANAGEMENT TOOLS
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name portainer.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_portainer portainer:9000;
        proxy_pass http://$upstream_portainer;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_portainer;
    }

    location @fallback_portainer {
        return 503 "Portainer service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/portainer.error.log;
    access_log /var/log/nginx/portainer.access.log;
}

# GATEWAY SERVICES
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name krakend.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_krakend krakend-designer:80;
        proxy_pass http://$upstream_krakend;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_krakend;
    }

    location @fallback_krakend {
        return 503 "KrakenD Designer service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/krakend.error.log;
    access_log /var/log/nginx/krakend.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name kong.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_kong kong:8001;
        proxy_pass http://$upstream_kong;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_kong;
    }

    location @fallback_kong {
        return 503 "Kong Admin API is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/kong.error.log;
    access_log /var/log/nginx/kong.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name traefik.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_traefik traefik:8082;
        proxy_pass http://$upstream_traefik;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_traefik;
    }

    location @fallback_traefik {
        return 503 "Traefik service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/traefik.error.log;
    access_log /var/log/nginx/traefik.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name envoy.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_envoy envoy:9901;
        proxy_pass http://$upstream_envoy;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_envoy;
    }

    location @fallback_envoy {
        return 503 "Envoy Admin UI is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/envoy.error.log;
    access_log /var/log/nginx/envoy.access.log;
}

# MONITORING EXPORTERS
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name blackbox.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_blackbox blackbox-exporter:9115;
        proxy_pass http://$upstream_blackbox;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_blackbox;
    }

    location @fallback_blackbox {
        return 503 "Blackbox Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/blackbox.error.log;
    access_log /var/log/nginx/blackbox.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name mongodb-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_mongodb_exporter mongodb-exporter:9216;
        proxy_pass http://$upstream_mongodb_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_mongodb_exporter;
    }

    location @fallback_mongodb_exporter {
        return 503 "MongoDB Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/mongodb-exporter.error.log;
    access_log /var/log/nginx/mongodb-exporter.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name mysql-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_mysql_exporter mysqld-exporter:9104;
        proxy_pass http://$upstream_mysql_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_mysql_exporter;
    }

    location @fallback_mysql_exporter {
        return 503 "MySQL Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/mysql-exporter.error.log;
    access_log /var/log/nginx/mysql-exporter.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name node-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_node_exporter node-exporter:9100;
        proxy_pass http://$upstream_node_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_node_exporter;
    }

    location @fallback_node_exporter {
        return 503 "Node Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/node-exporter.error.log;
    access_log /var/log/nginx/node-exporter.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name postgres-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_postgres_exporter postgres-exporter:9187;
        proxy_pass http://$upstream_postgres_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_postgres_exporter;
    }

    location @fallback_postgres_exporter {
        return 503 "PostgreSQL Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/postgres-exporter.error.log;
    access_log /var/log/nginx/postgres-exporter.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name redis-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_redis_exporter redis-exporter:9121;
        proxy_pass http://$upstream_redis_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_redis_exporter;
    }

    location @fallback_redis_exporter {
        return 503 "Redis Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/redis-exporter.error.log;
    access_log /var/log/nginx/redis-exporter.access.log;
}

# PROJECT MANAGEMENT
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name openproject.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_openproject openproject-web:8080;
        proxy_pass http://$upstream_openproject;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_openproject;
    }

    location @fallback_openproject {
        return 503 "OpenProject service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/openproject.error.log;
    access_log /var/log/nginx/openproject.access.log;
}

# DEVARCH DASHBOARD
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name dashboard.test devarch.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    root /var/www/html/dashboard/dist;
    index index.html;

    set $devarch_upstream "devarch:8000";

    location /api/logs {
        proxy_pass http://$devarch_upstream;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Connection '';
        proxy_http_version 1.1;

        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 24h;
        proxy_send_timeout 24h;
        proxy_connect_timeout 60s;
        chunked_transfer_encoding on;

        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Content-Type, Authorization" always;
        add_header X-Accel-Buffering no always;

        if ($request_method = OPTIONS) {
            return 204;
        }

        proxy_intercept_errors on;
        error_page 502 503 504 = @fallback_devarch;
    }

    location /api/ {
        proxy_pass http://$devarch_upstream;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Content-Type, Authorization" always;

        if ($request_method = OPTIONS) {
            return 204;
        }

        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        proxy_intercept_errors on;
        error_page 502 503 504 = @fallback_devarch;
    }

    location @fallback_devarch {
        return 503 "DevArch service is temporarily unavailable. Please start the container.";
        add_header Content-Type text/plain always;
    }

    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        try_files $uri =404;
    }

    location / {
        try_files $uri $uri/ /index.html;
    }

    error_log /var/log/nginx/dashboard.error.log;
    access_log /var/log/nginx/dashboard.access.log;
}

# DEVELOPMENT PROJECTS (.test domains)
server {
    listen 80 default_server;
    http2 on;
    listen 443 ssl default_server;
    server_name ~^(?<appname>[^.]+)\.test$;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    set $upstream_node "node:3000";
    set $upstream_python "python:8000";
    set $upstream_go "go:8080";
    set $upstream_dotnet "dotnet:8080";
    set $upstream_rust "rust:8080";
    set $devarch_upstream "devarch:8000";

    set $dist_html 0;
    set $dist_php 0;
    set $build_html 0;
    set $build_php 0;
    set $out_html 0;
    set $public_html 0;
    set $public_php 0;

    if (-f /var/www/html/$appname/dist/index.html) {
        set $dist_html 1;
    }
    if (-f /var/www/html/$appname/dist/index.php) {
        set $dist_php 1;
    }

    if (-f /var/www/html/$appname/build/index.html) {
        set $build_html 1;
    }
    if (-f /var/www/html/$appname/build/index.php) {
        set $build_php 1;
    }

    if (-f /var/www/html/$appname/out/index.html) {
        set $out_html 1;
    }

    if (-f /var/www/html/$appname/public/index.html) {
        set $public_html 1;
    }
    if (-f /var/www/html/$appname/public/index.php) {
        set $public_php 1;
    }

    set $docroot "/var/www/html/$appname";

    set $check_public "${public_html}${public_php}";
    if ($check_public ~ "[1]") {
        set $docroot "/var/www/html/$appname/public";
    }

    if ($out_html = 1) {
        set $docroot "/var/www/html/$appname/out";
    }

    set $check_build "${build_html}${build_php}";
    if ($check_build ~ "[1]") {
        set $docroot "/var/www/html/$appname/build";
    }

    set $check_dist "${dist_html}${dist_php}";
    if ($check_dist ~ "[1]") {
        set $docroot "/var/www/html/$appname/dist";
    }

    root $docroot;
    index index.php index.html index.htm;

    set $app_lang "static";

    if (-f /var/www/html/$appname/package.json) {
        set $app_lang "node";
    }

    if (-f /var/www/html/$appname/requirements.txt) {
        set $app_lang "python";
    }
    if (-f /var/www/html/$appname/manage.py) {
        set $app_lang "python";
    }

    if (-f /var/www/html/$appname/go.mod) {
        set $app_lang "go";
    }

    if (-f /var/www/html/$appname/appsettings.json) {
        set $app_lang "dotnet";
    }

    if (-f /var/www/html/$appname/Cargo.toml) {
        set $app_lang "rust";
    }

    if (-f /var/www/html/$appname/composer.json) {
        set $app_lang "php";
    }
    if (-f $docroot/index.php) {
        set $app_lang "php";
    }

    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    add_header X-Resolved-Docroot $docroot always;
    add_header X-Detected-Language $app_lang always;

    location / {
        try_files $uri $uri/ @app_router;
    }

    location @app_router {
        if (-f $docroot/index.html) {
            rewrite ^ /index.html break;
        }

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;

        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_buffering off;

        proxy_intercept_errors on;
        error_page 502 503 504 = @upstream_down;

        if ($app_lang = "node") {
            proxy_pass http://$upstream_node;
            break;
        }

        if ($app_lang = "python") {
            proxy_pass http://$upstream_python;
            break;
        }

        if ($app_lang = "go") {
            proxy_pass http://$upstream_go;
            break;
        }

        if ($app_lang = "dotnet") {
            proxy_pass http://$upstream_dotnet;
            break;
        }

        if ($app_lang = "rust") {
            proxy_pass http://$upstream_rust;
            break;
        }

        if ($app_lang = "php") {
            rewrite ^(.*)$ /index.php?$args last;
        }

        try_files /index.html =404;
    }

    location @upstream_down {
        return 503 "Upstream service ($app_lang) is temporarily unavailable for $host. Please start the container.";
        add_header Content-Type text/plain always;
    }

    location ~ ^/(ws|websocket|socket\.io|_next/webpack-hmr|sockjs-node) {
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_intercept_errors on;
        error_page 502 503 504 = @upstream_down;

        if ($app_lang = "node") { proxy_pass http://$upstream_node; }
        if ($app_lang = "python") { proxy_pass http://$upstream_python; }
        if ($app_lang = "dotnet") { proxy_pass http://$upstream_dotnet; }
        if ($app_lang = "rust") { proxy_pass http://$upstream_rust; }
    }

    location /api/logs {
        proxy_pass http://$devarch_upstream;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Connection '';
        proxy_http_version 1.1;

        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 24h;
        proxy_send_timeout 24h;
        proxy_connect_timeout 60s;
        chunked_transfer_encoding on;

        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Content-Type, Authorization" always;
        add_header X-Accel-Buffering no always;

        if ($request_method = OPTIONS) {
            return 204;
        }

        proxy_intercept_errors on;
        error_page 502 503 504 = @upstream_down;
    }

    # Only proxy /api/ to devarch for dashboard app, not PHP apps with their own API routes
    location /api/ {
        # Skip devarch proxy for PHP apps - let them handle their own /api routes
        if ($app_lang = "php") {
            rewrite ^(.*)$ /index.php?$args last;
        }

        proxy_pass http://$devarch_upstream;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Content-Type, Authorization" always;

        if ($request_method = OPTIONS) {
            return 204;
        }

        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        proxy_intercept_errors on;
        error_page 502 503 504 = @upstream_down;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;

        set $upstream_php php:9000;
        fastcgi_pass $upstream_php;

        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;

        fastcgi_param HTTPS on;
        fastcgi_param REQUEST_SCHEME https;
        fastcgi_param SERVER_PORT 443;

        fastcgi_param HTTP_X_FORWARDED_PROTO $scheme;
        fastcgi_param HTTP_X_FORWARDED_HOST $host;
        fastcgi_param HTTP_X_FORWARDED_PORT $server_port;

        error_page 502 503 504 = @fallback_php;
    }
    
    location @fallback_php {
        return 503 "PHP service is temporarily unavailable. Please start the PHP container.";
        add_header Content-Type text/plain always;
    }

    location ~ /\. {
        deny all;
    }

    location = /favicon.ico {
        access_log off;
        log_not_found off;
    }

    location = /robots.txt {
        access_log off;
        log_not_found off;
    }

    location ~* wp-config.php$ {
        deny all;
    }

    error_log /var/log/nginx/$appname.error.log;
    access_log /var/log/nginx/$appname.access.log;
}
