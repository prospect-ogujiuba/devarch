# NGINX PROXY MANAGER ADMIN
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name nginx.test npm.test nginx-proxy-manager.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        proxy_pass http://nginx-proxy-manager:81;
        include /data/nginx/custom/server_proxy.conf;
    }

    location /api {
        proxy_pass http://nginx-proxy-manager:81/api;
        include /data/nginx/custom/server_proxy.conf;
    }

    error_log /var/log/nginx/nginx-admin.error.log;
    access_log /var/log/nginx/nginx-admin.access.log;
}

# DATABASE MANAGEMENT TOOLS
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name adminer.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_adminer adminer:8080;
        proxy_pass http://$upstream_adminer;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_adminer;
    }

    location @fallback_adminer {
        return 503 "Adminer service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/adminer.error.log;
    access_log /var/log/nginx/adminer.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name phpmyadmin.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_phpmyadmin phpmyadmin:80;
        proxy_pass http://$upstream_phpmyadmin;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_phpmyadmin;
    }

    location @fallback_phpmyadmin {
        return 503 "phpMyAdmin service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/phpmyadmin.error.log;
    access_log /var/log/nginx/phpmyadmin.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name mongodb.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_mongodb mongo-express:8081;
        proxy_pass http://$upstream_mongodb;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_mongodb;
    }

    location @fallback_mongodb {
        return 503 "MongoDB Express service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/mongodb.error.log;
    access_log /var/log/nginx/mongodb.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name cloudbeaver.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_cloudbeaver cloudbeaver:8978;
        proxy_pass http://$upstream_cloudbeaver;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_cloudbeaver;
    }

    location @fallback_cloudbeaver {
        return 503 "Cloudbeaver service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/cloudbeaver.error.log;
    access_log /var/log/nginx/cloudbeaver.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name metabase.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_metabase metabase:3000;
        proxy_pass http://$upstream_metabase;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_metabase;
    }

    location @fallback_metabase {
        return 503 "Metabase service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/metabase.error.log;
    access_log /var/log/nginx/metabase.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name nocodb.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_nocodb nocodb:8080;
        proxy_pass http://$upstream_nocodb;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_nocodb;
    }

    location @fallback_nocodb {
        return 503 "NocoDB service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/nocodb.error.log;
    access_log /var/log/nginx/nocodb.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name pgadmin.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_pgadmin pgadmin:80;
        proxy_pass http://$upstream_pgadmin;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_pgadmin;
    }

    location @fallback_pgadmin {
        return 503 "pgAdmin service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/pgadmin.error.log;
    access_log /var/log/nginx/pgadmin.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name redis.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_redis redis-commander:8081;
        proxy_pass http://$upstream_redis;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_redis;
    }

    location @fallback_redis {
        return 503 "Redis Commander service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/redis.error.log;
    access_log /var/log/nginx/redis.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name drawdb.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_drawdb drawdb:80;
        proxy_pass http://$upstream_drawdb;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_drawdb;
    }

    location @fallback_drawdb {
        return 503 "DrawDB service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/drawdb.error.log;
    access_log /var/log/nginx/drawdb.access.log;
}

# BACKEND SERVICES
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name dotnet.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_dotnet dotnet:80;
        proxy_pass http://$upstream_dotnet;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_dotnet;
    }

    location @fallback_dotnet {
        return 503 ".NET service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/dotnet.error.log;
    access_log /var/log/nginx/dotnet.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name go.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_go go:8080;
        proxy_pass http://$upstream_go;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_go;
    }

    location @fallback_go {
        return 503 "Go service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/go.error.log;
    access_log /var/log/nginx/go.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name node.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_node node:3000;
        proxy_pass http://$upstream_node;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_node;
    }

    location @fallback_node {
        return 503 "Node.js service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/node.error.log;
    access_log /var/log/nginx/node.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name python.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_python python:8000;
        proxy_pass http://$upstream_python;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_python;
    }

    location @fallback_python {
        return 503 "Python service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/python.error.log;
    access_log /var/log/nginx/python.access.log;
}

# ANALYTICS & MONITORING
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name elasticsearch.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_elasticsearch elasticsearch:9200;
        proxy_pass http://$upstream_elasticsearch;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_elasticsearch;
    }

    location @fallback_elasticsearch {
        return 503 "Elasticsearch service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/elasticsearch.error.log;
    access_log /var/log/nginx/elasticsearch.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name kibana.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_kibana kibana:5601;
        proxy_pass http://$upstream_kibana;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_kibana;
    }

    location @fallback_kibana {
        return 503 "Kibana service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/kibana.error.log;
    access_log /var/log/nginx/kibana.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name logstash.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_logstash logstash:9600;
        proxy_pass http://$upstream_logstash;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_logstash;
    }

    location @fallback_logstash {
        return 503 "Logstash service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/logstash.error.log;
    access_log /var/log/nginx/logstash.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name grafana.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_grafana grafana:3000;
        proxy_pass http://$upstream_grafana;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_grafana;
    }

    location @fallback_grafana {
        return 503 "Grafana service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/grafana.error.log;
    access_log /var/log/nginx/grafana.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name prometheus.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_prometheus prometheus:9090;
        proxy_pass http://$upstream_prometheus;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_prometheus;
    }

    location @fallback_prometheus {
        return 503 "Prometheus service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/prometheus.error.log;
    access_log /var/log/nginx/prometheus.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name matomo.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_matomo matomo:80;
        proxy_pass http://$upstream_matomo;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_matomo;
    }

    location @fallback_matomo {
        return 503 "Matomo service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/matomo.error.log;
    access_log /var/log/nginx/matomo.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name cadvisor.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_cadvisor cadvisor:8080;
        proxy_pass http://$upstream_cadvisor;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_cadvisor;
    }

    location @fallback_cadvisor {
        return 503 "cAdvisor service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/cadvisor.error.log;
    access_log /var/log/nginx/cadvisor.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name otel.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_otel otel-collector:8889;
        proxy_pass http://$upstream_otel;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_otel;
    }

    location @fallback_otel {
        return 503 "OpenTelemetry Collector service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/otel.error.log;
    access_log /var/log/nginx/otel.access.log;
}

# AI SERVICES
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name langflow.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_langflow langflow:7860;
        proxy_pass http://$upstream_langflow;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_langflow;
    }

    location @fallback_langflow {
        return 503 "Langflow service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/langflow.error.log;
    access_log /var/log/nginx/langflow.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name n8n.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_n8n n8n:5678;
        proxy_pass http://$upstream_n8n;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_n8n;
    }

    location @fallback_n8n {
        return 503 "n8n service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/n8n.error.log;
    access_log /var/log/nginx/n8n.access.log;
}

# PROJECT MANAGEMENT
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name gitea.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_gitea gitea:3000;
        proxy_pass http://$upstream_gitea;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_gitea;
    }

    location @fallback_gitea {
        return 503 "Gitea service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/gitea.error.log;
    access_log /var/log/nginx/gitea.access.log;
}

# MAIL SERVICES
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name mailpit.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_mailpit mailpit:8025;
        proxy_pass http://$upstream_mailpit;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_mailpit;
    }

    location @fallback_mailpit {
        return 503 "Mailpit service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/mailpit.error.log;
    access_log /var/log/nginx/mailpit.access.log;
}

# MANAGEMENT TOOLS
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name portainer.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_portainer portainer:9000;
        proxy_pass http://$upstream_portainer;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_portainer;
    }

    location @fallback_portainer {
        return 503 "Portainer service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/portainer.error.log;
    access_log /var/log/nginx/portainer.access.log;
}

# GATEWAY SERVICES
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name krakend.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_krakend krakend-designer:80;
        proxy_pass http://$upstream_krakend;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_krakend;
    }

    location @fallback_krakend {
        return 503 "KrakenD Designer service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/krakend.error.log;
    access_log /var/log/nginx/krakend.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name kong.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_kong kong:8001;
        proxy_pass http://$upstream_kong;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_kong;
    }

    location @fallback_kong {
        return 503 "Kong Admin API is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/kong.error.log;
    access_log /var/log/nginx/kong.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name traefik.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_traefik traefik:8082;
        proxy_pass http://$upstream_traefik;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_traefik;
    }

    location @fallback_traefik {
        return 503 "Traefik service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/traefik.error.log;
    access_log /var/log/nginx/traefik.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name envoy.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_envoy envoy:9901;
        proxy_pass http://$upstream_envoy;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_envoy;
    }

    location @fallback_envoy {
        return 503 "Envoy Admin UI is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/envoy.error.log;
    access_log /var/log/nginx/envoy.access.log;
}

# MONITORING EXPORTERS
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name blackbox.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_blackbox blackbox-exporter:9115;
        proxy_pass http://$upstream_blackbox;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_blackbox;
    }

    location @fallback_blackbox {
        return 503 "Blackbox Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/blackbox.error.log;
    access_log /var/log/nginx/blackbox.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name mongodb-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_mongodb_exporter mongodb-exporter:9216;
        proxy_pass http://$upstream_mongodb_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_mongodb_exporter;
    }

    location @fallback_mongodb_exporter {
        return 503 "MongoDB Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/mongodb-exporter.error.log;
    access_log /var/log/nginx/mongodb-exporter.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name mysql-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_mysql_exporter mysqld-exporter:9104;
        proxy_pass http://$upstream_mysql_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_mysql_exporter;
    }

    location @fallback_mysql_exporter {
        return 503 "MySQL Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/mysql-exporter.error.log;
    access_log /var/log/nginx/mysql-exporter.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name node-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_node_exporter node-exporter:9100;
        proxy_pass http://$upstream_node_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_node_exporter;
    }

    location @fallback_node_exporter {
        return 503 "Node Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/node-exporter.error.log;
    access_log /var/log/nginx/node-exporter.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name postgres-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_postgres_exporter postgres-exporter:9187;
        proxy_pass http://$upstream_postgres_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_postgres_exporter;
    }

    location @fallback_postgres_exporter {
        return 503 "PostgreSQL Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/postgres-exporter.error.log;
    access_log /var/log/nginx/postgres-exporter.access.log;
}

server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name redis-exporter.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_redis_exporter redis-exporter:9121;
        proxy_pass http://$upstream_redis_exporter;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_redis_exporter;
    }

    location @fallback_redis_exporter {
        return 503 "Redis Exporter service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/redis-exporter.error.log;
    access_log /var/log/nginx/redis-exporter.access.log;
}

# PROJECT MANAGEMENT
server {
    listen 80;
    http2 on;
    listen 443 ssl;
    server_name openproject.test;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    location / {
        set $upstream_openproject openproject-web:8080;
        proxy_pass http://$upstream_openproject;
        include /data/nginx/custom/server_proxy.conf;
        error_page 502 503 504 = @fallback_openproject;
    }

    location @fallback_openproject {
        return 503 "OpenProject service is temporarily unavailable";
        add_header Content-Type text/plain always;
    }

    error_log /var/log/nginx/openproject.error.log;
    access_log /var/log/nginx/openproject.access.log;
}

# DEVELOPMENT PROJECTS (.test domains) - UNIFIED APPROACH
server {
    listen 80 default_server;
    http2 on;
    listen 443 ssl default_server;
    server_name ~^(?<appname>[^.]+)\.test$;

    ssl_certificate /etc/ssl/certs/local.crt;
    ssl_certificate_key /etc/ssl/private/local.key;

    if ($scheme != "https" ) {
        return 301 https://$host$request_uri;
    }

    # Check if this is a known infrastructure service first
    # If it matches any of the specific server blocks above, those take precedence

    # ============================================================================
    # BACKEND RUNTIME UPSTREAMS
    # ============================================================================
    # Container service endpoints for reverse proxying to backend runtimes
    # ============================================================================

    # Node.js upstream
    set $upstream_node "node:3000";

    # Python upstream
    set $upstream_python "python:8000";

    # Go upstream
    set $upstream_go "go:8080";

    # .NET upstream
    set $upstream_dotnet "dotnet:8080";

    # Rust upstream
    set $upstream_rust "rust:8080";
    
    # ============================================================================
    # SMART DOCUMENT ROOT DETECTION
    # ============================================================================
    # Automatically detects and serves from build output directories:
    #   Priority 1: dist/     (Vite, Vue CLI)
    #   Priority 2: build/    (Create React App)
    #   Priority 3: out/      (Next.js static export)
    #   Priority 4: public/   (Laravel, WordPress, legacy)
    #   Fallback:   app root  (plain PHP/HTML)
    # ============================================================================

    # Phase 1: File Existence Checks - Detect entry points in each directory
    set $dist_html 0;
    set $dist_php 0;
    set $build_html 0;
    set $build_php 0;
    set $out_html 0;
    set $public_html 0;
    set $public_php 0;

    # Check dist/ directory (Vite, Vue CLI, etc.)
    if (-f /var/www/html/$appname/dist/index.html) {
        set $dist_html 1;
    }
    if (-f /var/www/html/$appname/dist/index.php) {
        set $dist_php 1;
    }

    # Check build/ directory (Create React App, etc.)
    if (-f /var/www/html/$appname/build/index.html) {
        set $build_html 1;
    }
    if (-f /var/www/html/$appname/build/index.php) {
        set $build_php 1;
    }

    # Check out/ directory (Next.js static export)
    if (-f /var/www/html/$appname/out/index.html) {
        set $out_html 1;
    }

    # Check public/ directory (Laravel, WordPress, etc.)
    if (-f /var/www/html/$appname/public/index.html) {
        set $public_html 1;
    }
    if (-f /var/www/html/$appname/public/index.php) {
        set $public_php 1;
    }

    # Phase 2: Priority Resolution - Set docroot in reverse priority order
    # Lower priorities set first, higher priorities override
    set $docroot "/var/www/html/$appname";  # Default fallback: app root

    # Priority 4: public/ directory (Laravel, WordPress, legacy apps)
    set $check_public "${public_html}${public_php}";
    if ($check_public ~ "[1]") {
        set $docroot "/var/www/html/$appname/public";
    }

    # Priority 3: out/ directory (Next.js static export)
    if ($out_html = 1) {
        set $docroot "/var/www/html/$appname/out";
    }

    # Priority 2: build/ directory (Create React App, etc.)
    set $check_build "${build_html}${build_php}";
    if ($check_build ~ "[1]") {
        set $docroot "/var/www/html/$appname/build";
    }

    # Priority 1: dist/ directory (Vite, Vue CLI) - HIGHEST PRIORITY
    set $check_dist "${dist_html}${dist_php}";
    if ($check_dist ~ "[1]") {
        set $docroot "/var/www/html/$appname/dist";
    }

    # Apply resolved document root
    root $docroot;
    index index.php index.html index.htm;

    # ============================================================================
    # LANGUAGE RUNTIME DETECTION
    # ============================================================================
    # Detects app language by framework markers and routes accordingly
    # Priority order determines language if multiple markers exist
    # ============================================================================

    set $app_lang "static";  # Default: static files only (no backend)

    # Detect Node.js (package.json presence)
    if (-f /var/www/html/$appname/package.json) {
        set $app_lang "node";
    }

    # Detect Python (requirements.txt or manage.py)
    if (-f /var/www/html/$appname/requirements.txt) {
        set $app_lang "python";
    }
    if (-f /var/www/html/$appname/manage.py) {
        set $app_lang "python";
    }

    # Detect Go (go.mod)
    if (-f /var/www/html/$appname/go.mod) {
        set $app_lang "go";
    }

    # Detect .NET (appsettings.json is a reliable marker)
    if (-f /var/www/html/$appname/appsettings.json) {
        set $app_lang "dotnet";
    }

    # Detect Rust (Cargo.toml)
    if (-f /var/www/html/$appname/Cargo.toml) {
        set $app_lang "rust";
    }

    # Detect PHP (composer.json or index.php in docroot)
    # PHP gets priority if both markers exist (e.g., Laravel with frontend build)
    if (-f /var/www/html/$appname/composer.json) {
        set $app_lang "php";
    }
    if (-f $docroot/index.php) {
        set $app_lang "php";
    }

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Debug headers (helpful for development)
    add_header X-Resolved-Docroot $docroot always;
    add_header X-Detected-Language $app_lang always;

    # ============================================================================
    # PRIMARY ROUTING LOGIC
    # ============================================================================
    # Routes based on detected language and file type
    # Static files always served by Nginx, dynamic requests proxied to containers
    # ============================================================================

    location / {
        # Static files first (all languages) - if file exists, serve it directly
        # If not found, route to @app_router for backend processing
        # Note: removed $uri/ to prevent 403 on directories without index files
        try_files $uri @app_router;
    }

    # Application router - handles dynamic requests based on detected language
    location @app_router {
        # PRIORITY 1: Check for static SPA builds (dist/index.html or build/index.html)
        # If found, serve the SPA instead of proxying to backend
        # This handles cases like Vite/React builds that don't need a backend server
        if (-f $docroot/index.html) {
            rewrite ^ /index.html break;
        }

        # PRIORITY 2: Proxy to backend servers for SSR or API-driven apps
        # Proxy configuration headers (applied to all proxy_pass calls)
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;

        # Timeouts and buffers for development (Next.js can be slow during dev builds)
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_buffering off;

        # Node.js apps - reverse proxy to Node container
        # Only proxy if NOT a static SPA (checked above)
        if ($app_lang = "node") {
            proxy_pass http://$upstream_node;
            break;
        }

        # Python apps - reverse proxy to Python container
        if ($app_lang = "python") {
            proxy_pass http://$upstream_python;
            break;
        }

        # Go apps - reverse proxy to Go container
        if ($app_lang = "go") {
            proxy_pass http://$upstream_go;
            break;
        }

        # .NET apps - reverse proxy to .NET container
        if ($app_lang = "dotnet") {
            proxy_pass http://$upstream_dotnet;
            break;
        }

        # Rust apps - reverse proxy to Rust container
        if ($app_lang = "rust") {
            proxy_pass http://$upstream_rust;
            break;
        }

        # PHP apps - try index.php with query string (processed by PHP block below)
        if ($app_lang = "php") {
            rewrite ^ /index.php?$query_string last;
        }

        # Static-only apps - SPA fallback
        try_files /index.html =404;
    }

    # WebSocket support for various frameworks
    location ~ ^/(ws|websocket|socket\.io|_next/webpack-hmr|sockjs-node) {
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Route based on detected language
        if ($app_lang = "node") { proxy_pass http://$upstream_node; }
        if ($app_lang = "python") { proxy_pass http://$upstream_python; }
        if ($app_lang = "dotnet") { proxy_pass http://$upstream_dotnet; }
        if ($app_lang = "rust") { proxy_pass http://$upstream_rust; }
    }

    # Dashboard API - serve from app root, not dist/
    location ~ ^/api/.*\.php$ {
        # Override docroot for API paths to always use app root
        set $api_script /var/www/html/$appname$fastcgi_script_name;

        # Check if API file exists at app root
        if (!-f $api_script) {
            return 404;
        }

        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        set $upstream_php php:9000;
        fastcgi_pass $upstream_php;

        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $api_script;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_param HTTPS on;

        error_page 502 503 504 = @fallback_php;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        
        # Direct PHP connection - no upstream needed
        set $upstream_php php:9000;
        fastcgi_pass $upstream_php;
        
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_param HTTPS on;
        
        # Handle PHP service being down
        error_page 502 503 504 = @fallback_php;
    }
    
    location @fallback_php {
        return 503 "PHP service is temporarily unavailable. Please start the PHP container.";
        add_header Content-Type text/plain always;
    }

    location ~ /\. {
        deny all;
    }

    location = /favicon.ico {
        access_log off;
        log_not_found off;
    }

    location = /robots.txt {
        access_log off;
        log_not_found off;
    }

    location ~* wp-config.php$ {
        deny all;
    }

    error_log /var/log/nginx/$appname.error.log;
    access_log /var/log/nginx/$appname.access.log;
}
